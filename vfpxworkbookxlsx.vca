*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ЎЎATENCION!! - ЎЎNO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="vfpxworkbookxlsx.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS vfpxworkbookxlsx AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "vfpxworkbookxlsx.h"
	*<DefinedPropArrayMethod>
		*m: addclassdefinednumericformats		&& Adds pre-defined numeric cell formats
		*m: addcustomnumericformat		&& Adds a new custom defined numeric format
		*m: addindexcolor		&& Adds a new indexed color definition
		*m: addinlinefontobject		&& Adds an object for setting the inline formatting of cell text
		*m: addmrucolor		&& Adds a custom defined MRU color to the workbook
		*m: addnamedrange		&& Adds a name range to the workbook
		*m: addnumericformat		&& Adds a numeric format expression to be used
		*m: addsheet		&& Adds a new sheet to the workbook
		*m: addstringvalue		&& Adds a string value to the internal cursor
		*m: addstyleborders		&& Adds to the cell style a border definition
		*m: addstylefill		&& Adds to the cell style a fill definition
		*m: addstylefont		&& Adds to the cell style a font definition
		*m: addstylehorizalignment		&& Adds to the cell style horizontal cell alignment
		*m: addstyleindent		&& Adds to the style indent definition
		*m: addstylenumericformat		&& Adds to the style definition numeric format
		*m: addstyletextrotation		&& Adds to the style definition text rotation
		*m: addstylevertalignment		&& Adds to the cell style vertical cell alignment
		*m: addstylewordwrap		&& Adds to the style definition word wrap
		*m: cellformatpainter		&& Copies the formatting of a source cell to other cells
		*m: cellrefasciitoindex		&& Converts a 'AA444' cell reference to the row and column index values
		*m: clearcellvalidation		&& Clears/deletes the named range from the workbook
		*m: clearcellvalue		&& Clears the cell value
		*m: columnasciitoindex		&& Converts Excel Ascii column value to index value
		*m: columnindextoascii		&& Gets the column ASCII code for the column index
		*m: convertcolortohex		&& Converts a color value (integer) to Hex representation
		*m: converthexstringtonumeric		&& ConvertHexStringToNumeric
		*m: convertpixelstoexcelunits		&& Converts Pixel measurement to Excel measurement
		*m: createexcelfile		&& Creates the Excel file from the components
		*m: createformatstyle		&& Creates a new format style definition
		*m: createinlineformattext		&& Creates an in-line text formatted definition
		*m: createworkbook		&& Creates a new workbook object
		*m: createworkbookex		&& Internal method for creating a workbook
		*m: createworkingcursors		&& Creates the working cursors for worksheet definitions
		*m: createworkingdirectories		&& Creates the working directories for the XML files
		*m: debugcursorstofile		&& Debugging use for saving the internal cursors to a text file
		*m: debugoutput		&& Limited functions for debugging
		*m: debug_assign
		*m: declaredll		&& Declares the required support Win32 API
		*m: deleteallworkbooks		&& Deletes all workbooks
		*m: deletesheet		&& Deletes the sheet from the Workbook
		*m: deleteworkbook		&& Deletes the selected workbook
		*m: demo		&& Demo for the features of this class
		*m: derivesheetname		&& Derives the sheet name
		*m: destroyworkingcursors		&& Destroys the working cursors
		*m: documentation		&& Documentation of the methods and properties for this class
		*m: freezepanes		&& Freezes the panes of the sheet
		*m: getalphanumericsplit		&& Returns the position of the alpha and numeric split
		*m: getbordersrecord		&& Gets the border record; returns True if found, or False in not found
		*m: getcellalignment		&& Returns the cell alignment
		*m: getcellborders		&& Returns the cell border info
		*m: getcelldatatype		&& Returns the data type for the selected cell
		*m: getcellfill		&& Returns the fill info for the cell
		*m: getcellfont		&& Returns the cell font settings
		*m: getcellformula		&& Returns the cell formula expression
		*m: getcellformulafromxml		&& Gets the cell formula from the XML node
		*m: getcellindent		&& Returns the cell indentation
		*m: getcellnumberformat		&& Returns the format code for the selected cell
		*m: getcellnumberformattext		&& Returns the selected cell numeric format as text
		*m: getcellrecord		&& Positions to the xl_cells record; returns true if found, or false if not found
		*m: getcellstyle		&& Gets the cell style value
		*m: getcelltextrotation		&& Gets the cell text rotation value
		*m: getcellvalidation		&& Returns the cell validation settings
		*m: getcellvalue		&& Returns the value of the cell
		*m: getcellwordwrap		&& Returns the cell word wrap setting
		*m: getcellxfsid		&& Returns the Cell XfsId value
		*m: getcellxfsrecord		&& Positions the record pointer to xl_cellxfs record; returns true if found, or false if not found
		*m: getchecksum		&& Returns the checksum the string
		*m: getchildnodecount		&& Returns the number of child nodes
		*m: getchildnodeelement		&& Returns the selected child node
		*m: getcolumnincolrowpair		&& Returns the column (Ascii value) in a ColRow pair; i.e., returns A from A6 reference
		*m: getcolumnwidth		&& Returns the column width
		*m: getcolwidthkeyexpr		&& Gets the key expression for c_colwidths
		*m: getcursorrecord		&& Gets the specified xl_cursor record; returns true if found, false if not found
		*m: getcustomnumericformat		&& Returns the format code for the specified custom numeric format
		*m: getcustompapersize		&& Gets the values for the custom paper size
		*m: getformatkeyexpr		&& Gets the key expression for t_format
		*m: getheaderfooterkeyexpr		&& Gets the key expression for the header footer table record
		*m: getinlinefontdefinition		&& Returns the inline formatting definition of cell text for each character group
		*m: getlastcolumninrow		&& Returns the last column index in the row
		*m: getlastrownumber		&& Returns the last row number in the sheet
		*m: getmaxcolumnnumber		&& Returns the max column number for a sheet
		*m: getnextid		&& Gets the next sequential Id value
		*m: getnodeattributevalue		&& Returns the attribute value
		*m: getnodecount		&& Returns the number of nodes to be processed
		*m: getnodeelement		&& Gets the string content for the node element
		*m: getnodeelementvalue		&& Gets the value assigned to the node element
		*m: getnumberofsheets		&& Returns the number of sheets for the given workbook
		*m: getpapersize		&& Gets the paper size for the selected sheet
		*m: getprintorientation		&& Gets the print orientation for the sheet output
		*m: getrelationshipfilename		&& Gets the file name for the R:Id value in the relationships XML
		*m: getrgbvalues		&& Gets the specified RGB color value
		*m: getrowheightkeyexpr		&& Gets the key expression for the c_rowheights
		*m: getrowincolrowpair		&& REturns the row (integer value) in a ColRow pair; i.e., return 6 from A6 reference
		*m: getrowmaxcolumn		&& Returns the selected row maximum column
		*m: getsharedstringid		&& Gets the Shared Strings Id value for the cell text
		*m: getsheetname		&& Gets the sheet name
		*m: getsheetrecord		&& Positions the record in xl_sheets; returns true if record found, or false if not found
		*m: getsheetrowvalues		&& Returns the cell values for the given row
		*m: getsheetscale		&& Gets the sheet printing scale
		*m: getstringrecord		&& Positions the record pointer to the selected string record
		*m: getstringxml		&& Returns a converted string from XML to text
		*m: getvalidation		&& Returns the validation definition
		*m: getvalidationlist		&& Returns a list of validations for the workbook/sheet
		*m: getworkbook		&& Gets the workbook Id from the name
		*m: getworkbookfilename		&& Gets the file name for the workbook index
		*m: getworkbooksheets		&& Returns the workbook sheets
		*m: getxmlheaderfootertext		&& Returns a XML formatted string for the header and footer text
		*m: getxmlstring		&& Gets the string as an XML formatted string
		*m: initalizeidvalues		&& Initializes the internal Id values
		*m: insertcell		&& Inserts a new cell into the sheet
		*m: insertcolumn		&& Inserts a new column into the sheet
		*m: insertrow		&& Inserts a new row into the sheet
		*m: iscellformula		&& Returns True if cell contains a formula
		*m: iscellreferenceinvalid		&& Checks if the cell reference is invalid (outside of limits)
		*m: isformatstyledefined		&& Determines if the format is defined as a style
		*m: isvalidborderstyle		&& Validates the border style value
		*m: mergecells		&& Merges cells together
		*m: ondestroy		&& Called by the Destroy() event - user implementation
		*m: oninit		&& User code for Init() Event
		*m: onshowerrormessage		&& Event for displaying an error message to the user
		*m: onshowstatusmessage		&& Event for displaying a wait message to the user
		*m: opencreatedxlsxfile		&& Opens the XLSX file via Win32 API default program
		*m: openxlsxworkbook		&& Opens the passed Xlsx workbook and loads the internal cursors with the content
		*m: parsestring		&& Parses a string based on a specified delimiter
		*m: readcellvalueformat		&& Reads the cell value and format for a sheet
		*m: readexternalrefxml		&& Reads the External References file
		*m: readsharedstringsxml		&& Reads the sharedstrings.xml for opening workbooks
		*m: readsheetxml		&& Reads the sheet.xml for opening a workbook
		*m: readstylesxml		&& Reads the styles.xml file for opening a workbook
		*m: removeworkingdirectories		&& Removes the working directories
		*m: renamesheet		&& Renames the selected sheet
		*m: resetcolumnwidth		&& Resets the column width to default
		*m: saveasutf8		&& Saves the file as a UTF-8
		*m: savegridtoworkbook		&& Saves the selected grid to a workbook
		*m: savegridtoworkbookex		&& Saves the passed grid to a workbook without adding the content to the internal cursors
		*m: savemultigridtoworkbookex		&& Same as SaveGridToWorkbookEx() method but handles multiple grids being passed
		*m: savetabletoworkbook		&& Saves the table passed (alias) as a workbook sheet
		*m: savetabletoworkbookex		&& Creates a new workbook from a table; direct write to XLSX file without loading internal cursors
		*m: saveworkbook		&& Saves the selected workbook as an XLSX file
		*m: saveworkbookas		&& Saves the selected workbook with the new name
		*m: setcellalignment		&& Sets the cell horizontal and vertical alignments
		*m: setcellalignmentrange		&& Sets the cell alignment for a range of cells
		*m: setcellborder
		*m: setcellborderex
		*m: setcellborderrange		&& Sets the cell border for a range of cells
		*m: setcellfill		&& Sets the fill color for the cell
		*m: setcellfillrange		&& Sets the fill for a range of cells
		*m: setcellfont		&& Sets the selected cell font format
		*m: setcellfontrange		&& Sets the cell font format for a range of cells
		*m: setcellformula		&& Sets the cell formula expression
		*m: setcellindent		&& Sets the cell indentation value
		*m: setcellinlineformattext		&& Saves the in-line format definition to a cell value
		*m: setcellnumberdecimals		&& Sets the number of decimals to display
		*m: setcellnumberformat		&& Sets the cell number format
		*m: setcellnumberformatrange		&& Sets the number format for a range of cells
		*m: setcellstyle		&& Sets the cell style
		*m: setcellstylerange		&& Sets the cell style for a range of cells
		*m: setcelltextrotation		&& Sets the cell text rotation value
		*m: setcellvalidation		&& Adds a cell validation
		*m: setcellvalue		&& Sets the cell value
		*m: setcellwordwrap		&& Sets the cell word-wrapping value
		*m: setcellwordwraprange		&& Sets the word wrap for a range of cells
		*m: setcolumnbestfit		&& Set the column to best fit
		*m: setcolumnwidth		&& Sets the column width
		*m: setcolumnwidthrange		&& Sets the column width for a range of columns
		*m: setcustompapersize		&& Sets the paper size based on custom dimensions
		*m: setdefaultborder		&& Sets the default border style for the workbook
		*m: setdefaultfill		&& Sets the default fill for the workbook
		*m: setdefaultfont		&& Sets the default font for the workbook
		*m: setheaderfootersetup		&& Sets the header and footer setup for the sheet
		*m: setheaderfootertext		&& Sets the header/footer text for the sheet
		*m: setlastid		&& Sets the last used Id Value for strings, borders, fills, fonts, and cellxfs
		*m: setpapersize		&& Sets the paper size for the selected sheet
		*m: setprintfittoheight		&& Number of vertical pages to fit on for printing
		*m: setprintfittowidth		&& Number of horizontal pages to fit on for printing
		*m: setprintorientation		&& Sets the printer orientation for sheet output
		*m: setrowheight		&& Sets the row height
		*m: setrowheightrange		&& Sets the row height for a range of rows
		*m: setrowmaxcolumn		&& Sets the value for the maximum cell column in a row
		*m: setsheetmargins		&& Sets the sheet margin values
		*m: setsheetscale		&& Sets the print scale; must be between 10 and 400; i.e. 10=10%, 100=100%, etc.
		*m: setsheetvisibility		&& Sets the sheet visibility
		*m: ttoc3		&& Equlivalent of TTOC() function for pre VFP9 support
		*m: unfreezepanes		&& Removes the pane freeze from the sheet
		*m: unmergedcells		&& Unmerges merged cells
		*m: writeasinlineformattedstring		&& Writes the string as formatted in-line
		*m: writeasinlinestring		&& Writes the value as an inlineStr value
		*m: writedirectcellformattedvalue		&& WriteDirectCellFormattedValue
		*m: writedirectcellvalue		&& Writes the cell value directly to the sheets xml
		*m: writedirectxmls		&& Writes the workbook XMLs for direct table/grid to workbook output
		*m: writerelationshipsxml		&& Writes the relationships xml file
		*m: writesheetxmls		&& Writes the Sheet XML files
		*m: writestringsxml		&& Writes the sharedStrings XML
		*m: writestylesxml		&& Writes the styles.xml support file
		*m: writesupportxmls		&& Writes the [Content_Types].xml, .rels, core.xml, workbook.xml.rels and app.xml files
		*m: writeworkbookxml		&& Writes the workbook XML
		*p: autotrimsheetname		&& Indicates to auto-trim sheet name to max length ***Boolean
		*p: codepage		&& CodePage to use for the Strings cursor
		*p: companyname		&& Company Name
		*p: creatorname		&& Creator Name
		*p: debug		&& Sets debugging mode ***Boolean
		*p: declarewinapi		&& Flag to execute the DeclareDLL method in the Init() ***Boolean
		*p: defaultfont		&& Workbook Default Font
		*p: defaultfontsize		&& Default font size ***Integer
		*p: defaultsheetname		&& Default sheet name (language specific)
		*p: errorlevelid		&& Error level Id ***Integer
		*p: excelxlsxrelease		&& Release version of Class ***Integer
		*p: oxdom		&& XML DOM Object
		*p: savecurrencyasnumeric		&& Flag to save a currency value as a numeric rather than currency in the spreadsheet; will convert the value to four decimal places ***Boolean
		*p: subject		&& Subject of Workbook (stored in properties)
		*p: title		&& Title of workbook (stored in properties)
		*p: truefalsevalue		&& The boolean value as displayed in Excel delimited by a pipe symbol
		*p: username		&& User Name
		*a: lastborderid[1,2]		&& Stores the last used border Id for a workbook
		*a: lastcellxfsid[1,2]		&& Stores the last used CellXfs Id for a workbook
		*a: lastfillid[1,2]		&& Stores the last used fill Id for a workbook
		*a: lastfontid[1,2]		&& Stores the last used font Id for a workbook
		*a: lastindexcolorid[1,2]		&& Last used IndexedColor Id
		*a: lastmrucolorid[1,2]		&& Last used mruColor Id value
		*a: lastnumfmtid[1,2]		&& Last used NumFmt Id
		*a: lastrelationid[1,2]		&& Last used Relationship Id
		*a: lastsheetid[1,2]		&& Last used sheet Id
		*a: laststringid[1,2]		&& Stores the last used string Id for a workbook
		*a: stringndx[1,0]		&& Returns the next string index value by workbook ***Integer
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED Destroy,Init
	AutoSize = .T.
	autotrimsheetname = .T.		&& Indicates to auto-trim sheet name to max length ***Boolean
	Caption = "clsVFPxWorkbookXLSX"
	codepage = 0		&& CodePage to use for the Strings cursor
	companyname = VFPxWorkbookXLSX		&& Company Name
	creatorname = VFPxWorkbookXLSX		&& Creator Name
	debug = .F.		&& Sets debugging mode ***Boolean
	declarewinapi = .T.		&& Flag to execute the DeclareDLL method in the Init() ***Boolean
	defaultfont = Calibri		&& Workbook Default Font
	defaultfontsize = 11		&& Default font size ***Integer
	defaultsheetname = Sheet		&& Default sheet name (language specific)
	errorlevelid = 0		&& Error level Id ***Integer
	excelxlsxrelease = 31		&& Release version of Class ***Integer
	Height = 17
	Name = "vfpxworkbookxlsx"
	oxdom = 		&& XML DOM Object
	savecurrencyasnumeric = .F.		&& Flag to save a currency value as a numeric rather than currency in the spreadsheet; will convert the value to four decimal places ***Boolean
	subject = 		&& Subject of Workbook (stored in properties)
	title = 		&& Title of workbook (stored in properties)
	truefalsevalue = Yes|No		&& The boolean value as displayed in Excel delimited by a pipe symbol
	username = VFPxWorkbookXLSX		&& User Name
	Visible = .F.
	Width = 129
	_memberdata = <VFPData>
		<memberdata name="autotrimsheetname" type="property" display="AutoTrimSheetName"/>
		<memberdata name="defaultfontsize" type="property" display="DefaultFontSize"/>
		<memberdata name="cellrefasciitoindex" type="method" display="CellRefAsciiToIndex"/>
		<memberdata name="getchecksum" type="method" display="GetCheckSum"/>
		<memberdata name="getstringrecord" type="method" display="GetStringRecord"/>
		<memberdata name="initalizeidvalues" type="method" display="InitalizeIdValues"/>
		<memberdata name="insertcell" type="method" display="InsertCell"/>
		<memberdata name="addclassdefinednumericformats" type="method" display="AddClassDefinedNumericFormats"/>
		<memberdata name="addcustomnumericformat" type="method" display="AddCustomNumericFormat"/>
		<memberdata name="addindexcolor" type="method" display="AddIndexColor"/>
		<memberdata name="addinlinefontobject" type="method" display="AddInlineFontObject"/>
		<memberdata name="addmrucolor" type="method" display="AddMruColor"/>
		<memberdata name="addnamedrange" type="method" display="AddNamedRange"/>
		<memberdata name="addnumericformat" type="method" display="AddNumericFormat"/>
		<memberdata name="addsheet" type="method" display="AddSheet"/>
		<memberdata name="addstringvalue" type="method" display="AddStringValue"/>
		<memberdata name="addstyleborders" type="method" display="AddStyleBorders"/>
		<memberdata name="addstylefill" type="method" display="AddStyleFill"/>
		<memberdata name="addstylefont" type="method" display="AddStyleFont"/>
		<memberdata name="addstylehorizalignment" type="method" display="AddStyleHorizAlignment"/>
		<memberdata name="addstyleindent" type="method" display="AddStyleIndent"/>
		<memberdata name="addstylenumericformat" type="method" display="AddStyleNumericFormat"/>
		<memberdata name="addstyletextrotation" type="method" display="AddStyleTextRotation"/>
		<memberdata name="addstylevertalignment" type="method" display="AddStyleVertAlignment"/>
		<memberdata name="addstylewordwrap" type="method" display="AddStyleWordWrap"/>
		<memberdata name="cellformatpainter" type="method" display="CellFormatPainter"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROTECTED PROCEDURE addclassdefinednumericformats		&& Adds pre-defined numeric cell formats
		Lparameters tnWB, tnFormatId
		Local llAdded, lcTextFormat, lcXMLFormat
		
		llAdded = Inlist(tnFormatId, CELL_FORMAT_CURRENCY_RED, CELL_FORMAT_ACC_CURR_POUNDS, CELL_FORMAT_ACC_CURR_EURO,;
		 CELL_FORMAT_CURR_POUNDS_RED, CELL_FORMAT_CURR_EURO_RED)
		
		Do Case
		Case tnFormatId = CELL_FORMAT_CURRENCY_RED
		  lcTextFormat = '"$"#,##0.00;[Red]("$"#,##0.00)'
		  lcXMLFormat  = This.GetXMLString(lcTextFormat)
		
		Case tnFormatId = CELL_FORMAT_ACC_CURR_POUNDS
		  lcXMLFormat  = '_-[$&#163;-809]* #,##0.00_-;-[$&#163;-809]* #,##0.00_-;_-[$&#163;-809]* &quot;-&quot;??_-;_-@_-'
		  lcTextFormat = '"Ј"#,##0.00;[Red]("Ј"#,##0.00)'
		
		Case tnFormatId = CELL_FORMAT_ACC_CURR_EURO
		  lcXMLFormat  = '_-[$&#8364;-2]* .00_-;-[$&#8364;-2]* .00_-;_-[$&#8364;-2]* &quot;-&quot;??_-;_-@_-'
		  lcTextFormat = '"Ђ"#,##0.00;[Red]("Ђ"#,##0.00)'
		
		Case tnFormatId = CELL_FORMAT_CURR_POUNDS_RED
		  lcXMLFormat  = '[$&#163;-809]#,##0.00;[Red]\-[$&#163;-809]#,##0.00'
		  lcTextFormat = '"Ј"#,##0.00;[Red]("Ј"#,##0.00)'
		
		Case tnFormatId = CELL_FORMAT_CURR_EURO_RED
		  lcXMLFormat  = '[$&#8364;-2]\ #,##0.00_);[Red]\([$&#8364;-2]\ #,##0.00\)'
		  lcTextFormat = '"Ђ"#,##0.00;[Red]("Ђ"#,##0.00)'
		EndCase
		
		If llAdded
		  Insert Into xl_numFmts (workbook, Id, formatxml, formatcode, applydec) ;
		    VALUES (tnWB, tnFormatId, lcXMLFormat, lcTextFormat, False)
		EndIf
		Return llAdded
		
	ENDPROC

	PROCEDURE addcustomnumericformat		&& Adds a new custom defined numeric format
		Lparameters tnWB, tcPosFormat, tcNegFormat, tcZeroFormat, tcTextFormat, tlApplyDec
		Local lnId, lcFormatCode, lnNdx, lcSetPoint, lcSeparator
		If Vartype(tcPosFormat) != "C"
		  Return 0
		Endif
		Do Case
		Case Pcount() = 1
		  tcNegFormat  = ""
		  tcZeroFormat = ""
		  tcTextFormat = ""
		  tlApplyDec   = False
		
		Case Pcount() = 2
		  tcZeroFormat = ""
		  tcTextFormat = ""
		  tlApplyDec   = False
		
		Case Pcount() = 3
		  tcTextFormat = ""
		  tlApplyDec   = False
		
		Case Pcount() = 4
		  tlApplyDec = False
		Endcase
		If Vartype(tcNegFormat) != "C"
		  tcNegFormat = ""
		Endif
		If Vartype(tcZeroFormat) != "C"
		  tcZeroFormat = ""
		Endif
		If Vartype(tcTextFormat) != "C"
		  tcTextFormat = ""
		Endif
		If Occurs(";", tcPosFormat) > 0 Or Occurs(";", tcNegFormat) > 0 Or Occurs(";", tcZeroFormat) > 0 Or Occurs(";", tcTextFormat) > 0
		  Return 0
		Endif
		*-*	If not US standard for separator and decimal point, then change to US standard
		lcSetPoint  = Set("POINT")
		lcSeparator = Set("SEPARATOR")
		If lcSetPoint != "." Or lcSeparator != ","
		  tcPosFormat = Chrtran(Chrtran(tcPosFormat, lcSetPoint + lcSeparator, Tab + CR), Tab + CR, ".,")
		  tcNegFormat = Chrtran(Chrtran(tcNegFormat, lcSetPoint + lcSeparator, Tab + CR), Tab + CR, ".,")
		  tcZeroFormat = Chrtran(Chrtran(tcZeroFormat, lcSetPoint + lcSeparator, Tab + CR), Tab + CR, ".,")
		  tcTextFormat = Chrtran(Chrtran(tcTextFormat, lcSetPoint + lcSeparator, Tab + CR), Tab + CR, ".,")
		Endif
		*-*	Build expression from parts
		lcFormatCode = tcPosFormat
		If !Empty(tcNegFormat)
		  lcFormatCode = lcFormatCode + ";" + tcNegFormat
		Endif
		If !Empty(tcZeroFormat)
		  lcFormatCode = lcFormatCode + ";" + tcZeroFormat
		Endif
		If !Empty(tcTextFormat)
		  lcFormatCode = lcFormatCode + ";" + tcTextFormat
		Endif
		lnId = This.GetNextId(tnWB, "xl_numfmts")
		Insert Into xl_numFmts (workbook, Id, formatxml, formatcode, applydec) ;
		  VALUES (tnWB, lnId, This.GetXMLString(lcFormatCode), lcFormatCode, tlApplyDec)
		Return lnId
		
	ENDPROC

	PROCEDURE addindexcolor		&& Adds a new indexed color definition
		Lparameters tnWB, tnRGBColor
		Local lnIndexId, lcHexColor
		If Pcount() != 2 Or Vartype(tnRGBColor) != "N"
		  Return 0
		Endif
		lcHexColor = This.ConvertColorToHex(tnRGBColor)
		If Seek(BinToC(tnWB)+lcHexColor, "xl_ndxcolors", "rgbcolor")
		  lnIndexId = xl_ndxcolors.indexid
		Else
		  lnIndexId = This.GetNextId(tnWB, "xl_ndxcolors")
		  Insert Into xl_ndxcolors (workbook, indexid, rgbcolor) Values (tnWB, lnIndexId, lcHexColor)
		Endif
		Return lnIndexId
		
	ENDPROC

	PROCEDURE addinlinefontobject		&& Adds an object for setting the inline formatting of cell text
		Lparameters toInline, tnBeg, tnLen, tcFontName, tnFontSize, tnFontColor, tlFontBold, tlFontItalic, tcULine, tlStrkThru, tlSubscript, tlSuperscript
		Local loCharacter
		If Pcount() < 4 or Vartype(toInline) != "O"
		  Return Null
		Endif
		Do Case
		Case Pcount() = 4
		  tnFontSize    = 10
		  tnFontColor   = Rgb(0,0,0)
		  tlFontBold    = False
		  tlFontItalic  = False
		  tcULine       = UNDERLINE_NONE
		  tlStrkThru    = False
		  tlSubscript   = False
		  tlSuperscript = False
		
		Case Pcount() = 5
		  tnFontColor   = Rgb(0,0,0)
		  tlFontBold    = False
		  tlFontItalic  = False
		  tcULine       = UNDERLINE_NONE
		  tlStrkThru    = False
		  tlSubscript   = False
		  tlSuperscript = False
		
		Case Pcount() = 6
		  tlFontBold    = False
		  tlFontItalic  = False
		  tcULine       = UNDERLINE_NONE
		  tlStrkThru    = False
		  tlSubscript   = False
		  tlSuperscript = False
		
		Case Pcount() = 7
		  tlFontItalic  = False
		  tcULine       = UNDERLINE_NONE
		  tlStrkThru    = False
		  tlSubscript   = False
		  tlSuperscript = False
		
		Case Pcount() = 8
		  tcULine       = UNDERLINE_NONE
		  tlStrkThru    = False
		  tlSubscript   = False
		  tlSuperscript = False
		
		Case Pcount() = 9
		  tlStrkThru    = False
		  tlSubscript   = False
		  tlSuperscript = False
		
		Case Pcount() = 10
		  tlSubscript   = False
		  tlSuperscript = False
		
		Case Pcount() = 11
		  tlSuperscript = False
		Endcase
		loCharacter = Createobject("Empty")
		AddProperty(loCharacter, "BegPos", tnBeg)
		AddProperty(loCharacter, "Length", tnLen)
		AddProperty(loCharacter, "FontName", tcFontName)
		AddProperty(loCharacter, "FontSize", tnFontSize)
		AddProperty(loCharacter, "FontBold", tlFontBold)
		AddProperty(loCharacter, "FontItalic", tlFontItalic)
		AddProperty(loCharacter, "FontColor", tnFontColor)
		AddProperty(loCharacter, "Underline", tcULine)
		AddProperty(loCharacter, "StrikeThru", tlStrkThru)
		AddProperty(loCharacter, "SubScript", tlSubscript)
		AddProperty(loCharacter, "SuperScript", tlSuperscript)
		
		toInline.Count = toInline.Count + 1
		Dimension toInline.Characters[toInline.Count]
		toInline.Characters[toInline.Count] = loCharacter
		
		Return toInline
		
	ENDPROC

	PROCEDURE addmrucolor		&& Adds a custom defined MRU color to the workbook
		Lparameters tnWB, tnRGBColor
		Local lnIndexId, lcHexColor
		If Pcount() != 2 Or Vartype(tnRGBColor) != "N"
		  Return 0
		Endif
		lcHexColor = This.ConvertColorToHex(tnRGBColor)
		If Seek(BinToC(tnWB)+lcHexColor, "xl_mrucolors", "rgbcolor")
		  lnIndexId = xl_mrucolors.indexid
		Else
		  lnIndexId = This.GetNextId(tnWB, "xl_mrucolors")
		  Insert Into xl_mrucolors (workbook, indexid, rgbcolor) Values (tnWB, lnIndexId, lcHexColor)
		Endif
		Return lnIndexId
		
	ENDPROC

	PROCEDURE addnamedrange		&& Adds a name range to the workbook
		Lparameters tnWB, tnSheet, tcName, tnScope, tcComment, tnBegRow, tnBegCol, tnEndRow, tnEndCol
		Local lcRangeName
		If Pcount() < 8 or Vartype(tcName) != "C" Or Len(tcName) > 50 or Len(tcComment) > 254 or tnBegRow > tnEndRow Or tnBegCol > tnEndCol
		  Return ""
		Endif
		If Vartype(tnScope) != "N"
		  tnScope = 0
		Endif
		If Vartype(tcComment) != "C"
		  tcComment = ""
		Endif
		lcRangeName = Chrtran(Alltrim(tcName), " !@#$%^&*()+={}[]|<>,.'?/" + Chr(34), Replicate("_", 25))
		If !Isalpha(lcRangeName) And !Inlist(Left(lcRangeName, 1), "_", "\")
		  lcRangeName = "_" + lcRangeName
		Endif
		If Seek(BinToC(tnWB), "xl_workbooks", "workbook") And !Seek(BinToC(tnWB)+Padl(lcRangeName, 254, " "), "xl_namerange", "wbrname")
		  Insert Into xl_namerange (workbook, Sheet, rname, scope, Comment, begrow, begcol, endrow, endcol) ;
		    VALUES (tnWB, tnSheet, lcRangeName, tnScope, tcComment, tnBegRow, tnBegCol, tnEndRow, tnEndCol)
		Else
		  lcRangeName = ""
		Endif
		Return lcRangeName
		
	ENDPROC

	PROCEDURE addnumericformat		&& Adds a numeric format expression to be used
		Lparameters tnWB, tcFormatCode
		Local lcPosCode, lcNegCode, lcZerCode
		If Pcount() < 2 Or (Vartype(tnWB) != "N" And tnWB > 0) Or Vartype(tcFormatCode) != "C"
		  Return 0
		Endif
		With This
		  lcPosCode = .ParseString(tcFormatCode, 1, ";")
		  lcNegCode = .ParseString(tcFormatCode, 2, ";")
		  lcZerCode = .ParseString(tcFormatCode, 3, ";")
		  Return .AddCustomNumericFormat(tnWB, lcPosCode, lcNegCode, lcZerCode)
		Endwith
		
	ENDPROC

	PROCEDURE addsheet		&& Adds a new sheet to the workbook
		Lparameters tnWB, tcSheetName, tnState
		Local lnShId, lnRelId
		lnShId = 0
		With This
		  If Pcount() > 0 And Seek(BinToC(tnWB), "xl_workbooks", "workbook")
		    lnShId = .GetNextId(tnWB, "xl_sheets")
		    Do Case
		    Case Pcount() = 0
		
		    Case Pcount() = 1
		      tcSheetName = "Sheet" + Transform(lnShId + 1)        && Bug fix identified by Dan Lauer
		      tnState = VISIBLE_SHEET_STATE
		
		    Case Pcount() = 2
		      If Vartype(tcSheetName) != "C"
		        tcSheetName = "Sheet" + Transform(lnShId + 1)
		      Endif
		      tnState = VISIBLE_SHEET_STATE
		
		    Otherwise
		      If Vartype(tcSheetName) != "C"
		        tcSheetName = "Sheet" + Transform(lnShId + 1)
		      Endif
		      If Vartype(tnState) != "N"
		        tnState = VISIBLE_SHEET_STATE
		      Endif
		    Endcase
		    If Empty(tcSheetName)
		      tcSheetName = "Sheet" + Transform(lnShId + 1)
		    Endif
		    tcSheetName = Chrtran(tcSheetName, ":\/?*", "_____")
		    If Len(tcSheetName) > LIMITS_MAX_SH_NAME
		      If .AutoTrimSheetName
		        tcSheetName = Left(Alltrim(tcSheetName), LIMITS_MAX_SH_NAME)
		      Else
		        .SetLastId(tnWB, lnShId-1, "xl_sheets")
		        Return 0
		      Endif
		    Endif
		    If Seek(BinToC(tnWB)+Upper(Padr(tcSheetName, Len(xl_sheets.shname))), "xl_sheets", "shname")    && Change recommendation by Doug Hennig
		      lnShId = 0
		    Else
		      Insert Into xl_sheets (workbook, Sheet, shname, state, mleft, mright, mtop, mbot, mheader, mfooter, shdeleted, xsplit, ysplit, prnorient, ;
		        papersize, Paperwidth, paperheight, Scale, fittowidth, fittoheight) ;
		        VALUES (tnWB, lnShId, tcSheetName, tnState, 0.75, 0.75, 0.75, 0.75, 0.3, 0.3, False, 0, 0, PORTRAIT_PRINT_ORIENTATION, 0, 0, 0, 100, 0, 0)
		
		      lnRelId = This.GetNextId(tnWB, "xl_relationships")
		      Insert Into xl_relationships (workbook, Sheet, relid, reltype, Target) Values (tnWB, lnShId, lnRelId, "worksheet", "worksheets/sheet" + Transform(lnShId) + ".xml")
		    Endif
		  Endif
		Endwith
		Return lnShId
		
	ENDPROC

	PROTECTED PROCEDURE addstringvalue		&& Adds a string value to the internal cursor
		Lparameters tnWB, tcString, tlInLine
		Local lcStringXml, lnStringId, llPresrvSp, lcCheckSum
		With This
		  If tlInLine
		    llPresrvSp  = Iif(Left(tcString, 1) = " ", True, False)
		    lcStringXml = .GetXMLString(tcString)
		    lnStringId  = .GetNextId(tnWB, "xl_strings")
		    lcCheckSum  = .GetCheckSum(tcString)
		    Insert Into xl_strings (Id, workbook, checksum, stringxml, stringval, presvspace, Formatted) ;
		      VALUES (lnStringId, tnWB, lcCheckSum, lcStringXml, tcString, llPresrvSp, True)
		  Else
		    If .GetStringRecord(tnWB, tcString) And xl_strings.Formatted = False
		      lnStringId = xl_strings.Id
		    Else
		      llPresrvSp  = Iif(Left(tcString, 1) = " " Or Right(tcString, 1) = " ", True, False)
		      lcStringXml = .GetXMLString(tcString)
		      lnStringId  = .GetNextId(tnWB, "xl_strings")
		      lcCheckSum  = .GetCheckSum(tcString)
		      Insert Into xl_strings (Id, workbook, checksum, stringxml, stringval, presvspace, Formatted) ;
		        VALUES (lnStringId, tnWB, lcCheckSum, lcStringXml, tcString, llPresrvSp, False)
		    Endif
		  Endif
		Endwith
		Return lnStringId
		
	ENDPROC

	PROCEDURE addstyleborders		&& Adds to the cell style a border definition
		Lparameters tnWB, tnCellXfsId, tnBorders, tcStyle, tnColor
		Local lnDiagDn, lnDiagUp, lcLStyle, lnLColor, lcRStyle, lnRColor, lcTStyle, lnTColor, lcBStyle, lnBColor
		Local lcDStyle, lnDColor, lnBorderId
		If Pcount() < 3
		  Return False
		Endif
		If Seek(BinToC(tnWB)+BinToC(tnCellXfsId), "xl_cellxfs", "id")
		  If Vartype(tnBorders) != 'N' Or Empty(tnBorders) Or !Between(tnBorders, 0, 63)
		    tnBorders = 0
		  Endif
		  If !This.IsValidBorderStyle(tcStyle)
		    tcStyle = BORDER_STYLE_NONE
		  Endif
		  If Vartype(tnColor) != 'N' Or !Between(tnColor, 0, Rgb(255,255,255)) Or Empty(tnColor)
		    tnColor = Rgb(0, 0, 0)
		  Endif
		  Store 0 To lnDiagDn, lnDiagUp
		  Store Rgb(0,0,0) To lnLColor, lnRColor, lnTColor, lnBColor, lnDColor
		  Store BORDER_STYLE_NONE To lcLStyle, lcRStyle, lcTStyle, lcBStyle, lcDStyle
		  If Bittest(tnBorders, 0)
		    lcLStyle = tcStyle
		    lnLColor = tnColor
		  Endif
		  If Bittest(tnBorders, 1)
		    lcRStyle = tcStyle
		    lnRColor = tnColor
		  Endif
		  If Bittest(tnBorders, 2)
		    lcTStyle = tcStyle
		    lnTColor = tnColor
		  Endif
		  If Bittest(tnBorders, 3)
		    lcBStyle = tcStyle
		    lnBColor = tnColor
		  Endif
		  If Bittest(tnBorders, 4)
		    lcDStyle = tcStyle
		    lnDColor = tnColor
		    lnDiagDn = 1
		  Endif
		  If Bittest(tnBorders, 5)
		    lcDStyle = tcStyle
		    lnDColor = tnColor
		    lnDiagUp = 1
		  Endif
		  If This.GetBordersRecord(tnWB, lcLStyle, lnLColor, lcRStyle, lnRColor, lcTStyle, lnTColor, lcBStyle, lnBColor, lcDStyle, lnDColor, lnDiagDn, lnDiagUp)
		    lnBorderId = xl_borders.Id
		  Else
		    lnBorderId = This.GetNextId(tnWB, 'xl_borders')
		    Insert Into xl_borders (workbook, Id, lstyle, lcolor, rstyle, rcolor, tstyle, tcolor, bstyle, bcolor, dstyle, dcolor, diagdn, diagup) ;
		      VALUES (tnWB, lnBorderId, lcLStyle, lnLColor, lcRStyle, lnRColor, lcTStyle, lnTColor, lcBStyle, lnBColor, lcDStyle, lnDColor, lnDiagDn, lnDiagUp)
		  Endif
		*-*	Set the border id to the style definition
		  Replace xl_cellxfs.borderid With lnBorderId In xl_cellxfs
		  Return True
		Else
		  Return False
		Endif
		
	ENDPROC

	PROCEDURE addstylefill		&& Adds to the cell style a fill definition
		Lparameters tnWB, tnCellXfsId, tnFColor, tnBColor, tcPatternType
		Local lnFillId, lnFIndex, lnBIndex
		Do Case
		Case Pcount() < 3
		  Return False
		
		Case Pcount() = 3
		  tnBColor = tnFColor
		  tcPatternType = FILL_STYLE_SOLID
		
		Case Pcount() = 4
		  tcPatternType = FILL_STYLE_SOLID
		Endcase
		If Seek(BinToC(tnWB)+BinToC(tnCellXfsId), "xl_cellxfs", "id")
		  If Vartype(tnFColor) = 'N' And Between(tnFColor, 0, Rgb(255, 255, 255))
		    tnFColor = Floor(tnFColor)
		    lnFIndex = 0
		  Else
		    tnFColor = 0
		    lnFIndex = 64
		  Endif
		  If Vartype(tnBColor) = 'N' And Between(tnBColor, 0, Rgb(255, 255, 255))
		    tnBColor = Floor(tnBColor)
		    lnBIndex = 0
		  Else
		    tnBColor = tnFColor
		    lnBIndex = lnFIndex
		  Endif
		  If Vartype(tcPatternType) != "C" Or Empty(tcPatternType)
		    tcPatternType = FILL_STYLE_SOLID
		  Endif
		*-*	Get the fill record id
		  If Seek(BinToC(tnWB)+BinToC(tnFColor)+BinToC(tnBColor)+tcPatternType, "xl_fills", "fillcolor")
		    lnFillId = xl_fills.Id
		    Replace xl_fills.Theme     With 0, ;
		      xl_fills.tint      With 0, ;
		      xl_fills.fgindexed With lnFIndex, ;
		      xl_fills.bgindexed With lnBIndex In xl_fills
		  Else
		    lnFillId = This.GetNextId(tnWB, 'xl_fills')
		    Insert Into xl_fills (workbook, Id, fgcolor, bgcolor, patttype, Theme, tint, fgindexed, bgindexed) ;
		      VALUES (tnWB, lnFillId, tnFColor, tnBColor, tcPatternType, 0, 0, lnFIndex, lnBIndex)
		  Endif
		*-*	Set the fill id to the style definition
		  Replace xl_cellxfs.fillid With lnFillId In xl_cellxfs
		  Return True
		Else
		  Return False
		Endif
		
	ENDPROC

	PROCEDURE addstylefont		&& Adds to the cell style a font definition
		Lparameters tnWB, tnCellXfsId, tcFName, tnFSize, tlBold, tlItalic, tnFColor, tcULine, tlStrikThr, tcVPos
		Local lnFontId
		If Pcount() < 3
		  Return False
		Endif
		If Seek(BinToC(tnWB)+BinToC(tnCellXfsId), "xl_cellxfs", "id")
		  If Vartype(tcFName) != 'C' Or Empty(tcFName)
		    tcFName = 'Calibri'
		  Endif
		  tcFName = Proper(Alltrim(tcFName))
		  tnFSize = Iif(Vartype(tnFSize) != 'N' Or Empty(tnFSize) Or tnFSize < 0.5, 11, Int(tnFSize))
		  If Vartype(tlBold) != 'L'
		    tlBold = False
		  Endif
		  If Vartype(tlItalic) != 'L'
		    tlItalic = False
		  Endif
		  tnFColor = Iif(Vartype(tnFColor) = 'N' And Between(tnFColor, 0, Rgb(255, 255, 255)), Floor(tnFColor), Rgb(0, 0, 0))
		  If Vartype(tlStrikThr) != 'L'
		    tlStrikThr = False
		  Endif
		  If Vartype(tcULine) != 'C' Or !Inlist(tcULine, UNDERLINE_SINGLE, UNDERLINE_DOUBLE, UNDERLINE_SINGLEACCOUNTING, UNDERLINE_DOUBLEACCOUNTING, UNDERLINE_NONE)
		    tcULine = UNDERLINE_NONE
		  Endif
		  If Vartype(tcVPos) != 'C' Or !Inlist(tcVPos, FONT_VERTICAL_BASELINE, FONT_VERTICAL_SUBSCRIPT, FONT_VERTICAL_SUPERSCRIPT)
		    tcVPos = FONT_VERTICAL_BASELINE
		  Endif
		*-*	Get the font record id
		  If Seek(BinToC(tnWB)+Padr(tcFName, 100) + Str(tnFSize, 5, 1) + Transform(tlBold) + Transform(tlItalic) + Padl(tnFColor, 15) + Padr(tcULine, 16) + ;
		      TRANSFORM(tlStrikThr) + Padr(tcVPos, 11), "xl_fonts", "cellformat")
		
		    lnFontId = xl_fonts.Id
		    Replace xl_fonts.Theme   With 0, ;
		      xl_fonts.tint    With 0, ;
		      xl_fonts.indexed With 0 In xl_fonts
		  Else
		    lnFontId = This.GetNextId(tnWB, 'xl_fonts')
		    Insert Into xl_fonts (workbook, Id, fname, Fsize, fbold, fitalic, fcolor, uline, strkthr, fvpos) ;
		      VALUES (tnWB, lnFontId, tcFName, tnFSize, tlBold, tlItalic, tnFColor, tcULine, tlStrikThr, tcVPos)
		  Endif
		*-*	Set the font id to the style definition
		  Replace xl_cellxfs.fontid With lnFontId In xl_cellxfs
		  Return True
		Else
		  Return False
		Endif
		
	ENDPROC

	PROCEDURE addstylehorizalignment		&& Adds to the cell style horizontal cell alignment
		Lparameters tnWB, tnCellXfsId, tcHorizAlign
		If Pcount() < 3
		  Return False
		Endif
		If Seek(BinToC(tnWB)+BinToC(tnCellXfsId), "xl_cellxfs", "id")
		  If Vartype(tcHorizAlign) = 'C' And Inlist(tcHorizAlign, CELL_HORIZ_ALIGN_LEFT, CELL_HORIZ_ALIGN_RIGHT, CELL_HORIZ_ALIGN_CENTER)
		    Replace xl_cellxfs.halign With tcHorizAlign In xl_cellxfs
		    Return True
		  Else
		    Return False
		  Endif
		Else
		  Return False
		Endif
		
	ENDPROC

	PROCEDURE addstyleindent		&& Adds to the style indent definition
		Lparameters tnWB, tnCellXfsId, tnIndent
		If Pcount() < 3
		  Return False
		Endif
		If Seek(BinToC(tnWB)+BinToC(tnCellXfsId), "xl_cellxfs", "id")
		  If Vartype(tnIndent) = 'N'
		    Replace xl_cellxfs.indent With tnIndent In xl_cellxfs
		    Return True
		  Else
		    Return False
		  Endif
		Else
		  Return False
		Endif
		
	ENDPROC

	PROCEDURE addstylenumericformat		&& Adds to the style definition numeric format
		Lparameters tnWB, tnCellXfsId, tnNumFmtId
		Local lnNumFmtId
		If Pcount() < 3
		  Return False
		Endif
		If Seek(BinToC(tnWB)+BinToC(tnCellXfsId), "xl_cellxfs", "id")
		  Do Case
		  Case Vartype(tnNumFmtId) != 'N'
		    Return False
		
		  Case tnNumFmtId < START_NUMERIC_FORMAT_ID
		    lnNumFmtId = tnNumFmtId
		
		  Case tnNumFmtId >= START_NUMERIC_FORMAT_ID
		    If Seek(BinToC(tnWB)+BinToC(tnNumFmtId), "xl_numfmts", "id")
		      lnNumFmtId = xl_numfmts.Id
		    Else
		      If !This.AddClassDefinedNumericFormats(tnWB, tnNumFmtId)
		        Return False
		      Endif
		      lnNumFmtId = tnNumFmtId
		    Endif
		
		  Otherwise
		    Return False
		  Endcase
		  Replace xl_cellxfs.numfmtid With lnNumFmtId In xl_cellxfs
		  Return True
		Else
		  Return False
		Endif
		
	ENDPROC

	PROCEDURE addstyletextrotation		&& Adds to the style definition text rotation
		Lparameters tnWB, tnCellXfsId, tnRotation
		If Pcount() < 3
		  Return False
		Endif
		If Seek(BinToC(tnWB)+BinToC(tnCellXfsId), "xl_cellxfs", "id")
		  If Vartype(tnRotation) = 'N' And Between(tnRotation, -90, 90)
		    Replace xl_cellxfs.Rotation With tnRotation In xl_cellxfs
		    Return True
		  Else
		    Return False
		  Endif
		Else
		  Return False
		Endif
		
	ENDPROC

	PROCEDURE addstylevertalignment		&& Adds to the cell style vertical cell alignment
		Lparameters tnWB, tnCellXfsId, tcVertAlign
		If Pcount() < 3
		  Return False
		Endif
		If Seek(BinToC(tnWB)+BinToC(tnCellXfsId), "xl_cellxfs", "id")
		  If Vartype(tcVertAlign) = 'C' And Inlist(tcVertAlign, CELL_VERT_ALIGN_TOP, CELL_VERT_ALIGN_BOTTOM, CELL_VERT_ALIGN_CENTER)
		    Replace xl_cellxfs.valign With tcVertAlign In xl_cellxfs
		    Return True
		  Else
		    Return False
		  Endif
		Else
		  Return False
		Endif
		
	ENDPROC

	PROCEDURE addstylewordwrap		&& Adds to the style definition word wrap
		Lparameters tnWB, tnCellXfsId, tlWordWrap
		If Pcount() < 3
		  Return False
		Endif
		If Seek(BinToC(tnWB)+BinToC(tnCellXfsId), "xl_cellxfs", "id")
		  If Vartype(tlWordWrap) = 'L'
		    Replace xl_cellxfs.wraptext With Iif(tlWordWrap, 1, 0) In xl_cellxfs
		    Return True
		  Else
		    Return False
		  Endif
		Else
		  Return False
		Endif
		
	ENDPROC

	PROCEDURE cellformatpainter		&& Copies the formatting of a source cell to other cells
		Lparameters tnWB, tnSheet, tnSrcRow, tnSrcCol, tnBegRow, tnBegCol, tnEndRow, tnEndCol
		Local lnCellXfs, lnNumDec, llReturn, lnRow, lnCol
		Do Case
		Case Pcount() < 6
		  Return False
		
		Case Pcount() = 6
		  tnEndRow = tnBegRow
		  tnEndCol = tnBegCol
		
		Case Pcount() = 7
		  tnEndCol = tnBegCol
		Endcase
		If This.GetCellRecord(tnWB, tnSheet, tnSrcRow, tnSrcCol)
		  lnCellXfs = xl_cells.cellxfs
		  lnNumDec  = xl_cells.numdec
		  For lnRow=tnBegRow To tnEndRow
		    For lnCol=tnBegCol To tnEndCol
		      If This.GetCellRecord(tnWB, tnSheet, lnRow, lnCol)
		        Replace xl_cells.cellxfs With lnCellXfs, ;
		          xl_cells.numdec  With lnNumDec In xl_cells
		      Else
		        Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted, numdec, validndx) ;
		          VALUES (tnWB, tnSheet, lnRow, lnCol, DATA_TYPE_NONE, lnCellXfs, False, lnNumDec, 0)
		      Endif
		    Endfor
		  Endfor
		  llReturn = True
		Else
		  llReturn = False
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE cellrefasciitoindex		&& Converts a 'AA444' cell reference to the row and column index values
		Lparameters tcCellRef
		Local lnCellCol, lnNdx, lnCellRow, loCellRef
		lnCellCol = This.ColumnAsciiToIndex(tcCellRef)
		lnCellRow = 0
		For lnNdx=1 To Len(tcCellRef)
		  If Isdigit(Substr(tcCellRef, lnNdx))
		    lnCellRow = Int(Val(Substr(tcCellRef, lnNdx)))
		    Exit
		  Endif
		Endfor
		loCellRef = Createobject("Empty")
		AddProperty(loCellRef, "Column", lnCellCol)
		AddProperty(loCellRef, "Row", lnCellRow)
		Return loCellRef
		
	ENDPROC

	PROCEDURE clearcellvalidation		&& Clears/deletes the named range from the workbook
		Lparameters tnWB, tcName
		If Pcount() < 2
		  Return False
		Endif
		If Vartype(tcName) != "C"
		  Return False
		Endif
		If Seek(BinToC(tnWB)+Padl(tcName, 254, " "), "xl_namerange", "wbrname")
		  Delete In xl_namerange
		  llReturn = True
		Else
		  llReturn = False
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE clearcellvalue		&& Clears the cell value
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local llReturn
		If This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		  Replace xl_cells.celldeleted With True In xl_cells
		  llReturn = True
		Else
		  llReturn = False
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE columnasciitoindex		&& Converts Excel Ascii column value to index value
		Lparameters tcColIndex
		Local lnIndex, lnNdx, lnChr
		lnIndex = 0
		For lnNdx=1 To Len(tcColIndex)
		  lnChr = Asc(Upper(Substr(tcColIndex, lnNdx, 1)))
		  If Between(lnChr, 65, 90)
		    lnIndex = (lnChr - 64) + (lnIndex * 26)
		  Else
		    Exit
		  Endif
		Endfor
		Return lnIndex
		
	ENDPROC

	PROCEDURE columnindextoascii		&& Gets the column ASCII code for the column index
		Lparameters tnCol
		Local lnRemCol, lcColumn, lnPartCol
		If Pcount() = 0 Or Vartype(tnCol) != "N"
		  Return ""
		Endif
		Try
		  lnRemCol = tnCol
		  lcColumn = ""
		  Do While lnRemCol > 0
		    lnPartCol = Mod(lnRemCol, 26)
		    If lnPartCol = 0
		      lnPartCol = 26
		    Endif
		    lnRemCol = (lnRemCol - lnPartCol) / 26
		    lcColumn = Chr(lnPartCol + 64)  + lcColumn
		  Enddo
		
		Catch To loException
		  Set Step On
		Endtry
		Return lcColumn
		
	ENDPROC

	PROTECTED PROCEDURE convertcolortohex		&& Converts a color value (integer) to Hex representation
		Lparameters tnColor
		Local lnRed, lnGreen, lnBlue, lcHexRed, lcHexGreen, lcHexBlue
		With This
		  lnRed   = .GetRGBValues(tnColor, 'R')
		  lnGreen = .GetRGBValues(tnColor, 'G')
		  lnBlue  = .GetRGBValues(tnColor, 'B')
		  lcHexRed   = Right(Transform(lnRed, '@0'), 2)
		  lcHexGreen = Right(Transform(lnGreen, '@0'), 2)
		  lcHexBlue  = Right(Transform(lnBlue, '@0'), 2)
		Endwith
		Return "FF" + Upper(lcHexRed + lcHexGreen + lcHexBlue)
		
	ENDPROC

	PROTECTED PROCEDURE converthexstringtonumeric		&& ConvertHexStringToNumeric
		Lparameters tcHexNum
		Local lcValue
		If Empty(tcHexNum)
		  Return 0
		Endif
		If Len(tcHexNum) > 6
		  tcHexNum = Substr(tcHexNum, 3)
		Endif
		tcHexNum = Upper(Alltrim(tcHexNum))
		tcHexNum = Right(tcHexNum, 2) + Substr(tcHexNum, 3, 2) + Left(tcHexNum, 2)
		lcValue  = "0x" + tcHexNum
		Return Eval(lcValue)
		
	ENDPROC

	PROCEDURE convertpixelstoexcelunits		&& Converts Pixel measurement to Excel measurement
		Lparameters tnPixels
		Return tnPixels * 0.152542
		
	ENDPROC

	PROTECTED PROCEDURE createexcelfile		&& Creates the Excel file from the components
		Lparameters tcTempPath, tcFilePath, tcWBName
		Local loShell, loFolder, lcZipFile, loException, loFile, lnCountBefore, lcFile, lcZipPath, lnCount, lhFile
		lcZipPath = Alltrim(tcFilePath)
		If Empty(lcZipPath)
		  lcZipPath = Sys(5) + Sys(2003)
		Endif
		lcZipFile = Addbs(lcZipPath) + Forceext(Alltrim(tcWBName), "zip")
		*-*	Delete any prior file with same Excel name
		If File(Forceext(lcZipFile, "xlsx"))
		  Try
		    Erase (Forceext(lcZipFile, "xlsx"))
		    llError = False
		
		  Catch To loException
		    This.ErrorLevelId = 10
		    Raiseevent(This, "OnShowErrorMessage", 10, "Error - unable to delete existing file" + CR + loException.Message)
		    llError = True
		  Endtry
		  If llError
		    Return False
		  Endif
		Endif
		*-*	Validate that the file name and path are valid
		Try
		  lhFile = Fcreate(lcZipFile, 0)
		  Fclose(lhFile)
		
		Catch To loException
		  This.ErrorLevelId = 11
		  Raiseevent(This, "OnShowErrorMessage", 11, "CreateExcelFile - Failed to create Zip file"+ CR + loException.Message)
		  Return False
		Endtry
		
		*-*	Create base zip file
		Strtofile(Chr(80)+Chr(75)+Chr(5)+Chr(6)+Replicate(Chr(0), 18), lcZipFile, 0)
		loShell  = Createobject("shell.application")
		loFolder = loShell.NameSpace(tcTempPath).Items
		
		*-*	Add the files to the zip
		If Os(3)<'6' Or Os(3)='6' And Os(4)<'1'
		  Try
		    For Each loFile In loFolder
		      loShell.NameSpace(lcZipFile).MoveHere(loFile, FOF_SILENT)
		      apiSleep(100)
		    Endfor
		
		  Catch To loException
		    Set Step On
		  Endtry
		
		  llErr = True
		  Do While llErr
		    Try
		      apiMoveFile(lcZipFile, Forceext(lcZipFile, "xlsx"))
		      llErr = False
		    Catch
		      apiSleep(100)
		    Endtry
		  Enddo
		Else
		  Try
		    For Each loFile In loFolder
		      lnCountBefore = loShell.NameSpace(tcTempPath).Items.Count
		      loShell.NameSpace(lcZipFile).MoveHere(loFile, FOF_SILENT)
		      Do While lnCountBefore = loShell.NameSpace(tcTempPath).Items.Count
		        apiSleep(50)
		      Enddo
		    Endfor
		
		  Catch To loException
		    This.ErrorLevelId = 12
		    Raiseevent(This, "OnShowErrorMessage", 12, "CreateExcelFile - Failed to add contents to Zip file"+ CR + loException.Message)
		    Set Step On
		    Erase (lcZipFile)
		    Do Case
		    Case loException.ErrorNo = 1943
		
		    Otherwise
		      Set Step On
		    Endcase
		  Endtry
		  Try
		    apiMoveFile(lcZipFile, Forceext(lcZipFile, "xlsx"))
		
		  Catch To loException
		    This.ErrorLevelId = 13
		    Raiseevent(This, "OnShowErrorMessage", 13, "CreateExcelFile - Rename failed"+ CR + loException.Message)
		    Set Step On
		  Endtry
		Endif
		Return True
		
	ENDPROC

	PROCEDURE createformatstyle		&& Creates a new format style definition
		Lparameters tnWB
		If Pcount() > 0 And Seek(BinToC(tnWB), "xl_workbooks", "workbook")
		  lnId = This.GetNextId(tnWB, "xl_cellxfs")
		  Insert Into xl_cellxfs (workbook, Id, numFmtId, fontId, fillId, borderId, halign, valign, indent, wraptext, Rotation) ;
		    VALUES (tnWB, lnId, 0, 0, 0, 0, "", "", 0, 0, 0)
		  Return lnId
		Else
		  Return -1
		Endif
		
	ENDPROC

	PROCEDURE createinlineformattext		&& Creates an in-line text formatted definition
		Lparameters tnWB, tcCellText
		Local loInline
		loInline = Createobject("Empty")
		AddProperty(loInline, "Workbook", tnWB)
		AddProperty(loInline, "StringId", Null)
		AddProperty(loInline, "StringValue", tcCellText)
		AddProperty(loInline, "Count", 0)
		AddProperty(loInline, "Characters[1]")
		loInline.Characters[1] = Null
		Return loInline
		
	ENDPROC

	PROCEDURE createworkbook		&& Creates a new workbook object
		Lparameters tcName
		Local lcWBName, lcPath, lnWB
		If Pcount() = 1
		  tlLoadDefaults = True
		Endif
		lcWBName = Juststem(tcName)
		lcPath   = Justpath(tcName)
		If Empty(lcPath)
		  lcPath = Sys(5) + Sys(2003)
		  tcName = Addbs(lcPath) + lcWBName + "." + Justext(tcName)
		Endif
		With This
		  If Seek(Padr(Upper(tcName), 240, "_"), "xl_workbooks", "fullname")
		    lnWB = 0
		  Else
		    Insert Into xl_workbooks (wbname, filepath, FullName) Values (lcWBName, lcPath, Padr(Upper(tcName), 240, "_"))
		
		    lnWB = xl_workbooks.workbook
		    .SetDefaultFont(lnWB, This.DefaultFont, This.DefaultFontSize)        && Change recommended by Doug Hennig; 2017-06-12
		    .SetDefaultBorder(lnWB, BORDER_STYLE_NONE)
		
		    Insert Into xl_relationships (workbook, relid, reltype, Target) Values (lnWB, 1, "styles", "styles.xml")
		    Insert Into xl_relationships (workbook, relid, reltype, Target) Values (lnWB, 2, "sharedStrings", "sharedStrings.xml")
		    .SetLastId(lnWB, 2, "xl_relationships")
		
		    Insert Into xl_cellxfs (workbook, Id, numFmtId, fontId, fillId, borderId, halign, valign, indent, wraptext) ;
		      VALUES (lnWB, 0, 0, 0, 0, 0, "", "", 0, 0)
		
		    Insert Into xl_fills (workbook, Id, fgcolor, bgcolor, patttype, Theme, tint, fgindexed, bgindexed) ;
		      VALUES (lnWB, 0, 0, 0, FILL_STYLE_NONE, 0, 0, 0, 0)
		
		    Insert Into xl_fills (workbook, Id, fgcolor, bgcolor, patttype, Theme, tint, fgindexed, bgindexed) ;
		      VALUES (lnWB, 1, 0, 0, FILL_STYLE_GRAY125, 0, 0, 0, 0)
		  Endif
		Endwith
		Return lnWB
		
	ENDPROC

	PROTECTED PROCEDURE createworkbookex		&& Internal method for creating a workbook
		Lparameters tcName
		Local lcWBName, lcPath, lnWB
		lcWBName = Juststem(tcName)
		lcPath   = Justpath(tcName)
		If Empty(lcPath)
		  lcPath = Sys(5) + Sys(2003)
		  tcName = Addbs(lcPath) + lcWBName + "." + Justext(tcName)
		Endif
		If Seek(Padr(Upper(tcName), 240, "_"), "xl_workbooks", "fullname")
		  lnWB = 0
		Else
		  Insert Into xl_workbooks (wbname, filepath, FullName) Values (lcWBName, lcPath, Padr(Upper(tcName), 240, "_"))
		  lnWB = xl_workbooks.workbook
		Endif
		Return lnWB
		
	ENDPROC

	PROTECTED PROCEDURE createworkingcursors		&& Creates the working cursors for worksheet definitions
		If Used('xl_strings')
		  Return
		Endif
		
		Create Cursor xl_strings Codepage = (This.Codepage) (Id I, workbook I, checksum C(230), stringxml M, stringval M, presvspace L, Formatted L)
		
		Index On BinToC(workbook)+BinToC(Id) Tag Id For !Deleted()
		Index On BinToC(workbook)+Padl(Id, 10, '0') Tag sortorder For !Deleted()
		Index On BinToC(workbook)+checksum Tag stringndx
		Index On workbook Tag workbook
		
		Create Cursor xl_strformat (workbook I, Id I, Index I, stringxml M, stringval M, fbold L, fitalic L, fcolor I, fname C(100), Fsize N(5,1), uline C(16), strkthr L, ;
		  fvpos C(11), Theme I, tint F(20,15), indexed I, presvspace L)
		Index On BinToC(workbook)+BinToC(Id)+Padl(Index, 10, '0') Tag sortorder For !Deleted()
		Index On BinToC(workbook)+BinToC(Id)+BinToC(Index) Tag Id For !Deleted()
		
		Create Cursor xl_workbooks (workbook I Autoinc Nextvalue 1, wbname C(200), filepath C(200), FullName C(240))
		Index On BinToC(workbook) Tag workbook
		Index On Upper(FullName) Tag FullName
		Index On Padr(Upper(Alltrim(wbname)), 200, "_") Tag wbname
		
		Create Cursor xl_sheets (workbook I, Sheet I, shname C(30), state I, mleft N(6,3), mright N(6,3), mtop N(6,3), mbot N(6,3), mheader N(6,3), ;
		  mfooter N(6,3), shdeleted L, xsplit I, ysplit I, prnorient I, Papersize I, Paperwidth I, paperheight I, ;
		  paperdimen C(2), Scale I, fittowidth I, fittoheight I, tabcolorndx I, tabcolorrgb C(8))
		Index On Sheet Tag Sheet
		Index On workbook Tag workbook
		Index On BinToC(workbook)+Upper(Alltrim(shname)) Tag shname
		Index On BinToC(workbook)+BinToC(Sheet) Tag sheetndx For !Deleted()
		
		Create Cursor xl_cells (workbook I, Sheet I, cellrow I, cellcol I, cellvalue C(25), DataType C(1), cellformula M, stringid I, cellxfs I, numdec I, celldeleted L, validndx I)
		Index On Sheet Tag Sheet
		Index On cellrow Tag cellrow
		Index On cellcol Tag cellcol
		Index On workbook Tag workbook
		Index On BinToC(workbook)+BinToC(Sheet)+BinToC(cellrow)+BinToC(cellcol) Tag reverse Descending
		Index On BinToC(workbook)+BinToC(Sheet)+BinToC(cellrow)+BinToC(cellcol) Tag cellindex Candidate
		
		Create Cursor xl_cellxfs (workbook I, Id I, numFmtId I, fontId I, fillId I, borderId I, halign C(8), valign C(8), indent I, wraptext I, Rotation I)
		Index On BinToC(workbook)+BinToC(Id) Tag Id For !Deleted()
		Index On BinToC(workbook)+Padl(Id, 10, '0') Tag sortorder For !Deleted()
		Index On BinToC(workbook)+BinToC(numFmtId)+BinToC(fontId)+BinToC(fillId)+BinToC(borderId)+BinToC(indent)+BinToC(wraptext)+BinToC(Rotation)+Alltrim(halign)+Alltrim(valign) Tag cellxfs For !Deleted()
		Index On BinToC(workbook)+BinToC(fontId)+BinToC(fillId)+BinToC(borderId)+BinToC(indent)+BinToC(wraptext)+BinToC(Rotation)+Alltrim(halign)+Alltrim(valign) Tag cellformat For !Deleted()
		
		Create Cursor xl_fonts (workbook I, Id I, fname C(100), Fsize N(5,1), fbold L, fitalic L, fcolor I, uline C(16), strkthr L, ;
		  fvpos C(11), Theme I, tint F(20,15), indexed I)
		Index On BinToC(workbook)+fname + Str(Fsize, 5, 1) + Transform(fbold) + Transform(fitalic) + Padl(fcolor, 15) + uline + Transform(strkthr) + fvpos Tag cellformat
		Index On BinToC(workbook)+Padl(Id, 10, '0') Tag sortorder For !Deleted()
		Index On BinToC(workbook)+BinToC(Id) Tag Id For !Deleted()
		
		Create Cursor xl_fills (workbook I, Id I, fgcolor I, bgcolor I, patttype C(25), Theme I, tint F(20,15), fgindexed I, bgindexed I)
		Index On BinToC(workbook)+BinToC(fgcolor)+BinToC(bgcolor)+patttype Tag FillColor
		Index On BinToC(workbook)+Padl(Id, 10, '0') Tag sortorder For !Deleted()
		Index On BinToC(workbook)+BinToC(Id) Tag Id For !Deleted()
		
		Create Cursor xl_borders (workbook I, Id I, lstyle C(20), lcolor I, ltheme I, ltint I, lindexed I, rstyle C(20), rcolor I, rtheme I, rtint I, rindexed I, ;
		  tstyle C(20), tcolor I, ttheme I, ttint I, tindexed I, bstyle C(20), bcolor I, btheme I, btint I, bindexed I, ;
		  dstyle C(20), dcolor I, dtheme I, dtint I, dindexed I, diagdn I, diagup I, Theme I, tint F(20,15))
		Index On BinToC(workbook) + Alltrim(lstyle) + BinToC(lcolor) + Alltrim(rstyle) + BinToC(rcolor) + Alltrim(tstyle) + BinToC(tcolor) + Alltrim(bstyle) + BinToC(bcolor) + ;
		  ALLTRIM(dstyle) + BinToC(dcolor) + BinToC(diagdn) + BinToC(diagup) Tag cellborder
		Index On BinToC(workbook)+Padl(Id, 10, '0') Tag sortorder For !Deleted()
		Index On BinToC(workbook)+BinToC(Id) Tag Id For !Deleted()
		
		Create Cursor xl_mergecells (workbook I, Sheet I, begrow I, begcol I, endrow I, endcol I)
		Index On workbook Tag workbook
		Index On Sheet Tag Sheet
		Index On begrow Tag begrow
		Index On begcol Tag begcol
		Index On endrow Tag endrow
		Index On endcol Tag endcol
		Index On BinToC(workbook)+BinToC(Sheet)+BinToC(begrow)+BinToC(begcol) Tag mergecell For !Deleted()
		
		Create Cursor xl_colwidths (workbook I, Sheet I, Column I, Width N(16,9), bestfit L)
		Index On Sheet Tag Sheet
		Index On Column Tag Column
		Index On workbook Tag workbook
		Index On BinToC(workbook)+BinToC(Sheet)+BinToC(Column) Tag shcolumn For !Deleted()
		
		Create Cursor xl_hdrfooterdefn (workbook I, Sheet I, alignmargin L, difffirstpg L, diffoddeven L, scalewdoc L)
		Index On workbook Tag workbook
		Index On Sheet Tag Sheet
		Index On BinToC(workbook)+BinToC(Sheet) Tag wbsheet For !Deleted()
		
		Create Cursor xl_hdrfootertext (workbook I, Sheet I, Page I, section I, Text C(200), FontName C(50), FontSize I, fontstyle I, fontcolor I)
		Index On workbook Tag workbook
		Index On Sheet Tag Sheet
		Index On BinToC(workbook)+BinToC(Sheet)+BinToC(Page)+BinToC(section) Tag hdrfootr For !Deleted()
		
		Create Cursor xl_rowheights (workbook I, Sheet I, Row I, Height N(14,7))
		Index On workbook Tag workbook
		Index On Sheet Tag Sheet
		Index On Row Tag Row
		Index On BinToC(workbook)+BinToC(Sheet)+BinToC(Row) Tag shrow For !Deleted()
		
		Create Cursor xl_validation (workbook I, Sheet I, validndx I Autoinc Nextvalue 1, vtype I, vstyle I, voperator I, errmsg C(100), errtitle C(100), ;
		  allowblank L, showinpmsg L, showerrmsg L, vprompt C(100), formula L, formula1 C(254), formula2 C(254))
		Index On BinToC(validndx) Tag validndx For !Deleted()
		Index On BinToC(workbook)+BinToC(Sheet) Tag wbshindex For !Deleted()
		Index On BinToC(workbook)+BinToC(Sheet)+BinToC(validndx) Tag validindex For !Deleted()
		Index On Left(formula1, 240) Tag formula1 For !Deleted()
		Index On Left(formula2, 240) Tag formula2 For !Deleted()
		
		Create Cursor xl_namerange (workbook I, rname C(50), scope I, Comment C(254), Sheet I, begrow I, begcol I, endrow I, endcol I)
		Index On BinToC(workbook)+rname Tag wbrname For !Deleted()
		
		Create Cursor xl_numfmts (workbook I, Id I, tempid I, formatxml M, formatcode M, applydec L)
		Index On BinToC(workbook)+Padl(Id, 10, '0') Tag sortorder For !Deleted()
		Index On BinToC(workbook)+BinToC(Id) Tag Id For !Deleted()
		
		Create Cursor xl_rows (workbook I, Sheet I, Row I, maxcol I)
		Index On BinToC(workbook)+BinToC(Sheet)+BinToC(Row) Tag Id For !Deleted()
		
		Create Cursor xl_ndxcolors (workbook I, indexid I, rgbcolor C(8))
		Index On BinToC(workbook)+rgbcolor Tag rgbcolor For !Deleted()
		Index On BinToC(workbook)+BinToC(indexid) Tag indexid For !Deleted()
		
		Create Cursor xl_mrucolors (workbook I, indexid I, rgbcolor C(8))
		Index On BinToC(workbook)+rgbcolor Tag rgbcolor For !Deleted()
		Index On BinToC(workbook)+BinToC(indexid) Tag indexid For !Deleted()
		
		Create Cursor xl_relationships (workbook I, Sheet I, relid I, reltype C(20), Target C(240))
		Index On BinToC(workbook)+BinToC(relid) Tag relid For !Deleted()
		Index On BinToC(workbook)+BinToC(Sheet) Tag Sheet For !Deleted()
		Index On BinToC(workbook)+reltype Tag reltype For !Deleted()
		
		Create Cursor xl_extsheets (workbook I, extid I, relid I, sheetname C(30))
		Index On BinToC(workbook)+BinToC(extid) Tag extid For !Deleted()
		Index On BinToC(workbook)+BinToC(extid)+BinToC(relid) Tag relid For !Deleted()
		
		Create Cursor xl_extcells (workbook I, extid I, cellrow I, cellcol I, cellvalue M)
		Index On BinToC(workbook)+BinToC(extid) Tag extid For !Deleted()
		*INDEX ON BINTOC(workbook)+BINTOC(extid)+BINTOC(relid) TAG relid FOR !DELETED()
		
	ENDPROC

	PROTECTED PROCEDURE createworkingdirectories		&& Creates the working directories for the XML files
		Local lcDir, loException
		lcDir = Addbs(Sys(2023)) + Sys(2015)
		Try
		  Mkdir (lcDir)
		  Mkdir (lcDir + "\_rels")
		  Mkdir (lcDir + "\docProps")
		  Mkdir (lcDir + "\xl")
		  Mkdir (lcDir + "\xl\_rels")
		  Mkdir (lcDir + "\xl\worksheets")
		
		Catch To loException
		  lcDir = Null
		Endtry
		Return Addbs(lcDir)
		
	ENDPROC

	PROCEDURE debugcursorstofile		&& Debugging use for saving the internal cursors to a text file
		Lparameters tcStemName
		Local lnNumFlds, lcField, lcLineText, lnFld, lcFileName
		Local Array laFields[1, 18]
		Select xl_workbooks
		Set Order To Tag workbook
		lnNumFlds = Afields(laFields, "xl_workbooks")
		lcFileText = "Cursor: xl_workbooks" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_workbooks.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_workbooks.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		Select xl_sheets
		Set Order To Tag sheetndx
		lcFileName = tcStemName + " " + Alias() + ".txt"
		List To File (lcFileName) Noconsole
		lnNumFlds = Afields(laFields, "xl_sheets")
		lcFileText = lcFileText + "Cursor: xl_sheets" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_sheets.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_sheets.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		Select xl_cells
		Set Order To Tag cellindex
		lcFileName = tcStemName + " " + Alias() + ".txt"
		List To File (lcFileName) Noconsole
		lnNumFlds = Afields(laFields, "xl_cells")
		lcFileText = lcFileText + "Cursor: xl_cells" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_cells.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_cells.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		Select xl_strings
		Set Order To Tag stringid
		lcFileName = tcStemName + " " + Alias() + ".txt"
		List To File (lcFileName) Noconsole
		lnNumFlds = Afields(laFields, "xl_strings")
		lcFileText = lcFileText + "Cursor: xl_strings" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_strings.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_strings.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		Select xl_mergecells
		Set Order To Tag mergecell
		lcFileName = tcStemName + " " + Alias() + ".txt"
		List To File (lcFileName) Noconsole
		lnNumFlds = Afields(laFields, "xl_mergecells")
		lcFileText = lcFileText + "Cursor: xl_mergecells" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_mergecells.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_mergecells.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		Select xl_colwidths
		Set Order To Tag shcolumn
		lcFileName = tcStemName + " " + Alias() + ".txt"
		List To File (lcFileName) Noconsole
		lnNumFlds = Afields(laFields, "xl_colwidths")
		lcFileText = lcFileText + "Cursor: xl_colwidths" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_colwidths.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_colwidths.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		Select xl_fonts
		Set Order To Tag Id
		lcFileName = tcStemName + " " + Alias() + ".txt"
		List To File (lcFileName) Noconsole
		lnNumFlds = Afields(laFields, "xl_fonts")
		lcFileText = lcFileText + "Cursor: xl_fonts" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_fonts.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_fonts.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		Select xl_fills
		Set Order To Tag Id
		lcFileName = tcStemName + " " + Alias() + ".txt"
		List To File (lcFileName) Noconsole
		lnNumFlds = Afields(laFields, "xl_fills")
		lcFileText = lcFileText + "Cursor: xl_fills" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_fills.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_fills.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		Select xl_numfmts
		Set Order To Tag Id
		lcFileName = tcStemName + " " + Alias() + ".txt"
		List To File (lcFileName) Noconsole
		lnNumFlds = Afields(laFields, "xl_numfmts")
		lcFileText = lcFileText + "Cursor: xl_numfmts" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_numfmts.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_numfmts.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		Select xl_borders
		Set Order To Tag Id
		lcFileName = tcStemName + " " + Alias() + ".txt"
		List To File (lcFileName) Noconsole
		lnNumFlds = Afields(laFields, "xl_borders")
		lcFileText = lcFileText + "Cursor: xl_borders" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_borders.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_borders.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		Select xl_rowheights
		Set Order To Tag shrow
		lcFileName = tcStemName + " " + Alias() + ".txt"
		List To File (lcFileName) Noconsole
		lnNumFlds = Afields(laFields, "xl_rowheights")
		lcFileText = lcFileText + "Cursor: xl_rowheights" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_rowheights.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_rowheights.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		Select xl_hdrfooterdefn
		Set Order To Tag wbsheet
		lcFileName = tcStemName + " " + Alias() + ".txt"
		List To File (lcFileName) Noconsole
		lnNumFlds = Afields(laFields, "xl_hdrfooterdefn")
		lcFileText = lcFileText + "Cursor: xl_hdrfooterdefn" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_hdrfooterdefn.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_hdrfooterdefn.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		Select xl_hdrfootertext
		Set Order To Tag hdrfootr
		lcFileName = tcStemName + " " + Alias() + ".txt"
		List To File (lcFileName) Noconsole
		lnNumFlds = Afields(laFields, "xl_hdrfootertext")
		lcFileText = lcFileText + "Cursor: xl_hdrfootertext" + CRLF
		Scan
		  lcField = Lower(laFields[1, 1])
		  lcLineText = lcField + ": " + Transform(xl_hdrfootertext.&lcField)
		  For lnFld=2 To lnNumFlds
		    lcField = Lower(laFields[lnFld, 1])
		    lcLineText = lcLineText + ";  " + lcField + ": " + Transform(xl_hdrfootertext.&lcField)
		  Endfor
		  lcFileText = lcFileText + lcLineText + CRLF
		Endscan
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		Set Order To
		
		lcFileName = tcStemName + " Cursors.txt"
		Strtofile(lcFileText, lcFileName)
		
	ENDPROC

	PROCEDURE debugoutput		&& Limited functions for debugging
		Local lnWb, lnSh
		With This
		  lnWb = .CreateWorkbook("ExcelDebug.xlsx")
		
		  lnSh = .AddSheet(lnWb, "Debug Output")
		
		  .SetCellValue(lnWb, lnSh, 1, 1, "Test string 1")
		  .SetCellValue(lnWb, lnSh, 2, 1, "Test string 2")
		  .SetCellValue(lnWb, lnSh, 3, 1, "Test string 3")
		  .SetCellValue(lnWb, lnSh, 4, 1, "Test string 4")
		  .SetCellValue(lnWb, lnSh, 5, 1, "Test string 5")
		
		  .SetCellValue(lnWb, lnSh, 8, 1, "This is a long Test string for word-wrapping to occur This is a long Test string for word-wrapping to occur")
		  .SetCellWordWrap(lnWb, lnSh, 8, 1, True)
		  .SetRowHeight(lnWb, lnSh, 8, 75)
		  .SetColumnWidth(lnWb, lnSh, 1, 25)
		
		  .SetCellValue(lnWb, lnSh, 10, 1, Date(2015, 5, 6))
		  .SetCellValue(lnWb, lnSh, 11, 1, Datetime(2015, 5, 6, 6, 30, 30))
		
		  .SetCellFont(lnWb, lnSh, 1, 1, "Arial",                14,   True,         , Rgb(0,0,255))
		  .SetCellFont(lnWb, lnSh, 2, 1, "Times New Roman",        ,       ,         , Rgb(0,0,255))
		  .SetCellFont(lnWb, lnSh, 3, 1, "Consolas"       ,      14,   True)
		  .SetCellFont(lnWb, lnSh, 4, 1, "Arial",                24,   True,     True, Rgb(0,0,255))
		  .SetCellFont(lnWb, lnSh, 5, 1, "Cooper Black"   ,      12,       ,         ,             )
		
		  .SetCellBorder(lnWb, lnSh, 2, 1, BORDER_TOP+BORDER_BOTTOM, BORDER_STYLE_THICK,  Rgb(100,150,200))
		  .SetCellBorder(lnWb, lnSh, 5, 1, BORDER_LEFT+BORDER_RIGHT, BORDER_STYLE_DOUBLE, Rgb(255,0,0))
		
		  .SetCellFill(lnWb, lnSh, 1, 1, Rgb(255,204,153))
		  .SetCellFill(lnWb, lnSh, 3, 1, Rgb(204,255,255))
		
		  .SaveWorkbook(lnWb)
		Endwith
		
	ENDPROC

	PROCEDURE debug_assign
		Lparameters tlDebug
		If tlDebug
		  Set Debugout To "VFPXWorkbookXLSXDebug.txt"
		Endif
		This.Debug = tlDebug
		
	ENDPROC

	PROTECTED PROCEDURE declaredll		&& Declares the required support Win32 API
		Declare Sleep In kernel32 As apiSleep Integer tnTime
		Declare Integer DeleteFile In kernel32 As apiDeleteFile String lpFileName
		Declare Integer RemoveDirectory In kernel32 As apiRemoveDirectory String lpPathName
		Declare Long MoveFile In Win32API As apiMoveFile String SourceFileName, String DestFileName
		Declare Integer ShellExecute In Shell32 As apiShellExecute Long nhWnd, String lpAction, String lpFile, String lpParams, String lpDirectory, Integer nShowCmd
		
	ENDPROC

	PROCEDURE deleteallworkbooks		&& Deletes all workbooks
		Local loException
		Try
		  With This
		    .DestroyWorkingCursors()
		    .CreateWorkingCursors()
		    .InitalizeIdValues()
		  Endw
		
		Catch To loException
		  Set Step On
		Endtry
		
	ENDPROC

	PROCEDURE deletesheet		&& Deletes the sheet from the Workbook
		Lparameters tnWB, txSheet
		Local lnSheet, lxReturn
		lxReturn = False
		Do Case
		Case Vartype(txSheet) = "C"
		  If Seek(BinToC(tnWB)+Upper(txSheet), "xl_sheets", "shname") And Seek(BinToC(tnWB)+BinToC(xl_sheets.Sheet), "xl_relationships", "sheet")
		    lnSheet = xl_sheets.Sheet
		    Replace xl_sheets.shdeleted With True In xl_sheets
		    Delete In xl_sheets
		    Delete In xl_relationships
		    lxReturn = True
		  Endif
		
		Case Vartype(txSheet) = "N"
		  If Seek(BinToC(tnWB)+BinToC(txSheet), "xl_sheets", "sheetndx") And Seek(BinToC(tnWB)+BinToC(xl_sheets.Sheet), "xl_relationships", "sheet")
		    lnSheet = txSheet
		    Replace xl_sheets.shdeleted With True In xl_sheets
		    Delete In xl_sheets
		    Delete In xl_relationships
		    lxReturn = True
		  Endif
		Endcase
		If lxReturn
		  Replace xl_cells.celldeleted With True For workbook = tnWB And Sheet = lnSheet In xl_cells
		  Delete For workbook = tnWB And Sheet = lnSheet In xl_cells
		Endif
		Return lxReturn
		
	ENDPROC

	PROCEDURE deleteworkbook		&& Deletes the selected workbook
		Lparameters tnWB
		Local llSuccess, lnNdx
		Try
		  Replace xl_sheets.shdeleted  With True For workbook = tnWB In xl_sheets
		  Replace xl_cells.celldeleted With True For workbook = tnWB In xl_cells
		  Delete For workbook = tnWB In xl_workbooks
		  Delete For workbook = tnWB In xl_sheets
		  Delete For workbook = tnWB In xl_cells
		  Delete For workbook = tnWB In xl_strformat
		  Delete For workbook = tnWB In xl_strings
		  Delete For workbook = tnWB In xl_cellxfs
		  Delete For workbook = tnWB In xl_fonts
		  Delete For workbook = tnWB In xl_fills
		  Delete For workbook = tnWB In xl_borders
		  Delete For workbook = tnWB In xl_mergecells
		  Delete For workbook = tnWB In xl_colwidths
		  Delete For workbook = tnWB In xl_hdrfooterdefn
		  Delete For workbook = tnWB In xl_hdrfootertext
		  Delete For workbook = tnWB In xl_rowheights
		  Delete For workbook = tnWB In xl_validation
		  Delete For workbook = tnWB In xl_namerange
		  Delete For workbook = tnWB In xl_numfmts
		  Delete For workbook = tnWB In xl_rows
		  Delete For workbook = tnWB In xl_ndxcolors
		  Delete For workbook = tnWB In xl_mrucolors
		  Delete For workbook = tnWB In xl_relationships
		  Delete For workbook = tnWB In xl_extsheets
		  Delete For workbook = tnWB In xl_extcells
		
		  With This
		    lnNdx = Ascan(.LastBorderId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      Adel(.LastBorderId, lnNdx)
		      lnNdx = Alen(.LastBorderId, 1) - 1
		      If lnNdx > 0
		        Dimension .LastBorderId[lnNdx, 2]
		      Else
		        .LastBorderId[1, 1] = 0                                          && Workbook Id
		        .LastBorderId[1, 2] = 0                                          && Last Border Id
		      Endif
		    Endif
		
		    lnNdx = Ascan(.LastCellXfsId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      Adel(.LastCellXfsId, lnNdx)
		      lnNdx = Alen(.LastCellXfsId, 1) - 1
		      If lnNdx > 0
		        Dimension .LastCellXfsId[lnNdx, 2]
		      Else
		        .LastCellXfsId[1, 1] = 0                                         && Workbook Id
		        .LastCellXfsId[1, 2] = 0                                         && Last CellXfs Id
		      Endif
		    Endif
		
		    lnNdx = Ascan(.LastFillId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      Adel(.LastFillId, lnNdx)
		      lnNdx = Alen(.LastFillId, 1) - 1
		      If lnNdx > 0
		        Dimension .LastFillId[lnNdx, 2]
		      Else
		        .LastFillId[1, 1] = 0                                            && Workbook Id
		        .LastFillId[1, 2] = 0                                            && Last Fill Id
		      Endif
		    Endif
		
		    lnNdx = Ascan(.LastFontId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      Adel(.LastFontId, lnNdx)
		      lnNdx = Alen(.LastFontId, 1) - 1
		      If lnNdx > 0
		        Dimension .LastFontId[lnNdx, 2]
		      Else
		        .LastFontId[1, 1] = 0                                            && Workbook Id
		        .LastFontId[1, 2] = 0                                            && Last Font Id
		      Endif
		    Endif
		
		    lnNdx = Ascan(.LastIndexColorId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      Adel(.LastIndexColorId, lnNdx)
		      lnNdx = Alen(.LastIndexColorId, 1) - 1
		      If lnNdx > 0
		        Dimension .LastIndexColorId[lnNdx, 2]
		      Else
		        .LastIndexColorId[1, 1] = 0                                      && Workbook Id
		        .LastIndexColorId[1, 2] = 0                                      && Last IndexColor Id
		      Endif
		    Endif
		
		    lnNdx = Ascan(.LastMruColorId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      Adel(.LastMruColorId, lnNdx)
		      lnNdx = Alen(.LastMruColorId, 1) - 1
		      If lnNdx > 0
		        Dimension .LastMruColorId[lnNdx, 2]
		      Else
		        .LastMruColorId[1, 1] = 0                                        && Workbook Id
		        .LastMruColorId[1, 2] = 0                                        && Last mruColor Id
		      Endif
		    Endif
		
		    lnNdx = Ascan(.LastNumFmtId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      Adel(.LastNumFmtId, lnNdx)
		      lnNdx = Alen(.LastNumFmtId, 1) - 1
		      If lnNdx > 0
		        Dimension Ths.LastNumFmtId[lnNdx, 2]
		      Else
		        .LastNumFmtId[1, 1] = 0                                          && Workbook Id
		        .LastNumFmtId[1, 2] = 0                                          && Last NumFmt Id
		      Endif
		    Endif
		
		    lnNdx = Ascan(.LastRelationId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      Adel(.LastRelationId, lnNdx)
		      lnNdx = Alen(.LastRelationId, 1) - 1
		      If lnNdx > 0
		        Dimension .LastRelationId[lnNdx, 2]
		      Else
		        .LastRelationId[1, 1] = 0                                        && Workbook Id
		        .LastRelationId[1, 2] = 0                                        && Last Relationship Id
		      Endif
		    Endif
		
		    lnNdx = Ascan(.LastSheetId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      Adel(.LastSheetId, lnNdx)
		      lnNdx = Alen(.LastSheetId, 1) - 1
		      If lnNdx > 0
		        Dimension .LastSheetId[lnNdx, 2]
		      Else
		        .LastSheetId[1, 1] = 0                                           && Workbook Id
		        .LastSheetId[1, 2] = 0                                           && Last Sheet Id
		      Endif
		    Endif
		
		    lnNdx = Ascan(.LastStringId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      Adel(.LastStringId, lnNdx)
		      lnNdx = Alen(.LastStringId, 1) - 1
		      If lnNdx > 0
		        Dimension .LastStringId[lnNdx, 2]
		      Else
		        .LastStringId[1, 1] = 0                                          && Workbook Id
		        .LastStringId[1, 2] = 0                                          && Last String Id
		      Endif
		    Endif
		    llSuccess = True
		  Endwith
		
		Catch To loException
		  Set Step On
		  llSuccess = False
		Endtry
		Return llSuccess
		
	ENDPROC

	PROCEDURE demo		&& Demo for the features of this class
		Local lnWb, lnSh1, lnRow, lnCol, lnSh2, lnSh3, lnSh4, lnCnt, lnFormat, llBoolean, lcNamedRange
		Local lnSh6, lnSh5, loInline, lnStyle1, lnStyle2, lnBorders, lcString
		lnWb = This.CreateWorkbook("ExcelTest.xlsx")
		If lnWb = 0
		  Return False
		Endif
		
		With This
		  lnSh1 = .AddSheet(lnWb, "Test Sheet 1")
		  If lnSh1 = 0
		    Return False
		  Endif
		  .FreezePanes(lnWb, lnSh1, 1, 2)
		
		  llBoolean = True
		  For lnRow=1 To 10
		    For lnCol=1 To 9
		      .SetCellValue(lnWb, lnSh1, lnRow, lnCol, Sys(2015))
		    Endfor
		    llBoolean = !llBoolean
		    .SetCellValue(lnWb, lnSh1, lnRow, 10, llBoolean)
		  Endfor
		  .SetRowHeight(lnWb, lnSh1, 6, 25)
		
		*-*	Example of cell styles
		  lnStyle1  = .CreateFormatStyle(lnWb)   && Create the base style definition
		  lnBorders = BORDER_LEFT + BORDER_RIGHT + BORDER_TOP + BORDER_BOTTOM
		  .AddStyleBorders(lnWb, lnStyle1, lnBorders, BORDER_STYLE_THIN, Rgb(16,100,200))
		  .AddStyleFont(lnWb, lnStyle1, "Times New Roman", 14, False, False, Rgb(0,0,255))
		  .SetCellStyleRange(lnWb, lnSh1, 2, 1, 2, 9, lnStyle1)
		
		  lnStyle2  = .CreateFormatStyle(lnWb)   && Create the base style definition
		  lnBorders = BORDER_BOTTOM
		  .AddStyleBorders(lnWb, lnStyle2, lnBorders, BORDER_STYLE_THICK, Rgb(16,100,200))
		  .AddStyleFont(lnWb, lnStyle2, "Arial", 16, True, False)
		  .SetCellStyleRange(lnWb, lnSh1, 4, 1, 4, 9, lnStyle2)
		
		*-*	* Indentation examples  [OLD WAY - DEPRICATED METHODS]
		*-*	this.SetCellIndent(lnWb, lnSh1, 2, 6, 3)
		*-*	this.SetCellIndent(lnWb, lnSh1, 4, 6, 3)
		*-*	this.SetCellIndent(lnWb, lnSh1, 6, 6, 3)
		*-*	this.SetCellIndent(lnWb, lnSh1, 8, 6, 3)
		*-*	this.SetCellIndent(lnWb, lnSh1, 10, 6, 3)
		*-*
		*-*	*                tnWB, tnSheet, tnCellRow, tnCellCol,           tcFName, tnFSize, tlBold, tlItalic,     tnFColor,  tcULine, tlStrikThr, tcVPos
		*-*	this.SetCellFont(lnWb, lnSh1,           1,         1, "Arial",                14,   True,     True, RGB(0,0,255))
		*-*	this.SetCellFont(lnWb, lnSh1,           2,         1, "Times New Roman",        ,       ,         , RGB(0,0,255))
		*-*	this.SetCellFont(lnWb, lnSh1,           3,         1,                  ,      14,   True)
		*-*	this.SetCellFont(lnWb, lnSh1,           4,         1, "Arial",                14,   True,     True, RGB(0,0,255))
		*-*	this.SetCellFont(lnWb, lnSh1,           6,         1,                  ,        ,       ,         ,             , 'single')
		*-*	this.SetCellFont(lnWb, lnSh1,           7,         1,                  ,        ,       ,         ,             , 'double')
		*-*	this.SetCellFont(lnWb, lnSh1,           8,         1,                  ,        ,       ,         ,             ,         , True)
		*-*	this.SetCellFont(lnWb, lnSh1,           9,         1,                  ,        ,       ,         ,             ,         ,            , "superscript")
		*-*
		*-*	* New procedure each line is drawed with the same style and color
		*-*	this.SetCellBorder(lnWb, lnSh1, 3, 4, 63, BORDER_STYLE_THIN,   RGB(16,100,200))
		*-*	this.SetCellBorder(lnWb, lnSh1, 3, 6, 31, BORDER_STYLE_THICK,  RGB(100,150,200))
		*-*	this.SetCellBorder(lnWb, lnSh1, 3, 8, 47, BORDER_STYLE_DOUBLE, RGB(200,150,100))
		*-*	this.SetCellBorder(lnWb, lnSh1, 3, 4,  8, BORDER_STYLE_THIN,   RGB(16,100,200))
		*-*
		*-*	this.SetCellWordWrapRange(lnWb, lnSh1, 1, 1, 10, 9, True)
		*-*
		*-*	* Old procedure - each line can have a different style or color
		*-*	this.SetCellBorderEx(lnWb, lnSh1, 5, 2, 'thin',,'thin',,'thick',,'thick')
		*-*	this.SetCellBorderEx(lnWb, lnSh1, 9, 2, ,,,,'double',255,'thick',RGB(255,0,255))
		
		* Example of setting inline text formatting
		  loInline = .CreateInLineFormatText(lnWb, "This is an in-line formatted text string")
		  loInline = .AddInLineFontObject(loInline, 1, 4, "Arial Black", 16)
		  loInline = .AddInLineFontObject(loInline, 5, 15, "Times New Roman", 14, Rgb(255,0,0), .T.)
		  loInline = .AddInLineFontObject(loInline, 20, 21, "Arial", 12)
		  .SetCellInLineFormatText(lnWb, lnSh1, 16, 1, loInline)
		
		* Rotated text
		  .SetCellValue(lnWb, lnSh1, 17, 1, "This text is rotated 45 degrees")
		  .SetCellTextRotation(lnWb, lnSh1, 17, 1, 45)
		  .SetCellValue(lnWb, lnSh1, 18, 1, "This text is rotated -45 degrees")
		  .SetCellTextRotation(lnWb, lnSh1, 18, 1, -45)
		
		* Similar text
		  .SetCellValue(lnWb, lnSh1, 15, 7, "This text is similar")
		  .SetCellValue(lnWb, lnSh1, 16, 7, "This text is similar to the one above but is longer length")
		
		*-* Very long text
		  lcString = "Addtionally, there is a new method for reading an existing XLSX file into the working cursors and then supporting methods to extract the individual cell values and formatting.  However, this XLSX read method is still in development "
		  .SetCellValue(lnWb, lnSh1, 22, 1, lcString)
		  lcString = lcString + "and not yet ready for use.  This is the method OpenXlsxWorkbook() - only use if you want to try it but the method will not necessarily read all the numeric"
		  .SetCellValue(lnWb, lnSh1, 23, 1, lcString)
		  lcString = lcString + " or date values correctly at this point.  I did not want to hold this release of VFPxWorkbookXlsx class for the completion of the reading of the XLSX file due to the other bug fixes."
		  .SetCellValue(lnWb, lnSh1, 24, 1, lcString)
		
		* Text with ASCII > 128
		  .SetCellValue(lnWb, lnSh1, 19, 1, "This text that has ASCII chars > 128:" + CRLF + "Trademark symbol: " + Chr(174) + CRLF + "Copyright symbol: " + Chr(169))
		
		* Column Width examples
		  .SetColumnWidth(lnWb, lnSh1, 1, 25)
		  .SetColumnWidth(lnWb, lnSh1, 2, 15)
		  .SetColumnWidth(lnWb, lnSh1, 3, 15)
		  .SetColumnWidth(lnWb, lnSh1, 4, 20)
		  .SetColumnWidth(lnWb, lnSh1, 5, 15)
		  .SetColumnWidth(lnWb, lnSh1, 6, 25)
		  .SetColumnWidth(lnWb, lnSh1, 9, 15)
		
		*Row inserted
		  .InsertRow(lnWb, lnSh1, 5, INSERT_AFTER)
		
		*Column inserted
		  .InsertColumn(lnWb, lnSh1, 5, INSERT_RIGHT)
		
		* Sheet setup examples
		  .SetPrintOrientation(lnWb, lnSh1, PORTRAIT_PRINT_ORIENTATION)
		  .SetPaperSize(lnWb, lnSh1, PAPERSIZE_LEGAL)
		  .SetSheetScale(lnWb, lnSh1, 50)
		
		*******************************************************************************
		
		  lnSh2 = .AddSheet(lnWb, "Test Sheet 2")
		  If lnSh2 = 0
		    Return False
		  Endif
		  .FreezePanes(lnWb, lnSh2, 1)
		
		  .SetCellValue(lnWb, lnSh2, 1, 1, "Column Header 1")
		  .SetCellValue(lnWb, lnSh2, 1, 2, "Column Header 2")
		  .SetCellValue(lnWb, lnSh2, 1, 3, "Column Header 3")
		  .SetCellValue(lnWb, lnSh2, 1, 4, "Column Header 4")
		  .SetCellValue(lnWb, lnSh2, 1, 5, "Column Header 5")
		
		  .SetCellFont(lnWb, lnSh2, 1, 1, "Arial", 14, True, False, Rgb(255,255,255))
		  .SetCellFill(lnWb, lnSh2, 1, 1, Rgb(51,102,255))
		  .CellFormatPainter(lnWb, lnSh2, 1, 1, 1, 2, 1, 5)
		
		  .SetColumnWidthRange(lnWb, lnSh2, 1, 5, 24)
		
		* Add integer values to cells
		  For lnRow=2 To 6
		    For lnCol=1 To 5
		      .SetCellValue(lnWb, lnSh2, lnRow, lnCol, lnRow*lnCol)
		    Endfor
		  Endfor
		
		* Add SUM() formula to columns
		  For lnCol=1 To 5
		    lcColumn = .ColumnIndexToAscii(lnCol)
		    .SetCellFormula(lnWb, lnSh2, 7, lnCol, "=SUM(" + lcColumn + "2:" + lcColumn + "6)")
		  Endfor
		
		* Add floating point values to cells
		  For lnRow=10 To 15
		    For lnCol=3 To 5
		      .SetCellValue(lnWb, lnSh2, lnRow, lnCol, lnRow*1.25)
		    Endfor
		  Endfor
		
		* Add AVERAGE(), MAX(), & MIN() formula to columns
		  .SetCellFormula(lnWb, lnSh2, 16, 3, "=AVERAGE(C10:C15)")
		  .SetCellFormula(lnWb, lnSh2, 16, 4, "=MAX(D10:D15)")
		  .SetCellFormula(lnWb, lnSh2, 16, 5, "=MIN(E10:E15)")
		
		  .SetCellValue(lnWb, lnSh2, 16, 1, "This row contains calculated formulas -->")
		
		* Merge some cells
		  .MergeCells(lnWb, lnSh2, 2, 8, 2, 10)
		  .MergeCells(lnWb, lnSh2, 3, 8, 3, 10)
		  .MergeCells(lnWb, lnSh2, 5, 8, 10, 10)
		  .SetCellValue(lnWb, lnSh2, 2, 8, "Merged H2:J2")
		  .SetCellValue(lnWb, lnSh2, 3, 8, "Merged H3:J3")
		  .SetCellValue(lnWb, lnSh2, 5, 8, "Merged H5:J10")
		  .SetCustomPaperSize(lnWb, lnSh2, 841, 1189, "mm")
		  .SetHeaderFooterSetup(lnWb, lnSh2, False, True, False, False)
		  .SetHeaderFooterText(lnWb, lnSh2, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_HDR_CENTER, "This is First Page", "Arial", 16, HEADERFOOTER_FONT_STYLE_BOLD, Rgb(255,0,0))
		  .SetHeaderFooterText(lnWb, lnSh2, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_HDR_CENTER, "These are Additional Pages", "Arial", 10, HEADERFOOTER_FONT_STYLE_BOLD, Rgb(0,128,0))
		  .SetHeaderFooterText(lnWb, lnSh2, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_FTR_CENTER, "Page &amp;P of &amp;N", "Arial", 16, HEADERFOOTER_FONT_STYLE_BOLD)
		
		*******************************************************************************
		
		  lnSh3 = .AddSheet(lnWb, "Number Formats")
		  If lnSh3 = 0
		    Return False
		  Endif
		
		  lnFormat = .AddNumericFormat(lnWb, '[Green]"$"#,##0.00;[Red]"$"#,##0.00')
		*lnFormat = this.AddCustomNumericFormat(lnWb, '[Green]"$"#,##0.00', '[Red]"$"#,##0.00')
		  .SetCellValue(lnWb, lnSh3, 1, 1, 56.558)
		  .SetCellValue(lnWb, lnSh3, 1, 2, "Custom defined format: " + .GetCustomNumericFormat(lnWb, lnFormat))
		  .SetCellNumberFormat(lnWb, lnSh3, 1, 1, lnFormat)
		
		  .SetColumnWidth(lnWb, lnSh3, 1, 18)
		  .SetColumnWidth(lnWb, lnSh3, 2, 60)
		
		  .SetCellValue(lnWb, lnSh3, 3, 1, 14)
		  .SetCellValue(lnWb, lnSh3, 3, 2, "Integer format")
		  .SetCellNumberFormat(lnWb, lnSh3, 3, 1, CELL_FORMAT_INTEGER)
		
		  .SetCellValue(lnWb, lnSh3, 4, 1, 13355.2)
		  .SetCellValue(lnWb, lnSh3, 4, 2, "Float format")
		  .SetCellNumberFormat(lnWb, lnSh3, 4, 1, CELL_FORMAT_FLOAT)
		
		  .SetCellValue(lnWb, lnSh3, 5, 1, 16898)
		  .SetCellValue(lnWb, lnSh3, 5, 2, "Integer format, comma separated")
		  .SetCellNumberFormat(lnWb, lnSh3, 5, 1, CELL_FORMAT_COMMA_INTEGER)
		
		  .SetCellValue(lnWb, lnSh3, 6, 1, 13355.20)
		  .SetCellValue(lnWb, lnSh3, 6, 2, "Float format, comma separated")
		  .SetCellNumberFormat(lnWb, lnSh3, 6 , 1, CELL_FORMAT_COMMA_FLOAT)
		
		  .SetCellValue(lnWb, lnSh3, 7, 1, -13355.20)
		  .SetCellValue(lnWb, lnSh3, 7, 2, "Currency format, negative in parenthesis")
		  .SetCellNumberFormat(lnWb, lnSh3, 7, 1, CELL_FORMAT_CURRENCY_PAREN)
		
		  .SetCellValue(lnWb, lnSh3, 8, 1, -13355.20)
		  .SetCellValue(lnWb, lnSh3, 8, 2, "Currency format, negative red in parenthesis")
		  .SetCellNumberFormat(lnWb, lnSh3, 8, 1, CELL_FORMAT_CURRENCY_RED_PAREN)
		
		  .SetCellValue(lnWb, lnSh3, 10, 1, 0.55)
		  .SetCellValue(lnWb, lnSh3, 10, 2, "Percent format, integer")
		  .SetCellNumberFormat(lnWb, lnSh3, 10, 1, CELL_FORMAT_PERCENT_INTEGER)
		
		  .SetCellValue(lnWb, lnSh3, 11, 1, 0.5534)
		  .SetCellValue(lnWb, lnSh3, 11, 2, "Percent format, float")
		  .SetCellNumberFormat(lnWb, lnSh3, 11, 1, CELL_FORMAT_PERCENT_FLOAT)
		
		  .SetCellValue(lnWb, lnSh3, 13, 1, 456800000.00)
		  .SetCellValue(lnWb, lnSh3, 13, 2, "Exponential format")
		  .SetCellNumberFormat(lnWb, lnSh3, 13, 1, CELL_FORMAT_EXPONENT)
		
		  .SetCellValue(lnWb, lnSh3, 15, 1, 0.25)
		  .SetCellValue(lnWb, lnSh3, 15, 2, "Fraction format, single place")
		  .SetCellNumberFormat(lnWb, lnSh3, 15, 1, CELL_FORMAT_FRACTION_1)
		
		  .SetCellValue(lnWb, lnSh3, 16, 1, 0.3125)
		  .SetCellValue(lnWb, lnSh3, 16, 2, "Fraction format, 2 places")
		  .SetCellNumberFormat(lnWb, lnSh3, 16, 1, CELL_FORMAT_FRACTION_2)
		
		  .SetCellValue(lnWb, lnSh3, 18, 1, Date())
		  .SetCellValue(lnWb, lnSh3, 18, 2, "Default date format")
		  .SetCellNumberFormat(lnWb, lnSh3, 18, 1, CELL_FORMAT_DATE_DMMMYY)
		
		  .SetCellValue(lnWb, lnSh3, 19, 1, Date())
		  .SetCellValue(lnWb, lnSh3, 19, 2, "Date format, d-mmm-yy")
		  .SetCellNumberFormat(lnWb, lnSh3, 19, 1, CELL_FORMAT_DATE_DMMMYY)
		
		  .SetCellValue(lnWb, lnSh3, 20, 1, Date())
		  .SetCellValue(lnWb, lnSh3, 20, 2, "Date format, d-mmm")
		  .SetCellNumberFormat(lnWb, lnSh3, 20, 1, CELL_FORMAT_DATE_DMMM)
		
		  .SetCellValue(lnWb, lnSh3, 21, 1, Date())
		  .SetCellValue(lnWb, lnSh3, 21, 2, "Date format, mmm-yy")
		  .SetCellNumberFormat(lnWb, lnSh3, 21, 1, CELL_FORMAT_DATE_MMMYY)
		
		  .SetCellValue(lnWb, lnSh3, 23, 1, 0.35733796296296294)
		  .SetCellValue(lnWb, lnSh3, 23, 2, "Time format, h:mm AM/PM")
		  .SetCellNumberFormat(lnWb, lnSh3, 23, 1, CELL_FORMAT_TIME_HMMAMPM)
		
		  .SetCellValue(lnWb, lnSh3, 24, 1, 0.35733796296296294)
		  .SetCellValue(lnWb, lnSh3, 24, 2, "Time format, h:mm:ss AM/PM")
		  .SetCellNumberFormat(lnWb, lnSh3, 24, 1, CELL_FORMAT_TIME_HMMSSAMPM)
		
		  .SetCellValue(lnWb, lnSh3, 25, 1, 0.35733796296296294)
		  .SetCellValue(lnWb, lnSh3, 25, 2, "Time format, h:mm")
		  .SetCellNumberFormat(lnWb, lnSh3, 25, 1, CELL_FORMAT_TIME_HMM)
		
		  .SetCellValue(lnWb, lnSh3, 26, 1, 0.35733796296296294)
		  .SetCellValue(lnWb, lnSh3, 26, 2, "Time format, h:mm:ss")
		  .SetCellNumberFormat(lnWb, lnSh3, 26, 1, CELL_FORMAT_TIME_HMMSS)
		
		  .SetCellValue(lnWb, lnSh3, 28, 1, Datetime())
		  .SetCellValue(lnWb, lnSh3, 28, 2, "Date-Time format, m/d/yy h:mm")
		  .SetCellNumberFormat(lnWb, lnSh3, 28, 1, CELL_FORMAT_DATETIME_MDYYHMM)
		
		  .SetCellValue(lnWb, lnSh3, 29, 1, Datetime())
		  .SetCellValue(lnWb, lnSh3, 29, 2, "Date-Time format, [$-409]dd/mmm/yyyy\ h:mm\ AM/PM;@")
		  .SetCellNumberFormat(lnWb, lnSh3, 29, 1, CELL_FORMAT_DATETIME_DDMMMYYYY_TTAM)
		
		  .SetCellValue(lnWb, lnSh3, 30, 1, Datetime())
		  .SetCellValue(lnWb, lnSh3, 30, 2, "Date-Time format, dd/mmm/yyyy\ h:mm;@")
		  .SetCellNumberFormat(lnWb, lnSh3, 30, 1, CELL_FORMAT_DATETIME_DDMMMYYYY_TT24)
		
		  .SetCellValue(lnWb, lnSh3, 31, 1, Datetime())
		  .SetCellValue(lnWb, lnSh3, 31, 2, "Date-Time format, [$-409]mmm\ d\,\ yyyy\ h:mm\ AM/PM;@")
		  .SetCellNumberFormat(lnWb, lnSh3, 31, 1, CELL_FORMAT_DATETIME_MMMDDYYYY_TTAM)
		
		  .SetCellValue(lnWb, lnSh3, 32, 1, Datetime())
		  .SetCellValue(lnWb, lnSh3, 32, 2, "Date-Time format, [$-409]mmm\ d\,\ yyyy\ h:mm;@")
		  .SetCellNumberFormat(lnWb, lnSh3, 32, 1, CELL_FORMAT_DATETIME_MMMDDYYYY_TT24)
		
		  .SetCellValue(lnWb, lnSh3, 33, 1, Datetime())
		  .SetCellValue(lnWb, lnSh3, 33, 2, "Date-Time format, m/d/yy\ h:mm\ AM/PM;@")
		  .SetCellNumberFormat(lnWb, lnSh3, 33, 1, CELL_FORMAT_DATETIME_MDYY_TTAM)
		
		  .SetCellValue(lnWb, lnSh3, 34, 1, Datetime())
		  .SetCellValue(lnWb, lnSh3, 34, 2, "Date-Time format, m/d/yy\ h:mm;@")
		  .SetCellNumberFormat(lnWb, lnSh3, 34, 1, CELL_FORMAT_DATETIME_MDYY_TT24)
		
		  .SetCellValue(lnWb, lnSh3, 36, 1, -89235)
		  .SetCellValue(lnWb, lnSh3, 36, 2, "Numeric format, #,##0;(#,##0)")
		  .SetCellNumberFormat(lnWb, lnSh3, 36, 1, CELL_FORMAT_COMMA_INTEGER_PAREN)
		
		  .SetCellValue(lnWb, lnSh3, 37, 1, -12457)
		  .SetCellValue(lnWb, lnSh3, 37, 2, "Numeric format, #,##0;[Red](#,##0)")
		  .SetCellNumberFormat(lnWb, lnSh3, 37, 1, CELL_FORMAT_COMMA_INTEGER_RED_PAREN)
		
		  .SetCellValue(lnWb, lnSh3, 38, 1, -1245789.22)
		  .SetCellValue(lnWb, lnSh3, 38, 2, "Numeric format, #,##0.00;(#,##0.00)")
		  .SetCellNumberFormat(lnWb, lnSh3, 38, 1, CELL_FORMAT_COMMA_FLOAT_PAREN)
		
		  .SetCellValue(lnWb, lnSh3, 39, 1, -125896.33)
		  .SetCellValue(lnWb, lnSh3, 39, 2, "Numeric format, #,##0.00;[Red](#,##0.00)")
		  .SetCellNumberFormat(lnWb, lnSh3, 39, 1, CELL_FORMAT_COMMA_FLOAT_RED_PAREN)
		
		  .SetCellValue(lnWb, lnSh3, 41, 1, 6.25E-2)
		  .SetCellValue(lnWb, lnSh3, 41, 2, "Time format")
		  .SetCellNumberFormat(lnWb, lnSh3, 41, 1, CELL_FORMAT_TIME_MMSS)
		
		  .SetCellValue(lnWb, lnSh3, 42, 1, 0.35733796296296294)
		  .SetCellValue(lnWb, lnSh3, 42, 2, "Time format, [h]:mm:ss")
		  .SetCellNumberFormat(lnWb, lnSh3, 42, 1, CELL_FORMAT_TIME_H_MMSS)
		
		  .SetCellValue(lnWb, lnSh3, 44, 1, -45.55)
		  .SetCellValue(lnWb, lnSh3, 44, 2, "CELL_FORMAT_CURRENCY_RED")
		  .SetCellNumberFormat(lnWb, lnSh3, 44, 1, CELL_FORMAT_CURRENCY_RED)
		
		  .SetCellValue(lnWb, lnSh3, 45, 1, -45.55)
		  .SetCellValue(lnWb, lnSh3, 45, 2, "CELL_FORMAT_ACC_CURR_POUNDS")
		  .SetCellNumberFormat(lnWb, lnSh3, 45, 1, CELL_FORMAT_ACC_CURR_POUNDS)
		
		  .SetCellValue(lnWb, lnSh3, 46, 1, -45.55)
		  .SetCellValue(lnWb, lnSh3, 46, 2, "CELL_FORMAT_ACC_CURR_EURO")
		  .SetCellNumberFormat(lnWb, lnSh3, 46, 1, CELL_FORMAT_ACC_CURR_EURO)
		
		  .SetCellValue(lnWb, lnSh3, 47, 1, -45.55)
		  .SetCellValue(lnWb, lnSh3, 47, 2, "CELL_FORMAT_CURR_EURO_RED")
		  .SetCellNumberFormat(lnWb, lnSh3, 47, 1, CELL_FORMAT_CURR_EURO_RED)
		
		  .SetCellValue(lnWb, lnSh3, 48, 1, -45.55)
		  .SetCellValue(lnWb, lnSh3, 48, 2, "CELL_FORMAT_CURR_POUNDS_RED")
		  .SetCellNumberFormat(lnWb, lnSh3, 48, 1, CELL_FORMAT_CURR_POUNDS_RED)
		
		  .SetPrintOrientation(lnWb, lnSh3, LANDSCAPE_PRINT_ORIENTATION)
		*-*	this.SetPrintFitToHeight(lnWb, lnSh3, 2)
		
		*******************************************************************************
		
		  lnSh4 = .AddSheet(lnWb, "Color Sheet")
		  If lnSh4 = 0
		    Return False
		  Endif
		
		  .SetCellValue(lnWb, lnSh4, 1, 1, "RGB(51,102,255)")
		  .SetCellFill(lnWb, lnSh4, 1, 1, Rgb(51,102,255))
		
		  .SetCellValue(lnWb, lnSh4, 1, 2, "RGB(255,0,0)")
		  .SetCellFill(lnWb, lnSh4, 1, 2, Rgb(255,0,0))
		
		  .SetCellAlignmentRange(lnWb, lnSh4, 1, 1, 1, 2, CELL_HORIZ_ALIGN_CENTER, CELL_VERT_ALIGN_CENTER)
		
		  .SetColumnWidthRange(lnWb, lnSh4, 1, 2, 18)
		  .SetRowHeight(lnWb, lnSh4, 1, 60)
		
		*******************************************************************************
		
		  lnSh5 = .AddSheet(lnWb, "Blank Sheet")
		
		*******************************************************************************
		
		  lnSh6 = .AddSheet(lnWb, "List Values", HIDDEN_SHEET_STATE)
		  If lnSh6 = 0
		    Return False
		  Endif
		
		  .SetCellValidation(lnWb, lnSh1, 13, 1, LIST_VALID_TYPE, , , , , , , , , "Yes,No,Maybe")
		  .SetCellValue(lnWb, lnSh1, 13, 2, "The cell to the left has a droplist validation")
		
		  .SetCellValue(lnWb, lnSh6, 1, 1, "Named Value List")
		  .SetCellValue(lnWb, lnSh6, 2, 1, "Named Value 1")
		  .SetCellValue(lnWb, lnSh6, 3, 1, "Named Value 2")
		  .SetCellValue(lnWb, lnSh6, 4, 1, "Named Value 3")
		  .SetCellValue(lnWb, lnSh6, 5, 1, "Named Value 4")
		  .SetCellValue(lnWb, lnSh6, 6, 1, "Named Value 5")
		  .SetCellValue(lnWb, lnSh6, 7, 1, "Named Value 6")
		
		  lcNamedRange = .AddNamedRange(lnWb, lnSh6, "Named Range", SCOPE_WB_NAMED_RANGE, "This is a comment", 2, 1, 7, 1)
		
		  .SetCellValidation(lnWb, lnSh1, 14, 1, LIST_VALID_TYPE, , , , , , , , , "=" + lcNamedRange)
		  .SetCellValue(lnWb, lnSh1, 14, 2, "The cell to the left has a droplist validation based on a Named Range (stored in Hidden Sheet6)")
		
		  .InsertCell(lnWb, lnSh1,  9, 9, INSERT_RIGHT)
		  .InsertCell(lnWb, lnSh1, 11, 9, INSERT_BEFORE)
		
		*-*  For testing sheet saving only
		*this.DeleteSheet(lnWb, lnSh2)
		
		  .SaveWorkbook(lnWb)
		  If .Debug
		    .DebugCursorsToFile("ExcelTest")
		  Endif
		Endwith
		
	ENDPROC

	PROTECTED PROCEDURE derivesheetname		&& Derives the sheet name
		Lparameters txWB
		Do Case
		Case Vartype(txWB) = "C"
		  lcSheetName = Juststem(txWB)
		
		Case Vartype(txWB) = "N"
		  lcSheetName = Juststem(This.GetWorkbookFileName(txWB))
		
		Otherwise
		  Return ""
		Endcase
		Return lcSheetName
		
	ENDPROC

	PROTECTED PROCEDURE Destroy
		Set Debugout To
		This.DestroyWorkingCursors()
		This.OnDestroy()
		
	ENDPROC

	PROTECTED PROCEDURE destroyworkingcursors		&& Destroys the working cursors
		Try
		  Use In Select('xl_strings')
		  Use In Select('xl_workbooks')
		  Use In Select('xl_sheets')
		  Use In Select('xl_cells')
		  Use In Select('xl_fonts')
		  Use In Select('xl_fills')
		  Use In Select('xl_borders')
		  Use In Select('xl_mergecells')
		  Use In Select('xl_colwidths')
		  Use In Select('xl_hdrfooterdefn')
		  Use In Select('xl_hdrfootertext')
		  Use In Select('xl_rowheights')
		  Use In Select('xl_numfmts')
		  Use In Select('xl_namerange')
		  Use In Select('xl_validation')
		  Use In Select('xl_strformat')
		  Use In Select('xl_cellxfs')
		  Use In Select('xl_rows')
		  Use In Select('xl_ndxcolors')
		  Use In Select('xl_mrucolors')
		  Use In Select('xl_relationships')
		  Use In Select('xl_extsheets')
		  Use In Select('xl_extcells')
		
		Catch To loException
		Endtry
		
	ENDPROC

	PROTECTED PROCEDURE documentation		&& Documentation of the methods and properties for this class
		*-*
		*-* Written by:  Vilhelm Praisach
		*-*              Gregory Green
		*-*
		*-* Release History:
		*-*
		*-*  May 11, 2015     Initial release.
		*-*  May 12, 2015     Added new methods: SetCellFormatRange, SetCellBorderRange, SaveGridToWorkbook
		*-*                   Added new properties: Title, Subject, CompanyName
		*-*                   Added check in SetCellValue that if a value is being set in a merged cell range then the value is set in the upper
		*-*                       left cell of the merged range
		*-*                   Corrected sheet references when writing the sheet XML
		*-*  May 27, 2015     Added new methods: ConvertPixelsToExcelUnits, GetWorkbook, GetWorkbookSheets, DeleteWorkbook, DeleteAllWorkbooks,
		*-*                                      SetCellAlignment, SetCellNumberDecimals, SetCellNumberFormat, SetCellNumberFormatRange,
		*-*                                      SetColumnWidthRange, SetRowHeight, SetRowHeightRange, SetCellWordWrap
		*-*                   Renamed method RemoveSheet to DeleteSheet
		*-*                   Corrected string to XML conversion (was performing a double conversion of the string)
		*-*                   Corrected issue of generated XLSX file being deleted; increase of Sleep() time for file rename
		*-* June 1, 2015      Corrected bug in merge cell and cell value assignment (after a merge cell was performed any subsequent sheets
		*-*                        added that had cells in the same merge range with value assignments was not having the values set correctly)
		*-*                   Changed property name ExcelXlsxVersion to ExcelXlsxRelease; this property will give the Release number (integer)
		*-*                        of this class
		*-* June 5, 2015      Added to set the default selected table/cursor (value retuned by ALIAS() function) when the default table/cursor
		*-*                        is changed in a method
		*-*                   Added new method: SaveTableToWorkbook
		*-* June 8, 2015      No new features.  Code was optimized for better performance.
		*-*
		*-*                   The first optimization I changed the SetCellValue() code to now always attempt to INSERT first. I added the CANDIDATE
		*-*                   clause to the primary INDEX so that if a cell is already entered, the INSERT command will fail in a TRY-CATCH block
		*-*                   (duplicate KEY); in the CATCH portion I do an update to the cell value. This reduced the time to assign the values
		*-*                   significantly. I had been doing a SEEK() for the cell and updating if found otherwise doing an INSERT
		*-*
		*-*                   The second optimization was how I was assigning a string index value. The original code did a SELECT-SQL WITH a MAX()
		*-*                   for the last used index value IN the workbook (strings are universal TO a workbook); I changed to a property value
		*-*                   (array indexed by the workbook number) and then just increment this value as it is used. Great amount of savings here too.
		*-*
		*-*                   The LAST optimization was in how the Sheet.xml were being written. I now just do a SCAN across the cells and add to the
		*-*                   XML. I was doing several SQL calls to first get the rows and then SQL calls TO the columns for each row. Again not as
		*-*                   efficient as just SCAN-ENDSCAN on the cells cursor table. Had to build in logic to populate rows that did not have a
		*-*                   cell value assigned but had row height assigned. The SQL coding was easier for this but at a great cost in time.
		*-* June 9, 2015      No new features.  Bug fix for a nasty crash of Excel when the print or print-preview is selected.  Congratulations to
		*-*                   Vilhelm for finding this bug.
		*-* July 1, 2015      Corrected return value for AddNumericFormat.
		*-*                   Changed the parameters on AddNumericFormat(); now just pass the numeric format
		*-*
		*-* Oct 29, 2015      Added new functions for opening an existing workbook (xlsx).  Added sheet print formatting methods.
		*-*
		*-************************************************************************************************************************************
	ENDPROC

	PROCEDURE freezepanes		&& Freezes the panes of the sheet
		Lparameters tnWB, tnSheet, tnTopRowCount, tnSideColCount
		Local lxReturn
		Do Case
		Case Pcount() < 3
		  Return False
		
		Case Pcount() = 3
		  tnSideColCount = 0
		Endcase
		If Vartype(tnTopRowCount) != 'N'
		  tnTopRowCount = 0
		Endif
		If Vartype(tnSideColCount) != 'N'
		  tnSideColCount = 0
		Endif
		If This.GetSheetRecord(tnWB, tnSheet)
		  Replace xl_sheets.xsplit With tnSideColCount, ;
		    xl_sheets.ysplit With tnTopRowCount In xl_sheets
		  lxReturn = True
		Else
		  lxReturn = False
		Endif
		Return lxReturn
		
	ENDPROC

	PROTECTED PROCEDURE getalphanumericsplit		&& Returns the position of the alpha and numeric split
		Lparameters tcText
		Local lnChr
		For lnChr=1 To Len(tcText)
		  If Isdigit(Substr(tcText, lnChr, 1))
		    Return lnChr
		  Endif
		Endfor
		Return 0
		
	ENDPROC

	PROTECTED PROCEDURE getbordersrecord		&& Gets the border record; returns True if found, or False in not found
		Lparameters tnWB, tcLStyle, tnLColor, tcRStyle, tnRColor, tcTStyle, tnTColor, tcBStyle, tnBColor, tcDStyle, tnDColor, tnDiagDn, tnDiagUp
		Return Seek(BinToC(tnWB) + tcLStyle + BinToC(tnLColor) + tcRStyle + BinToC(tnRColor) + tcTStyle + BinToC(tnTColor) + tcBStyle + BinToC(tnBColor) + ;
		  tcDStyle + BinToC(tnDColor) + BinToC(tnDiagDn) + BinToC(tnDiagUp), "xl_borders", "cellborder")
		
	ENDPROC

	PROCEDURE getcellalignment		&& Returns the cell alignment
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local loAlignInfo
		If Pcount() < 4
		  Return Null
		Endif
		If This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) And This.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		  loAlignInfo = Createobject("Empty")
		  AddProperty(loAlignInfo, "HorzAlign", xl_cellxfs.halign)
		  AddProperty(loAlignInfo, "VertAlign", xl_cellxfs.valign)
		Else
		  loAlignInfo = Null
		Endif
		Return loAlignInfo
		
	ENDPROC

	PROCEDURE getcellborders		&& Returns the cell border info
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local loBdrInfo
		If Pcount() < 4
		  Return Null
		Endif
		If This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) And This.GetCellXfsRecord(tnWB, xl_cells.cellxfs) And This.GetCursorRecord("xl_borders", tnWB, xl_cellxfs.borderId)
		  loBdrInfo = Createobject("Empty")
		  AddProperty(loBdrInfo, "LeftStyle",  xl_borders.lstyle)
		  AddProperty(loBdrInfo, "LeftColor",  xl_borders.lcolor)
		  AddProperty(loBdrInfo, "LeftTheme",  xl_borders.ltheme)
		  AddProperty(loBdrInfo, "LeftTint",   xl_borders.ltint)
		  AddProperty(loBdrInfo, "LeftIndex",  xl_borders.lindexed)
		
		  AddProperty(loBdrInfo, "RightStyle", xl_borders.rstyle)
		  AddProperty(loBdrInfo, "RightColor", xl_borders.rcolor)
		  AddProperty(loBdrInfo, "RightTheme", xl_borders.rtheme)
		  AddProperty(loBdrInfo, "RightTint",  xl_borders.rtint)
		  AddProperty(loBdrInfo, "RightIndex", xl_borders.rindexed)
		
		  AddProperty(loBdrInfo, "TopStyle",   xl_borders.tstyle)
		  AddProperty(loBdrInfo, "TopColor",   xl_borders.tcolor)
		  AddProperty(loBdrInfo, "TopTheme",   xl_borders.ttheme)
		  AddProperty(loBdrInfo, "TopTint",    xl_borders.ttint)
		  AddProperty(loBdrInfo, "TopIndex",   xl_borders.tindexed)
		
		  AddProperty(loBdrInfo, "BotStyle",   xl_borders.bstyle)
		  AddProperty(loBdrInfo, "BotColor",   xl_borders.bcolor)
		  AddProperty(loBdrInfo, "BotTheme",   xl_borders.btheme)
		  AddProperty(loBdrInfo, "BotTint",    xl_borders.btint)
		  AddProperty(loBdrInfo, "BotIndex",   xl_borders.bindexed)
		
		  AddProperty(loBdrInfo, "DiagStyle",  xl_borders.dstyle)
		  AddProperty(loBdrInfo, "DiagColor",  xl_borders.dcolor)
		  AddProperty(loBdrInfo, "DiagTheme",  xl_borders.dtheme)
		  AddProperty(loBdrInfo, "DiagTint",   xl_borders.dtint)
		  AddProperty(loBdrInfo, "DiagIndex",  xl_borders.dindexed)
		
		  AddProperty(loBdrInfo, "DiagDn",     xl_borders.diagdn)
		  AddProperty(loBdrInfo, "DiagUp",     xl_borders.diagup)
		Else
		  loBdrInfo = Null
		Endif
		Return loBdrInfo
		
	ENDPROC

	PROCEDURE getcelldatatype		&& Returns the data type for the selected cell
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Return Iif(Pcount() >= 4 And This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol), xl_cells.DataType, Null)
		
	ENDPROC

	PROCEDURE getcellfill		&& Returns the fill info for the cell
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local loFillInfo
		If Pcount() < 4
		  Return Null
		Endif
		With This
		  If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) And .GetCellXfsRecord(tnWB, xl_cells.cellxfs) And .GetCursorRecord("xl_fills", tnWB, xl_cellxfs.fillid)
		    loFillInfo = Createobject("Empty")
		    AddProperty(loFillInfo, "FgColor",   xl_fills.fgcolor)
		    AddProperty(loFillInfo, "BgColor",   xl_fills.bgcolor)
		    AddProperty(loFillInfo, "PatType",   xl_fills.patttype)
		    AddProperty(loFillInfo, "Theme",     xl_fills.Theme)
		    AddProperty(loFillInfo, "Tint",      xl_fills.tint)
		    AddProperty(loFillInfo, "FgIndexed", xl_fills.fgindexed)
		    AddProperty(loFillInfo, "BgIndexed", xl_fills.bgindexed)
		  Else
		    loFillInfo = Null
		  Endif
		Endwith
		Return loFillInfo
		
	ENDPROC

	PROCEDURE getcellfont		&& Returns the cell font settings
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local loFontInfo
		If Pcount() < 4
		  Return Null
		Endif
		With This
		  If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) And .GetCellXfsRecord(tnWB, xl_cells.cellxfs) And .GetCursorRecord("xl_fonts", tnWB, xl_cellxfs.fontid)
		    loFontInfo = Createobject("Empty")
		    AddProperty(loFontInfo, "FontName",        Alltrim(xl_fonts.fname))
		    AddProperty(loFontInfo, "FontSize",        xl_fonts.Fsize)
		    AddProperty(loFontInfo, "FontBold",        xl_fonts.fbold)
		    AddProperty(loFontInfo, "FontItalic",      xl_fonts.fitalic)
		    AddProperty(loFontInfo, "ForeColor",       xl_fonts.fcolor)
		    AddProperty(loFontInfo, "FontUnderline",   Alltrim(xl_fonts.uline))
		    AddProperty(loFontInfo, "FontStrikeThr",   xl_fonts.strkthr)
		    AddProperty(loFontInfo, "FontVerticalPos", Alltrim(xl_fonts.fvpos))
		  Else
		    loFontInfo = Null
		  Endif
		Endwith
		Return loFontInfo
		
	ENDPROC

	PROCEDURE getcellformula		&& Returns the cell formula expression
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Return Iif(Pcount() >= 4 and This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol), Alltrim(xl_cells.cellformula), Null)
		
	ENDPROC

	PROTECTED PROCEDURE getcellformulafromxml		&& Gets the cell formula from the XML node
		Lparameters tcFormula, tnCellCol
		Local lcFormula, lcShared, lnId, lcTemp, lnNdx, lcChr, lcAddExpr, lnCol, lcRef, lcRefBeg, lcRefEnd, llColRelative
		Local lnColBase, llRowRelative, lnRowBase
		With This
		  lcFormula = .GetNodeElementValue(tcFormula)
		  lcShared  = .GetNodeAttributeValue(tcFormula, "t")
		  If !Empty(lcShared)
		*-*	The formula is a shared formula
		    lnId = .GetNodeAttributeValue(tcFormula, "si")
		    If Empty(lcFormula)
		      If Seek(lnId, "t_shared", "id")
		*-*			Shared formula already added; update the column:row relative references
		        lcFormula = ""
		        lcTemp = Alltrim(t_shared.cellformula)
		        Do Case
		        Case t_shared.colrelative                && Forumla column is relative
		          lnNdx = 1
		          Do While lnNdx <= Len(lcTemp)
		            lcChr = Substr(lcTemp, lnNdx, 1)
		            If Isalpha(lcChr)
		              lcAddExpr = lcChr
		              Do While lnNdx <= Len(lcTemp)
		                lnNdx = lnNdx + 1
		                lcChr = Substr(lcTemp, lnNdx, 1)
		                Do Case
		                Case Isalpha(lcChr)
		                  lcAddExpr = lcAddExpr + lcChr
		
		                Case Isdigit(lcChr)
		                  lnCol = .ColumnAsciiToIndex(lcAddExpr)
		                  lnCol = lnCol + (tnCellCol - t_shared.colbase)
		                  lcAddExpr = .ColumnIndexToAscii(lnCol) + lcChr
		                  Exit
		
		                Otherwise
		                  lcAddExpr = lcAddExpr + lcChr
		                  Exit
		                Endcase
		              Enddo
		            Else
		              lcAddExpr = lcChr
		            Endif
		            lcFormula = lcFormula + lcAddExpr
		            lnNdx = lnNdx + 1
		          Enddo
		
		        Case t_shared.rowrelative                && Forumla row is relative
		          lnNdx = 1
		          Do While lnNdx <= Len(lcTemp)
		            lcChr = Substr(lcTemp, lnNdx, 1)
		            If Isdigit(lcChr)
		              lcAddExpr = lcChr
		              Do While lnNdx <= Len(lcTemp)
		                lnNdx = lnNdx + 1
		                lcChr = Substr(lcTemp, lnNdx, 1)
		                If Isdigit(lcChr)
		                  lcAddExpr = lcAddExpr + lcChr
		                Else
		                  If Isalpha(lcChr)
		                    lcAddExpr = lcAddExpr + lcChr
		                  Else
		                    lnRow = Int(Val(lcAddExpr))
		                    lnRow = lnRow + (lnCellRow - t_shared.rowbase)
		                    lcAddExpr = Transform(lnRow) + lcChr
		                  Endif
		                  Exit
		                Endif
		              Enddo
		            Else
		              lcAddExpr = lcChr
		            Endif
		            lcFormula = lcFormula + lcAddExpr
		            lnNdx = lnNdx + 1
		          Enddo
		        Endcase
		      Else
		        lcFormula = ""
		      Endif
		    Else
		      lcRef = .GetNodeAttributeValue(tcFormula, "ref")
		      If !Seek(lnId, "t_shared", "id") And Occurs(":", lcRef) > 0
		        lcRefBeg = .GetColumnInColRowPair(Getwordnum(lcRef, 1, ":"))
		        lcRefEnd = .GetColumnInColRowPair(Getwordnum(lcRef, 2, ":"))
		        If lcRefBeg == lcRefEnd
		          llColRelative = False
		          lnColBase     = 0
		          llRowRelative = True
		          lnRowBase     = .GetRowInColRowPair(Getwordnum(lcRef, 1, ":"))
		        Else
		          llColRelative = True
		          lnColBase     = .ColumnAsciiToIndex(lcRefBeg)
		          llRowRelative = False
		          lnRowBase     = 0
		        Endif
		        Insert Into t_shared (Id, colrelative, colbase, rowrelative, rowbase, cellformula) ;
		          VALUES (lnId, llColRelative, lnColBase, llRowRelative, lnRowBase, lcFormula)
		      Endif
		    Endif
		  Endif
		Endwith
		Return lcFormula
		
	ENDPROC

	PROCEDURE getcellindent		&& Returns the cell indentation
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local lnIndent
		If Pcount() != 4
		  Return -1
		Endif
		lnIndent = Iif(This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) And This.GetCellXfsRecord(tnWB, xl_cells.cellxfs),;
		  xl_cellxfs.indent, 0)
		Return lnIndent
		
	ENDPROC

	PROCEDURE getcellnumberformat		&& Returns the format code for the selected cell
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local lnNumFmtId
		If Pcount() != 4
		  Return -1
		Endif
		lnNumFmtId = Iif(This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) And This.GetCellXfsRecord(tnWB, xl_cells.cellxfs),;
		  xl_cellxfs.numFmtId, 0)
		Return lnNumFmtId
		
	ENDPROC

	PROCEDURE getcellnumberformattext		&& Returns the selected cell numeric format as text
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local lcFormatCode
		If Pcount() != 4
		  Return ""
		Endif
		Return Iif(Pcount() >= 4 and This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) And This.GetCellXfsRecord(tnWB, xl_cells.cellxfs), ;
		xl_cellxfs.formatcode, '')
		
	ENDPROC

	PROTECTED PROCEDURE getcellrecord		&& Positions to the xl_cells record; returns true if found, or false if not found
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Return Seek(BinToC(tnWB)+BinToC(tnSheet)+BinToC(tnCellRow)+BinToC(tnCellCol), "xl_cells", "cellindex")
		
	ENDPROC

	PROCEDURE getcellstyle		&& Gets the cell style value
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Return Iif(Pcount() = 4 And This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol), xl_cells.cellxfs, -1)
		
	ENDPROC

	PROCEDURE getcelltextrotation		&& Gets the cell text rotation value
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local lnRotation
		If Pcount() != 4
		  Return 99
		Endif
		If This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) And This.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		  lnRotation = xl_cellxfs.Rotation
		  If lnRotation > 90
		    lnRotation = 90 - lnRotation
		  Endif
		Else
		  lnRotation = 0
		Endif
		Return lnRotation
		
	ENDPROC

	PROCEDURE getcellvalidation		&& Returns the cell validation settings
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local loValiation
		loValiation = Createobject("Empty")
		AddProperty(loValiation, "Type", 0)
		AddProperty(loValiation, "Style", 0)
		AddProperty(loValiation, "Operator", 0)
		AddProperty(loValiation, "AllowBlank", False)
		AddProperty(loValiation, "ShowInputMsg", False)
		AddProperty(loValiation, "ShowErrMsg", False)
		AddProperty(loValiation, "ErrMsg", "")
		AddProperty(loValiation, "ErrTitle", "")
		AddProperty(loValiation, "Prompt", "")
		AddProperty(loValiation, "Formula1", "")
		AddProperty(loValiation, "Formula2", "")
		If Pcount() < 4
		  Return loValiation
		Endif
		If This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) And Seek(BinToC(xl_cells.validndx), "xl_validation", "validndx")
		  loValiation.Type         = xl_validation.vtype
		  loValiation.Style        = xl_validation.vstyle
		  loValiation.Operator     = xl_validation.voperator
		  loValiation.AllowBlank   = xl_validation.AllowBlank
		  loValiation.ShowInputMsg = xl_validation.showinpmsg
		  loValiation.ShowErrMsg   = xl_validation.ShowErrMsg
		  loValiation.ErrMsg       = xl_validation.ErrMsg
		  loValiation.ErrTitle     = xl_validation.ErrTitle
		  loValiation.Prompt       = xl_validation.vprompt
		  loValiation.Formula1     = xl_validation.Formula1
		  loValiation.Formula2     = xl_validation.Formula2
		Endif
		Return loValiation
		
	ENDPROC

	PROCEDURE getcellvalue		&& Returns the value of the cell
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local lxValue, lnDays, lnDecimals, lnMSec, lnTime, lnSize, lcType, loException
		If Pcount() < 4
		  Return Null
		Endif
		lxValue = Null
		With This
		  If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		    lnDecimals = Set("DECIMALS")
		    Try
		      Do Case
		      Case xl_cells.DataType = DATA_TYPE_DATE
		        lnDays  = Cast(xl_cells.cellvalue As I)
		        lxValue = Date(1900, 1, 1) + lnDays - 2
		
		      Case xl_cells.DataType = DATA_TYPE_TIME
		        Set Decimals To 12
		        lnMSec  = Cast(xl_cells.cellvalue As N(20,12))
		        lnTime  = lnMSec * 24 * 60 * 60
		        lxValue = Dtot(Date()) + lnTime
		        lxValue = Transform(Hour(lxValue)) + ":" + Transform(Minute(lxValue)) + ":" + Transform(Sec(lxValue))
		
		      Case xl_cells.DataType = DATA_TYPE_DATETIME
		        Set Decimals To 12
		        lnDays  = Cast(xl_cells.cellvalue As I)
		        lxValue = Date(1900, 1, 1) + lnDays - 2
		        lnMSec  = Cast(xl_cells.cellvalue As N(20,12)) - lnDays
		        lnTime  = lnMSec * 24 * 60 * 60
		        lxValue = Dtot(lxValue) + lnTime
		
		      Case xl_cells.DataType = DATA_TYPE_CHAR
		        lxValue = Iif(.GetCursorRecord("xl_strings", tnWB, xl_cells.stringid), Rtrim(xl_strings.stringval), '')
		
		      Case xl_cells.DataType = DATA_TYPE_INT
		        lxValue = Cast(xl_cells.cellvalue As I)
		        lxValue = Iif(lxValue != Val(xl_cells.cellvalue), Cast(xl_cells.cellvalue As N(20,0)), lxValue)
		
		      Case xl_cells.DataType = DATA_TYPE_FLOAT
		        lnSize = Atc(".", Alltrim(xl_cells.cellvalue))
		        lnSize = Iif(lnSize > 0, lnSize + lnDecimals, Len(Alltrim(xl_cells.cellvalue)) + lnDecimals + 1)
		        lcType  = "N(" + Transform(lnSize) + "," + Transform(lnDecimals) + ")"
		        lxValue = Cast(xl_cells.cellvalue As &lcType)
		
		      Case xl_cells.DataType = DATA_TYPE_CURRENCY
		        lxValue = Cast(xl_cells.cellvalue As Y)
		
		      Case xl_cells.DataType = DATA_TYPE_PERCENT
		        lxValue = Transform(Cast(xl_cells.cellvalue As N(14,8)) * 100) + "%"
		
		      Case xl_cells.DataType = DATA_TYPE_GENERAL
		        lxValue = Alltrim(xl_cells.cellvalue)
		
		      Case xl_cells.DataType = DATA_TYPE_FORMULA
		
		      Case xl_cells.DataType = DATA_TYPE_NONE
		        lxValue = Alltrim(xl_cells.cellvalue)
		
		      Otherwise
		        lxValue = Alltrim(xl_cells.cellvalue)
		      Endcase
		
		    Catch To loException
		      Set Step On
		    Finally
		      Set Decimals To &lnDecimals
		    Endtry
		  Endif
		Endwith
		Return lxValue
		
	ENDPROC

	PROCEDURE getcellwordwrap		&& Returns the cell word wrap setting
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Return Iif(Pcount() >= 4 and This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) And This.GetCellXfsRecord(tnWB, xl_cells.cellxfs),;
		 xl_cellxfs.wraptext, Null)
		
	ENDPROC

	PROTECTED PROCEDURE getcellxfsid		&& Returns the Cell XfsId value
		Lparameters tnWB, tnNumFmtId, tnFontId, tnFillId, tnBorderId, tcHAlign, tcVAlign, tnIndex, tnWrapText, tnRotation
		Local lnCellXfsId
		If Seek(BinToC(tnWB)+BinToC(tnNumFmtId)+BinToC(tnFontId)+BinToC(tnFillId)+BinToC(tnBorderId)+BinToC(tnIndex)+BinToC(tnWrapText)+BinToC(tnRotation)+Alltrim(tcHAlign)+Alltrim(tcVAlign), "xl_cellxfs", "cellxfs")
		  lnCellXfsId = xl_cellxfs.Id
		Else
		  lnCellXfsId = This.GetNextId(tnWB, 'xl_cellxfs')
		  Insert Into xl_cellxfs (workbook, Id, numFmtId, fontId, fillId, borderId, halign, valign, indent, wraptext, Rotation) ;
		    VALUES (tnWB, lnCellXfsId, tnNumFmtId, tnFontId, tnFillId, tnBorderId, tcHAlign, tcVAlign, tnIndex, tnWrapText, tnRotation)
		Endif
		Return lnCellXfsId
		
	ENDPROC

	PROTECTED PROCEDURE getcellxfsrecord		&& Positions the record pointer to xl_cellxfs record; returns true if found, or false if not found
		Lparameters tnWB, tnId
		Return Seek(BinToC(tnWB)+BinToC(tnId), "xl_cellxfs", "id")
		
	ENDPROC

	PROTECTED PROCEDURE getchecksum		&& Returns the checksum the string
		Lparameters tcString
		Local lcString, lcCheckSum
		lcString   = Alltrim(tcString)
		lcCheckSum = Sys(2007, lcString, 0, 1)
		lcCheckSum = lcCheckSum + Padr(lcString, (230-Len(lcCheckSum)), "_")
		Return lcCheckSum
		
	ENDPROC

	PROTECTED PROCEDURE getchildnodecount		&& Returns the number of child nodes
		Lparameters tcNode
		Return Occurs("<", tcNode) - 2
		
	ENDPROC

	PROTECTED PROCEDURE getchildnodeelement		&& Returns the selected child node
		Lparameters tcNode, tnChild
		Local lcElement
		lcElement = Strextract(tcNode, '<', '>', tnChild+1, 1)
		Return Strextract(tcNode, '<'+lcElement+'>', '</'+lcElement+'>', 1, 5)
		
	ENDPROC

	PROTECTED PROCEDURE getcolumnincolrowpair		&& Returns the column (Ascii value) in a ColRow pair; i.e., returns A from A6 reference
		Lparameters tcColRow
		Local lnNdx, lcCol, lcChr
		lcCol = ""
		For lnNdx=1 To Len(tcColRow)
		  lcChr = Substr(tcColRow, lnNdx, 1)
		  If Isdigit(lcChr)
		    Exit
		  Endif
		  lcCol = lcCol + lcChr
		Endfor
		Return lcCol
		
	ENDPROC

	PROCEDURE getcolumnwidth		&& Returns the column width
		Lparameters tnWB, tnSheet, tnColumn
		Local lxReturn
		If Pcount() < 3
		  Return Null
		Endif
		If This.GetSheetRecord(tnWB, tnSheet)
		  lxReturn = Iif(Seek(This.GetColWidthKeyExpr(tnWB, tnSheet, tnColumn), "xl_colwidths", "shcolumn"), xl_colwidths.Width, -1)
		Else
		  lxReturn = Null
		Endif
		Return lxReturn
		
	ENDPROC

	PROTECTED PROCEDURE getcolwidthkeyexpr		&& Gets the key expression for c_colwidths
		Lparameters tnWB, tnSheet, tnColumn
		Return BinToC(tnWB)+BinToC(tnSheet)+BinToC(tnColumn)
		
	ENDPROC

	PROTECTED PROCEDURE getcursorrecord		&& Gets the specified xl_cursor record; returns true if found, false if not found
		Lparameters tcCursor, tnWB, tnId
		Return Seek(BinToC(tnWB)+BinToC(tnId), tcCursor, "id")
		
	ENDPROC

	PROCEDURE getcustomnumericformat		&& Returns the format code for the specified custom numeric format
		Lparameters tnWB, tnNumFormat
		Return Iif(Seek(BinToC(tnWB)+BinToC(tnNumFormat), "xl_numfmts", "id"), Alltrim(xl_numfmts.formatcode), '')
		
	ENDPROC

	PROCEDURE getcustompapersize		&& Gets the values for the custom paper size
		Lparameters tnWB, tnSheet
		Local loReturn
		If Pcount() = 2 And This.GetSheetRecord(tnWB, tnSheet)
		  loReturn = Createobject("Empty")
		  AddProperty(loReturn, "PaperWidth",  xl_sheets.Paperwidth)
		  AddProperty(loReturn, "PaperHeight", xl_sheets.paperheight)
		  AddProperty(loReturn, "PaperDimen",  xl_sheets.paperdimen)
		Else
		  loReturn = Null
		Endif
		Return loReturn
		
	ENDPROC

	PROTECTED PROCEDURE getformatkeyexpr		&& Gets the key expression for t_format
		Lparameters tnNbrFmtId, tnNumDec, tnFontId, tnFillId, tnBorderId, tcHAlign, tcVAlign, tlWordWrap
		Return BinToC(tnNbrFmtId)+BinToC(tnNumDec)+BinToC(tnFontId)+BinToC(tnFillId)+BinToC(tnBorderId)+tcHAlign+tcVAlign+Transform(tlWordWrap)
		
	ENDPROC

	PROTECTED PROCEDURE getheaderfooterkeyexpr		&& Gets the key expression for the header footer table record
		Lparameters tnWB, tnSheet, tnPage, tnSection
		Return BinToC(tnWB)+BinToC(tnSheet)+BinToC(tnPage)+BinToC(tnSection)
		
	ENDPROC

	PROCEDURE getinlinefontdefinition		&& Returns the inline formatting definition of cell text for each character group
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local loSharedString, loInline, lcAlias, lnBegPos, lnLen, loCharacter
		If Pcount() != 4
		  Return Null
		Endif
		loSharedString = This.GetSharedStringId(tnWB, tnSheet, tnCellRow, tnCellCol)
		If Isnull(loSharedString)
		  Return Null
		Endif
		lnBegPos = 1
		lcAlias  = Alias()
		loInline = Createobject("Empty")
		AddProperty(loInline, "Workbook", tnWB)
		AddProperty(loInline, "StringId", loSharedString.StringId)
		AddProperty(loInline, "StringValue", loSharedString.StringValue)
		AddProperty(loInline, "Count", 0)
		AddProperty(loInline, "Characters[1]")
		Select xl_strformat
		Set Order To Tag sortorder
		Scan For workbook = tnWB And Id = loSharedString.StringId And !Deleted()
		  lnLen = Len(Rtrim(xl_strformat.stringxml))
		  loCharacter = Createobject("Empty")
		  AddProperty(loCharacter, "BegPos", lnBegPos)
		  AddProperty(loCharacter, "Length", lnLen)
		  AddProperty(loCharacter, "FontName", xl_strformat.fname)
		  AddProperty(loCharacter, "FontSize", xl_strformat.Fsize)
		  AddProperty(loCharacter, "FontBold", xl_strformat.fbold)
		  AddProperty(loCharacter, "FontItalic", xl_strformat.fitalic)
		  AddProperty(loCharacter, "FontColor", xl_strformat.fcolor)
		  AddProperty(loCharacter, "Underline", xl_strformat.uline)
		  AddProperty(loCharacter, "StrikeThru", xl_strformat.strkthr)
		  AddProperty(loCharacter, "SubScript", Iif(xl_strformat.fvpos=FONT_VERTICAL_SUBSCRIPT, True, False))
		  AddProperty(loCharacter, "SuperScript", Iif(xl_strformat.fvpos=FONT_VERTICAL_SUPERSCRIPT, True, False))
		  loInline.Count = loInline.Count + 1
		  Dimension loInline.Characters[loInline.Count]
		  loInline.Characters[loInline.Count] = loCharacter
		  lnBegPos = lnBegPos + lnLen
		Endscan
		Set Order To
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		If loInline.Count = 0
		  loInline = Null
		Endif
		Return loInline
		
	ENDPROC

	PROCEDURE getlastcolumninrow		&& Returns the last column index in the row
		Lparameters tnWB, tnSheet, tnCellRow
		Local lnMaxCol
		If Pcount() < 3
		  Return Null
		Endif
		lnMaxCol = 0
		Select Max(tmp.cellcol) As maxcol From xl_cells As tmp ;
		  WHERE workbook = tnWB ;
		  AND tmp.Sheet = tnSheet ;
		  AND tmp.cellrow = tnCellRow ;
		  AND tmp.celldeleted = False ;
		  INTO Cursor t_temp
		
		If _Tally > 0
		  lnMaxCol = t_temp.maxcol
		Endif
		If Used('t_temp')
		  Use In t_temp
		Endif
		Return lnMaxCol
		
	ENDPROC

	PROCEDURE getlastrownumber		&& Returns the last row number in the sheet
		Lparameters tnWB, tnSheet
		Local Array laMaxRow[1]
		If Pcount() < 2
		  Return Null
		Endif
		Select Max(cellrow) From xl_cells ;
		  WHERE workbook = tnWB ;
		  AND Sheet = tnSheet ;
		  AND celldeleted = False ;
		  INTO Array laMaxRow
		
		Return Iif(_Tally > 0, laMaxRow[1], 0)
		
	ENDPROC

	PROCEDURE getmaxcolumnnumber		&& Returns the max column number for a sheet
		Lparameters tnWB, tnSheet
		Local Array laMaxCol[1]
		If Pcount() < 2
		  Return Null
		Endif
		Select Max(tmp.maxcol) As maxcol From xl_rows As tmp ;
		  WHERE tmp.workbook = tnWB ;
		  AND tmp.Sheet = tnSheet ;
		  INTO Array laMaxCol
		
		Return Iif(_Tally > 0, laMaxCol[1], 0)
		
	ENDPROC

	PROTECTED PROCEDURE getnextid		&& Gets the next sequential Id value
		Lparameters tnWB, tcCursor
		Local lnNdx, lnNextId
		With This
		  Do Case
		  Case tcCursor = "xl_borders"
		    lnNdx = Ascan(.LastBorderId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastBorderId[lnNdx, 2] = .LastBorderId[lnNdx, 2] + 1
		      lnNextId = .LastBorderId[lnNdx, 2]
		    Else
		      lnNdx = Max(1, Alen(.LastBorderId, 1) + 1)
		      Dimension .LastBorderId[lnNdx, 2]
		      .LastBorderId[lnNdx, 1] = tnWB
		      .LastBorderId[lnNdx, 2] = 1
		      lnNextId = 1
		    Endif
		
		  Case tcCursor = "xl_cellxfs"
		    lnNdx = Ascan(.LastCellXfsId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastCellXfsId[lnNdx, 2] = .LastCellXfsId[lnNdx, 2] + 1
		      lnNextId = .LastCellXfsId[lnNdx, 2]
		    Else
		      lnNdx = Max(1, Alen(.LastCellXfsId, 1) + 1)
		      Dimension .LastCellXfsId[lnNdx, 2]
		      .LastCellXfsId[lnNdx, 1] = tnWB
		      .LastCellXfsId[lnNdx, 2] = 1
		      lnNextId = 1
		    Endif
		
		  Case tcCursor = "xl_fills"
		    lnNdx = Ascan(.LastFillId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastFillId[lnNdx, 2] = .LastFillId[lnNdx, 2] + 1
		      lnNextId = .LastFillId[lnNdx, 2]
		    Else
		      lnNdx = Max(1, Alen(.LastFillId, 1) + 1)
		      Dimension .LastFillId[lnNdx, 2]
		      .LastFillId[lnNdx, 1] = tnWB
		      .LastFillId[lnNdx, 2] = 2
		      lnNextId = 2
		    Endif
		
		  Case tcCursor = "xl_fonts"
		    lnNdx = Ascan(.LastFontId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastFontId[lnNdx, 2] = .LastFontId[lnNdx, 2] + 1
		      lnNextId = .LastFontId[lnNdx, 2]
		    Else
		      lnNdx = Max(1, Alen(.LastFontId, 1) + 1)
		      Dimension .LastFontId[lnNdx, 2]
		      .LastFontId[lnNdx, 1] = tnWB
		      .LastFontId[lnNdx, 2] = 1
		      lnNextId = 1
		    Endif
		
		  Case tcCursor = "xl_ndxcolors"
		    lnNdx = Ascan(.LastIndexColorId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastIndexColorId[lnNdx, 2] = .LastIndexColorId[lnNdx, 2] + 1
		      lnNextId = .LastIndexColorId[lnNdx, 2]
		    Else
		      lnNdx = Max(1, Alen(.LastIndexColorId, 1) + 1)
		      Dimension .LastIndexColorId[lnNdx, 2]
		      .LastIndexColorId[lnNdx, 1] = tnWB
		      .LastIndexColorId[lnNdx, 2] = 1
		      lnNextId = 1
		    Endif
		
		  Case tcCursor = "xl_mrucolors"
		    lnNdx = Ascan(.LastMruColorId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastMruColorId[lnNdx, 2] = .LastMruColorId[lnNdx, 2] + 1
		      lnNextId = .LastMruColorId[lnNdx, 2]
		    Else
		      lnNdx = Max(1, Alen(.LastMruColorId, 1) + 1)
		      Dimension .LastMruColorId[lnNdx, 2]
		      .LastMruColorId[lnNdx, 1] = tnWB
		      .LastMruColorId[lnNdx, 2] = 1
		      lnNextId = 1
		    Endif
		
		  Case tcCursor = "xl_numfmts"
		    lnNdx = Ascan(.LastNumFmtId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastNumFmtId[lnNdx, 2] = .LastNumFmtId[lnNdx, 2] + 1
		      lnNextId = .LastNumFmtId[lnNdx, 2]
		    Else
		      lnNdx = Max(1, Alen(.LastNumFmtId, 1) + 1)
		      Dimension .LastNumFmtId[lnNdx, 2]
		      .LastNumFmtId[lnNdx, 1] = tnWB
		      .LastNumFmtId[lnNdx, 2] = START_NUMERIC_FORMAT_ID
		      lnNextId = START_NUMERIC_FORMAT_ID
		    Endif
		
		  Case tcCursor = "xl_relationships"
		    lnNdx = Ascan(.LastRelationId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastRelationId[lnNdx, 2] = .LastRelationId[lnNdx, 2] + 1
		      lnNextId = .LastRelationId[lnNdx, 2]
		    Else
		      lnNdx = Max(1, Alen(.LastRelationId, 1) + 1)
		      Dimension .LastRelationId[lnNdx, 2]
		      .LastRelationId[lnNdx, 1] = tnWB
		      .LastRelationId[lnNdx, 2] = 1
		      lnNextId = 1
		    Endif
		
		  Case tcCursor = "xl_sheets"
		    lnNdx = Ascan(.LastSheetId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastSheetId[lnNdx, 2] = .LastSheetId[lnNdx, 2] + 1
		      lnNextId = .LastSheetId[lnNdx, 2]
		    Else
		      lnNdx = Max(1, Alen(.LastSheetId, 1) + 1)
		      Dimension .LastSheetId[lnNdx, 2]
		      .LastSheetId[lnNdx, 1] = tnWB
		      .LastSheetId[lnNdx, 2] = 1
		      lnNextId = 1
		    Endif
		
		  Case tcCursor = "xl_strings"
		    lnNdx = Ascan(.LastStringId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastStringId[lnNdx, 2] = .LastStringId[lnNdx, 2] + 1
		      lnNextId = .LastStringId[lnNdx, 2]
		    Else
		      lnNdx = Max(1, Alen(.LastStringId, 1) + 1)
		      Dimension .LastStringId[lnNdx, 2]
		      .LastStringId[lnNdx, 1] = tnWB
		      .LastStringId[lnNdx, 2] = 0
		      lnNextId = 0
		    Endif
		
		  Otherwise
		    lnNextId = 0
		  Endcase
		Endwith
		Return lnNextId
		
	ENDPROC

	PROTECTED PROCEDURE getnodeattributevalue		&& Returns the attribute value
		Lparameters tcXf, tcAttrName
		Return Strextract(tcXf, tcAttrName+'="', '"', 1)
		
	ENDPROC

	PROTECTED PROCEDURE getnodecount		&& Returns the number of nodes to be processed
		Lparameters tcNode, tcElement
		Local lnCount
		lnCount = Occurs("<"+tcElement+">", tcNode)
		If lnCount = 0
		  lnCount = Occurs("<"+tcElement+" ", tcNode)
		  If lnCount = 0
		    lnCount = Occurs("<"+tcElement, tcNode)
		  Endif
		Endif
		Return lnCount
		
	ENDPROC

	PROTECTED PROCEDURE getnodeelement		&& Gets the string content for the node element
		Lparameters tcNode, tcElement, tnNode, tlStrict, tnFlag
		Local lcContent, lnNdx, loException
		Do Case
		Case Pcount() = 3
		  tlStrict = False
		  tnFlag   = 5
		
		Case Pcount() = 4
		  tnFlag = 5
		Endcase
		If tlStrict
		  lcContent = Strextract(tcNode, "<"+tcElement+">", "</"+tcElement+">", tnNode, tnFlag)
		Else
		  lcContent = Strextract(tcNode, "<"+tcElement+" ", ">", tnNode, tnFlag)
		  If Right(lcContent, 2) != "/>"
		    lcContent = Strextract(tcNode, "<"+tcElement+" ", "</"+tcElement+">", tnNode, tnFlag)
		    If Empty(lcContent)
		      lcContent = Strextract(tcNode, "<"+tcElement+">", "</"+tcElement+">", tnNode, tnFlag)
		    Endif
		    If Empty(lcContent)
		      lcContent = Strextract(tcNode, "<"+tcElement, "/>", tnNode, tnFlag)
		    Endif
		  Endif
		Endif
		Return lcContent
		
	ENDPROC

	PROTECTED PROCEDURE getnodeelementvalue		&& Gets the value assigned to the node element
		Lparameters tcElement
		Return Strextract(tcElement, '>', '<', 1, 1)
		
	ENDPROC

	PROCEDURE getnumberofsheets		&& Returns the number of sheets for the given workbook
		Lparameters tnWB
		Local lnCount
		Select xl_sheets
		Count For xl_sheets.workbook = tnWB And !xl_sheets.shdeleted To lnCount
		Return lnCount
		
	ENDPROC

	PROCEDURE getpapersize		&& Gets the paper size for the selected sheet
		Lparameters tnWB, tnSheet
		Return Iif(Pcount() = 2 And This.GetSheetRecord(tnWB, tnSheet), xl_sheets.Papersize, -1)
		
	ENDPROC

	PROCEDURE getprintorientation		&& Gets the print orientation for the sheet output
		Lparameters tnWB, tnSheet
		Return Iif(Pcount() = 2 And This.GetSheetRecord(tnWB, tnSheet), xl_sheets.prnorient, 0)
		
	ENDPROC

	PROTECTED PROCEDURE getrelationshipfilename		&& Gets the file name for the R:Id value in the relationships XML
		Lparameters tnWB, tnShRId
		Return Iif(Seek(BinToC(tnWB)+BinToC(tnShRId), "xl_relationships", "relid"), Alltrim(xl_relationships.Target), '')
		
	ENDPROC

	PROCEDURE getrgbvalues		&& Gets the specified RGB color value
		Lparameters tnColorValue, tcRGB
		Local lnValue, lnNdx
		If Pcount() < 2
		  Return -1
		Endif
		Do Case
		Case tcRGB = "R"
		  lnValue = tnColorValue
		  For lnNdx=8 To 31
		    lnValue = Bitclear(lnValue, lnNdx)
		  Endfor
		
		Case tcRGB = "G"
		  lnValue = Bitrshift(tnColorValue, 8)
		  For lnNdx=8 To 31
		    lnValue = Bitclear(lnValue, lnNdx)
		  Endfor
		
		Case tcRGB = "B"
		  lnValue = Bitrshift(tnColorValue, 16)
		  For lnNdx=8 To 31
		    lnValue = Bitclear(lnValue, lnNdx)
		  Endfor
		
		Otherwise
		  Return -1
		Endcase
		Return Int(lnValue)
		
	ENDPROC

	PROTECTED PROCEDURE getrowheightkeyexpr		&& Gets the key expression for the c_rowheights
		Lparameters tnWB, tnSheet, tnRow
		Return BinToC(tnWB)+BinToC(tnSheet)+BinToC(tnRow)
		
	ENDPROC

	PROTECTED PROCEDURE getrowincolrowpair		&& REturns the row (integer value) in a ColRow pair; i.e., return 6 from A6 reference
		Lparameters tcColRow
		Local lcRow, lnNdx, lcChr
		lcRow = ""
		For lnNdx=1 To Len(tcColRow)
		  lcChr = Substr(tcColRow, lnNdx, 1)
		  If Isdigit(lcChr)
		    lcRow = lcRow + lcChr
		  Endif
		Endfor
		Return Int(Val(lcRow))
		
	ENDPROC

	PROCEDURE getrowmaxcolumn		&& Returns the selected row maximum column
		Lparameters tnWB, tnSheet, tnCellRow
		Return Iif(Seek(BinToC(tnWB)+BinToC(tnSheet)+BinToC(tnCellRow), "xl_rows", "id"), xl_rows.maxcol, 0)
		
	ENDPROC

	PROTECTED PROCEDURE getsharedstringid		&& Gets the Shared Strings Id value for the cell text
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local loSharedString
		loSharedString = Null
		If Pcount() < 4
		  Return loSharedString
		Endif
		If This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) And This.GetCursorRecord("xl_strings", tnWB, xl_cells.stringid)
		  loSharedString = Createobject("Empty")
		  AddProperty(loSharedString, "StringId", xl_cells.stringid)
		  AddProperty(loSharedString, "StringValue", xl_strings.stringval)
		Endif
		Return loSharedString
		
	ENDPROC

	PROCEDURE getsheetname		&& Gets the sheet name
		Lparameters tnWB, tnSheet
		Return Iif(Pcount() = 2 And This.GetSheetRecord(tnWB, tnSheet), Alltrim(xl_sheets.shname), '')
		
	ENDPROC

	PROTECTED PROCEDURE getsheetrecord		&& Positions the record in xl_sheets; returns true if record found, or false if not found
		Lparameters tnWB, tnSheet
		Return Seek(BinToC(tnWB)+BinToC(tnSheet), "xl_sheets", "sheetndx")
		
	ENDPROC

	PROCEDURE getsheetrowvalues		&& Returns the cell values for the given row
		Lparameters tnWB, tnSheet, tnCellRow
		Local lnMaxCol, loRow
		If Pcount() < 3
		  Return Null
		Endif
		lnMaxCol = This.GetMaxColumnNumber(tnWB, tnSheet)
		With This
		  If !Isnull(lnMaxCol) And lnMaxCol > 0
		    loRow = Createobject("Empty")
		    AddProperty(loRow, "Values[lnMaxCol, 2]", "")
		    AddProperty(loRow, "Count", lnMaxCol)
		    loRow.Values = Null
		    Select tmp.cellcol From xl_cells As tmp ;
		      WHERE workbook = tnWB ;
		      AND tmp.Sheet = tnSheet ;
		      AND tmp.cellrow = tnCellRow ;
		      AND tmp.celldeleted = False ;
		      INTO Cursor t_temp
		
		    Select t_temp
		    Scan
		      loRow.Values[t_temp.cellcol, 1] = .GetCellValue(tnWB, tnSheet, tnCellRow, t_temp.cellcol)
		      loRow.Values[t_temp.cellcol, 2] = .GetCellDataType(tnWB, tnSheet, tnCellRow, t_temp.cellcol)
		    Endscan
		    Use In t_temp
		  Else
		    loRow = Null
		  Endif
		Endwith
		Return loRow
		
	ENDPROC

	PROCEDURE getsheetscale		&& Gets the sheet printing scale
		Lparameters tnWB, tnSheet
		Return Iif(Pcount() = 2 And This.GetSheetRecord(tnWB, tnSheet), xl_sheets.Scale, -1)
		
	ENDPROC

	PROTECTED PROCEDURE getstringrecord		&& Positions the record pointer to the selected string record
		Lparameters tnWB, tcString
		Return Seek(BinToC(tnWB)+This.GetCheckSum(tcString), "xl_strings", "stringndx")
		
	ENDPROC

	PROTECTED PROCEDURE getstringxml		&& Returns a converted string from XML to text
		Lparameters tcString
		Local lcString, lcOldChr, lcChr, lnChr, lnNdx
		If Left(tcString, 1) != " " And Empty(tcString)
		  Return ""
		Endif
		Try
		  If Isnull(This.oXDOM)
		    lcString = Strtran(tcString, '&amp;', Chr(38))
		    lcString = Strtran(lcString, '&gt;', '>')
		    lcString = Strtran(lcString, '&lt;', '<')
		    lcString = Strtran(lcString, '&quot;', '"')
		    lnNdx = 1
		    Do While Atc("&#", lcString, lnNdx) > 0
		      lcOldChr = Strextract(lcString, "&#", ";", lnNdx)
		      lnChr    = Int(Val(lcOldChr))
		      If lnChr < 256
		        lcChr    = Chr(lnChr)
		        lcOldChr = "&#" + lcOldChr + ";"
		        lcString = Strtran(lcString, lcOldChr, lcChr)
		      Else
		        lnNdx = lnNdx + 1            && Increment to skip this embedded value
		      Endif
		    Enddo
		  Else
		    This.oXDOM.LoadXML("<value>" + tcString + "</value>")
		    lcString = This.oXDOM.Text
		  Endif
		
		Catch To loException
		  Set Step On
		Endtry
		Return lcString
		
	ENDPROC

	PROCEDURE getvalidation		&& Returns the validation definition
		Lparameters tnValidNdx
		Local loValiation
		loValiation = Createobject("Empty")
		AddProperty(loValiation, "Type", 0)
		AddProperty(loValiation, "Style", 0)
		AddProperty(loValiation, "Operator", 0)
		AddProperty(loValiation, "AllowBlank", False)
		AddProperty(loValiation, "ShowInputMsg", False)
		AddProperty(loValiation, "ShowErrMsg", False)
		AddProperty(loValiation, "ErrMsg", "")
		AddProperty(loValiation, "ErrTitle", "")
		AddProperty(loValiation, "Prompt", "")
		AddProperty(loValiation, "Formula1", "")
		AddProperty(loValiation, "Formula2", "")
		If Pcount() < 1
		  Return loValiation
		Endif
		If Seek(BinToC(tnValidNdx), "xl_validation", "validndx")
		  loValiation.Type         = xl_validation.vtype
		  loValiation.Style        = xl_validation.vstyle
		  loValiation.Operator     = xl_validation.voperator
		  loValiation.AllowBlank   = xl_validation.AllowBlank
		  loValiation.ShowInputMsg = xl_validation.showinpmsg
		  loValiation.ShowErrMsg   = xl_validation.ShowErrMsg
		  loValiation.ErrMsg       = xl_validation.ErrMsg
		  loValiation.ErrTitle     = xl_validation.ErrTitle
		  loValiation.Prompt       = xl_validation.vprompt
		  loValiation.Formula1     = Iif(xl_validation.formula, "=", "") + Alltrim(xl_validation.Formula1)
		  loValiation.Formula2     = Iif(Empty(xl_validation.Formula2), "", Iif(xl_validation.formula, "=", "") + Alltrim(xl_validation.Formula2))
		Endif
		Return loValiation
		
	ENDPROC

	PROCEDURE getvalidationlist		&& Returns a list of validations for the workbook/sheet
		Lparameters tnWB, tnSheet
		Local loValiation, lcAlias
		lcAlias = Alias()
		loValiation = Createobject("Empty")
		AddProperty(loValiation, "List[1]")
		AddProperty(loValiation, "Count", 0)
		Select xl_validation
		Scan For BinToC(workbook)+BinToC(Sheet)
		  loValiation.Count = loValiation.Count + 1
		  Dimension loValiation.List[loValiation.Count, 2]
		  loValiation.List[loValiation.Count, 1] = xl_validation.vtype
		  loValiation.List[loValiation.Count, 2] = xl_validation.validndx
		Endscan
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return loValiation
		
	ENDPROC

	PROCEDURE getworkbook		&& Gets the workbook Id from the name
		Lparameters tcName
		Return Iif(Seek(Padr(Upper(Juststem(tcName)), 200, "_"), "xl_workbooks", "wbname"), xl_workbooks.workbook, 0)
		
	ENDPROC

	PROCEDURE getworkbookfilename		&& Gets the file name for the workbook index
		Lparameters tnWB
		Return Iif(Seek(BinToC(tnWB), "xl_workbooks", "workbook"), ;
		  FORCEEXT(Addbs(Alltrim(xl_workbooks.filepath)) + Alltrim(xl_workbooks.wbname), "xlsx"), '')
		
	ENDPROC

	PROCEDURE getworkbooksheets		&& Returns the workbook sheets
		Lparameters tnWB
		Local loSheets
		loSheets = Createobject("Empty")
		AddProperty(loSheets, "List[1, 2]")
		AddProperty(loSheets, "Count", 0)
		Select xl_sheets
		Set Order To Tag Sheet
		*TODO: заменить на copy fields Sheet, shname to array loSheets.List
		*TODO: loSheets.Count = RecCount()
		Scan For workbook = tnWB And !shdeleted
		  loSheets.Count = loSheets.Count + 1
		  Dimension loSheets.List[loSheets.Count, 2]
		  loSheets.List[loSheets.Count, 1] = xl_sheets.Sheet
		  loSheets.List[loSheets.Count, 2] = Alltrim(xl_sheets.shname)
		Endscan
		Set Order To
		Return loSheets
		
	ENDPROC

	PROTECTED PROCEDURE getxmlheaderfootertext		&& Returns a XML formatted string for the header and footer text
		Local lcText
		*TODO: заменить на textmerge
		If Empty(xl_hdrfootertext.FontName)
		  lcText = '"-,'
		Else
		  lcText = '"' + Alltrim(xl_hdrfootertext.FontName) + ','
		Endif
		Do Case
		Case xl_hdrfootertext.fontstyle = HEADERFOOTER_FONT_STYLE_BOLD
		  lcText = lcText + 'Bold"'
		
		Case xl_hdrfootertext.fontstyle = HEADERFOOTER_FONT_STYLE_ITALIC
		  lcText = lcText + 'Italic"'
		
		Case xl_hdrfootertext.fontstyle = HEADERFOOTER_FONT_STYLE_BOLDITALIC
		  lcText = lcText + 'Bold Italic"'
		
		Otherwise
		  lcText = lcText + 'Regular"'
		Endcase
		If xl_hdrfootertext.FontSize > 0
		  lcText = lcText + '&amp;' + Transform(xl_hdrfootertext.FontSize)
		Endif
		If xl_hdrfootertext.fontcolor > 0
		  lcText = lcText + '&amp;K' + This.ConvertColorToHex(xl_hdrfootertext.fontcolor)
		Endif
		lcText = lcText + Alltrim(xl_hdrfootertext.Text)
		Return lcText
		
	ENDPROC

	PROTECTED PROCEDURE getxmlstring		&& Gets the string as an XML formatted string
		Lparameters tcString
		Local lcString, lcXMLString, lnNdx, lcChar, lcInvalidChars, loNodeText
		If Left(tcString, 1) != " " And Empty(tcString)
		  Return ""
		Endif
		*-*	TJF 2016-12-12 Strip out invalid XML characters (ASCII 0 to 31 except 9 (TAB), 10 (LF), and 13 (CR))
		lcInvalidChars = Chr(0) + Chr(1) + Chr(2) + Chr(3) + Chr(4) + Chr(5) + Chr(6) + Chr(7) + Chr(8) + Chr(11) + Chr(12) + ;
		  CHR(14) + Chr(15) + Chr(16) + Chr(17) + Chr(18) + Chr(19) + Chr(20) + Chr(21) + Chr(22) + Chr(23) + ;
		  CHR(24) + Chr(25) + Chr(26) + Chr(27) + Chr(28) + Chr(29) + Chr(30) + Chr(31)
		lcString = Chrtran(tcString, lcInvalidChars, "")
		If Isnull(This.oXDOM)
		  lcString = Strtran(lcString, Chr(38), '&amp;')
		  lcString = Strtran(lcString, '>', '&gt;')
		  lcString = Strtran(lcString, '<', '&lt;')
		  lcString = Strtran(lcString, '"', '&quot;')
		
		  If This.Codepage = 0
		    lcXMLString = ""
		    For lnNdx=1 To Len(lcString)
		      lcChar = Substr(lcString, lnNdx, 1)
		      lnChar = Asc(lcChar)
		      lcXMLString = lcXMLString + Iif(lnChar < 128, lcChar, "&#" + Transform(lnChar) + ";")
		    Endfor
		  Else
		    lcXMLString = lcString
		  Endif
		Else
		  loNodeText = This.oXDOM.createTextNode(lcString)
		  lcXMLString = loNodeText.XML
		  lcXMLString = Strtran(lcXMLString, '"', '&quot;')
		Endif
		Return lcXMLString
		
	ENDPROC

	PROTECTED PROCEDURE Init
		Lparameters tnCodePage
		Local loException, lnSelect
		With This
		  If Pcount() > 0 And Vartype(tnCodePage) = "N"
		    .Codepage = tnCodePage
		  Endif
		  lnSelect = Select()
		  .CreateWorkingCursors()
		  If .DeclareWinAPI
		    .DeclareDLL()
		  Endif
		  Try
		    .oXDOM = Createobject('MSXML2.DOMDocument')
		  Catch To loException
		    .oXDOM = Null
		  Endtry
		  .InitalizeIdValues()
		  .OnInit()
		  Select (lnSelect)
		Endwith
		
	ENDPROC

	PROTECTED PROCEDURE initalizeidvalues		&& Initializes the internal Id values
		With This
		  Dimension .LastBorderId[1, 2]
		  .LastBorderId[1, 1] = 0                                          && Workbook Id
		  .LastBorderId[1, 2] = 0                                          && Last Border Id
		
		  Dimension .LastCellXfsId[1, 2]
		  .LastCellXfsId[1, 1] = 0                                         && Workbook Id
		  .LastCellXfsId[1, 2] = 0                                         && Last CellXfs Id
		
		  Dimension .LastFillId[1, 2]
		  .LastFillId[1, 1] = 0                                            && Workbook Id
		  .LastFillId[1, 2] = 0                                            && Last Fill Id
		
		  Dimension .LastFontId[1, 2]
		  .LastFontId[1, 1] = 0                                            && Workbook Id
		  .LastFontId[1, 2] = 0                                            && Last Font Id
		
		  Dimension .LastIndexColorId[1, 2]
		  .LastIndexColorId[1, 1] = 0                                      && Workbook Id
		  .LastIndexColorId[1, 2] = 0                                      && Last IndexColor Id
		
		  Dimension .LastMruColorId[1, 2]
		  .LastMruColorId[1, 1] = 0                                        && Workbook Id
		  .LastMruColorId[1, 2] = 0                                        && Last mruColor Id
		
		  Dimension .LastNumFmtId[1, 2]
		  .LastNumFmtId[1, 1] = 0                                          && Workbook Id
		  .LastNumFmtId[1, 2] = 0                                          && Last NumFmt Id
		
		  Dimension .LastRelationId[1, 2]
		  .LastRelationId[1, 1] = 0                                        && Workbook Id
		  .LastRelationId[1, 2] = 0                                        && Last Relationship Id
		
		  Dimension .LastSheetId[1, 2]
		  .LastSheetId[1, 1] = 0                                           && Workbook Id
		  .LastSheetId[1, 2] = 0                                           && Last Sheet Id
		
		  Dimension .LastStringId[1, 2]
		  .LastStringId[1, 1] = 0                                          && Workbook Id
		  .LastStringId[1, 2] = 0                                          && Last String Id
		Endwith
		*TODO: заменить на store 0 to .LastBorderId, .LastCellXfsId, .LastFillId, .LastFontId, .LastIndexColorId, .LastMruColorId,;
		 .LastNumFmtId, .LastRelationId, .LastSheetId, .LastStringId
	ENDPROC

	PROCEDURE insertcell		&& Inserts a new cell into the sheet
		Lparameters tnWB, tnSheet, tnRow, tnCol, tnShift
		Local llReturn, lnRow
		If Pcount() < 5
		  Return False
		Endif
		With This
		  If .GetSheetRecord(tnWB, tnSheet)
		    Select xl_cells
		    Set Order To Tag reverse
		    Do Case
		    Case tnShift = INSERT_LEFT
		      Scan For workbook = tnWB And Sheet = tnSheet And cellcol >= tnCol And cellrow = tnRow
		        Replace xl_cells.cellcol With xl_cells.cellcol + 1 In xl_cells
		        .SetRowMaxColumn(tnWB, tnSheet, xl_cells.cellrow, xl_cells.cellcol)
		      Endscan
		      llReturn = True
		
		    Case tnShift = INSERT_RIGHT
		      Scan For workbook = tnWB And Sheet = tnSheet And cellcol > tnCol And cellrow = tnRow
		        Replace xl_cells.cellcol With xl_cells.cellcol + 1 In xl_cells
		        .SetRowMaxColumn(tnWB, tnSheet, xl_cells.cellrow, xl_cells.cellcol)
		      Endscan
		      llReturn = True
		
		    Case tnShift = INSERT_BEFORE
		      Scan For workbook = tnWB And Sheet = tnSheet And cellrow >= tnRow And cellcol = tnCol
		        Replace xl_cells.cellrow With xl_cells.cellrow + 1 In xl_cells
		        .SetRowMaxColumn(tnWB, tnSheet, xl_cells.cellrow, xl_cells.cellcol)
		      Endscan
		      llReturn = True
		
		    Case tnShift = INSERT_AFTER
		      Scan For workbook = tnWB And Sheet = tnSheet And cellrow > tnRow And cellcol = tnCol
		        Replace xl_cells.cellrow With xl_cells.cellrow + 1 In xl_cells
		        .SetRowMaxColumn(tnWB, tnSheet, xl_cells.cellrow, xl_cells.cellcol)
		      Endscan
		      llReturn = True
		
		    Otherwise
		      llReturn = False
		    Endcase
		    Set Order To
		  Else
		    llReturn = False
		  Endif
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE insertcolumn		&& Inserts a new column into the sheet
		Lparameters tnWB, tnSheet, tnCol, tnShift
		Local llReturn
		If Pcount() < 4
		  Return False
		Endif
		If This.GetSheetRecord(tnWB, tnSheet)
		  Select xl_cells
		  Set Order To Tag reverse
		  Do Case
		  Case tnShift = INSERT_LEFT
		    Scan For workbook = tnWB And Sheet = tnSheet And cellcol >= tnCol
		      Replace xl_cells.cellcol With xl_cells.cellcol + 1 In xl_cells
		      If Seek(BinToC(tnWB)+BinToC(tnSheet)+BinToC(xl_cells.cellrow), "xl_rows", "id") And xl_cells.cellcol > xl_rows.maxcol
		        Replace xl_rows.maxcol With xl_cells.cellcol In xl_rows
		      Endif
		    Endscan
		    llReturn = True
		
		  Case tnShift = INSERT_RIGHT
		    Scan For workbook = tnWB And Sheet = tnSheet And cellcol > tnCol
		      Replace xl_cells.cellcol With xl_cells.cellcol + 1 In xl_cells
		      If Seek(BinToC(tnWB)+BinToC(tnSheet)+BinToC(xl_cells.cellrow), "xl_rows", "id") And xl_cells.cellcol > xl_rows.maxcol
		        Replace xl_rows.maxcol With xl_cells.cellcol In xl_rows
		      Endif
		    Endscan
		    llReturn = True
		
		  Otherwise
		    llReturn = False
		  Endcase
		  Set Order To
		Else
		  llReturn = False
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE insertrow		&& Inserts a new row into the sheet
		Lparameters tnWB, tnSheet, tnRow, tnShift
		Local llReturn, lnRow
		If Pcount() < 4
		  Return False
		Endif
		If This.GetSheetRecord(tnWB, tnSheet)
		  Select xl_cells
		  Set Order To Tag reverse
		  Do Case
		  Case tnShift = INSERT_BEFORE
		    Scan For workbook = tnWB And Sheet = tnSheet And cellrow >= tnRow
		      lnRow = xl_cells.cellrow
		      Replace xl_cells.cellrow With lnRow + 1 In xl_cells
		      If Seek(BinToC(tnWB)+BinToC(tnSheet)+BinToC(lnRow), "xl_rows", "id")
		        Replace xl_rows.Row With xl_cells.cellrow In xl_rows
		      Endif
		    Endscan
		    llReturn = True
		
		  Case tnShift = INSERT_AFTER
		    Scan For workbook = tnWB And Sheet = tnSheet And cellrow > tnRow
		      lnRow = xl_cells.cellrow
		      Replace xl_cells.cellrow With lnRow + 1 In xl_cells
		      If Seek(BinToC(tnWB)+BinToC(tnSheet)+BinToC(lnRow), "xl_rows", "id")
		        Replace xl_rows.Row With xl_cells.cellrow In xl_rows
		      Endif
		    Endscan
		    llReturn = True
		
		  Otherwise
		    llReturn =  False
		  Endcase
		  Set Order To
		Else
		  llReturn = False
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE iscellformula		&& Returns True if cell contains a formula
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		Local llFormula
		If Pcount() < 4
		  Return Null
		Endif
		llFormula = False
		If This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		  llFormula = !Empty(xl_cells.cellformula)
		Endif
		Return llFormula
		
	ENDPROC

	PROTECTED PROCEDURE iscellreferenceinvalid		&& Checks if the cell reference is invalid (outside of limits)
		Lparameters tnRow, tnCol
		Return tnRow > LIMITS_MAX_ROWS Or tnCol > LIMITS_MAX_COLUMNS
		
	ENDPROC

	PROCEDURE isformatstyledefined		&& Determines if the format is defined as a style
		Lparameters tnWB, tcFName, tnFSize, tlBold, tlItalic, tnFColor, tcULine, tlStrikThr, tcVPos
		Do Case
		Case Pcount() < 3
		  Return Null
		
		Case Pcount() = 3
		  tlBold     = False
		  tlItalic   = False
		  tnFColor   = Rgb(0, 0, 0)
		  tcULine    = UNDERLINE_NONE
		  tlStrikThr = False
		  tcVPos     = FONT_VERTICAL_BASELINE
		
		Case Pcount() = 4
		  tlItalic   = False
		  tnFColor   = Rgb(0, 0, 0)
		  tcULine    = UNDERLINE_NONE
		  tlStrikThr = False
		  tcVPos     = FONT_VERTICAL_BASELINE
		
		Case Pcount() = 5
		  tnFColor   = Rgb(0, 0, 0)
		  tcULine    = UNDERLINE_NONE
		  tlStrikThr = False
		  tcVPos     = FONT_VERTICAL_BASELINE
		
		Case Pcount() = 6
		  tcULine    = UNDERLINE_NONE
		  tlStrikThr = False
		  tcVPos     = FONT_VERTICAL_BASELINE
		
		Case Pcount() = 7
		  tlStrikThr = False
		  tcVPos     = FONT_VERTICAL_BASELINE
		
		Case Pcount() = 8
		  tcVPos     = FONT_VERTICAL_BASELINE
		Endcase
		
		If Seek(BinToC(tnWB)+Padr(tcFName, 100) + Str(tnFSize, 5, 1) + Transform(tlBold) + Transform(tlItalic) + Padl(tnFColor, 15) + Padr(tcULine, 16) + ;
		    TRANSFORM(tlStrikThr) + Padr(tcVPos, 11), "xl_fonts", "cellformat")
		
		  If Seek(BinToC(tnWB)+BinToC(xl_fonts.Id)+BinToC(0)+BinToC(0)+BinToC(0)+BinToC(0)+BinToC(0), "xl_cellxfs", "cellformat")
		    Return xl_cellxfs.Id
		  Else
		    Return Null
		  Endif
		Else
		  Return Null
		Endif
		
	ENDPROC

	PROTECTED PROCEDURE isvalidborderstyle		&& Validates the border style value
		Lparameters tcStyle
		If Vartype(tcStyle) != 'C' Or Empty(tcStyle) Or !Inlist(tcStyle, BORDER_STYLE_THIN, BORDER_STYLE_HAIR, BORDER_STYLE_DOTTED, BORDER_STYLE_DASHDOTDOT, ;
		    BORDER_STYLE_DASHDOT, BORDER_STYLE_DASHED, BORDER_STYLE_THIN, BORDER_STYLE_MEDIUMDASHDOTDOT, ;
		    BORDER_STYLE_SLANTDASHDOT, BORDER_STYLE_MEDIUMDASHDOT, BORDER_STYLE_MEDIUMDASHED, ;
		    BORDER_STYLE_MEDIUM, BORDER_STYLE_THICK, BORDER_STYLE_DOUBLE)
		  Return False
		Endif
		Return True
		
	ENDPROC

	PROCEDURE mergecells		&& Merges cells together
		Lparameters tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol
		Local lnRow, lnCol, lcCellValue, lnStringIndex, lcDataType, lcCellFormula, llReturn
		If Pcount() < 6
		  Return False
		Endif
		If This.GetSheetRecord(tnWB, tnSheet)
		  If Seek(BinToC(tnWB)+BinToC(tnSheet)+BinToC(tnBegRow)+BinToC(tnBegCol), "xl_mergecells", "mergecell")
		    Replace xl_mergecells.endrow With tnEndRow, ;
		      xl_mergecells.endcol With tnEndCol In xl_mergecells
		  Else
		*-*		Check if a cell being merged is already in a merge group
		    Select xl_mergecells
		    Locate For workbook = tnWB And Sheet = tnSheet And Between(tnBegRow, begrow, endrow) And Between(tnBegCol, begcol, endcol) And !Deleted()
		    If Found()
		      llReturn = False
		    Else
		      Locate For workbook = tnWB And Sheet = tnSheet And Between(tnEndRow, begrow, endrow) And Between(tnEndCol, begcol, endcol) And !Deleted()
		      If Found()
		        llReturn = False
		      Else
		*-*				Add merged cells
		        Insert Into xl_mergecells (workbook, Sheet, begrow, begcol, endrow, endcol) ;
		          VALUES (tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol)
		*-*				Get upper left most cell value -> will be value of the merged cells (clear all other cell values)
		        Select xl_cells
		        lcCellValue = Null
		        For lnRow=tnBegRow To tnEndRow
		          For lnCol=tnBegCol To tnEndCol
		            If This.GetCellRecord(tnWB, tnSheet, lnRow, lnCol) And !Empty(xl_cells.cellvalue)
		              If Isnull(lcCellValue) And !xl_cells.celldeleted
		                lcDataType    = xl_cells.DataType
		                lcCellValue   = xl_cells.cellvalue
		                lcCellFormula = xl_cells.cellformula
		                lnStringIndex = xl_cells.stringid
		              Endif
		              Replace xl_cells.cellvalue   With "", ;
		                xl_cells.cellformula With "", ;
		                xl_cells.stringid    With 0, ;
		                xl_cells.DataType    With "" In xl_cells
		            Endif
		          Endfor
		        Endfor
		        If !Isnull(lcCellValue)
		          If This.GetCellRecord(tnWB, tnSheet, tnBegRow, tnBegCol)
		            Replace xl_cells.cellvalue   With lcCellValue, ;
		              xl_cells.cellformula With lcCellFormula, ;
		              xl_cells.stringid    With lnStringIndex, ;
		              xl_cells.DataType    With lcDataType, ;
		              xl_cells.celldeleted With False In xl_cells
		          Endif
		        Endif
		*-*				If the tnEndCol cell is not a cell already in the row then add the cell to the cursor for the max cells by row determination
		*				SELECT xl_cells
		*				FOR lnRow=tnBegRow TO tnEndRow
		*					LOCATE FOR workbook = tnWB AND sheet = tnSheet AND cellrow = lnRow AND cellcol >= tnEndCol AND !DELETED()
		*					IF !FOUND()
		*						INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, numdec, celldeleted) ;
		*							VALUES (tnWB, tnSheet, lnRow, tnEndCol, DATA_TYPE_NONE, 0, -1, False)
		*					ENDIF
		*				ENDFOR
		        llReturn = True
		      Endif
		    Endif
		  Endif
		  For lnRow=tnBegRow To tnEndRow
		    This.SetRowMaxColumn(tnWB, tnSheet, lnRow, tnEndCol)
		  Endfor
		Else
		  llReturn = False
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE ondestroy		&& Called by the Destroy() event - user implementation
		*-*
		*-*	TODO: Add your code here
		*-*
	ENDPROC

	PROCEDURE oninit		&& User code for Init() Event
		*-*
		*-*	TODO: Add your code here
		*-*
	ENDPROC

	PROCEDURE onshowerrormessage		&& Event for displaying an error message to the user
		LPARAMETERS tnErrorId, tcErrMessage
		*-*
		*-*	TODO: Use BINDEVENTS to bind to this event and display a message to your users
		*-*
	ENDPROC

	PROCEDURE onshowstatusmessage		&& Event for displaying a wait message to the user
		LPARAMETERS tnMode, tnStage, tnTotStages
		*-*
		*-*	TODO: Use BINDEVENTS to bind to this event and display a message to your users
		*-*
		*-*	tnTotStages = total number of tnStages (only passed on first call)
		*-*
		*-*	tnMode = 1; opening an xlsx file
		*-* tnStage = 0; start of open
		*-* tnStage = 1; reading shared strings XML
		*-* tnStage = 2; reading styles XML
		*-* tnStage = 3; reading relationships XML
		*-* tnStage = 4; reading sheets XML
		*-* tnStage = 5; reading named ranges
		*-* tnStage = 6; reading external references
		*-* tnStage = -1; end of open
		*-*
		*-*	tnMode = 2; saving an xlsx file
		*-* tnStage = 0; start of save
		*-* tnStage = 1; indicates saving supporting XMLs
		*-* tnStage = 2; indicates saving strings XML
		*-* tnStage = 3; indicates saving styles XML
		*-* tnStage = 4; indicates saving workbook
		*-* tnStage = 5; indicates saving relationship XML
		*-* tnStage = 6+; indicates saving sheets
		*-* tnStage = -1; end of close
		*-*
		*-*	tnMode = 3; saving an xlsx file
		*-* tnStage = 0; start of write of data to cell values
		*-* tnStage = 1-n; indicates saving cell values
		*-* tnStage = -1; write of data
		*-*
	ENDPROC

	PROCEDURE opencreatedxlsxfile		&& Opens the XLSX file via Win32 API default program
		Lparameters txWB
		Local lcFileName
		Do Case
		Case Pcount() = 0
		  Return False
		
		Case Vartype(txWB) = "N"
		  lcFileName = This.GetWorkbookFileName(txWB)
		  If Empty(lcFileName) Or !File(lcFileName)
		    Return False
		  Endif
		
		Case Vartype(txWB) = "C"
		  If File(txWB)
		    lcFileName = txWB
		  Else
		    Return False
		  Endif
		
		Otherwise
		  Return False
		Endcase
		Try
		  apiShellExecute(0, "Open", lcFileName, "", "", 5)
		
		Catch To loException
		  Raiseevent(This, "OnShowErrorMessage", 99, "Failure to open file: " + loException.Message)
		Endtry
		
	ENDPROC

	PROCEDURE openxlsxworkbook		&& Opens the passed Xlsx workbook and loads the internal cursors with the content
		Lparameters tcFileName, tlForceTextFormat
		Local lnWB, lcBaseName, lcTempPath, lcZipName, loShell, lnCnt, lnCntTot, lcRelationsXml, lnNode
		Local lnRelId, lcRelType, lcTarget, lcWbXmlPath, lcRelation, lcWorkbook, lcSheet, lcShName, lnShRId, lcShFile
		Local loException, loFS, lcDefinedNames, lcDefinedName, lcRName, lcComment, lnRangeId, lcRange, lnNdx
		Local lnBegRow, lnBegCol, lnEndRow, lnEndCol, lcExternalRefs, lnExRId, lcExtRef, lcCellRange, lcBegRange
		Local lcEndRange, loDir, lnLastRelId, lcSheets, lcRelationships, lcShState
		Local Array laTemp[1]
		With This
		  Do Case
		  Case Pcount() = 0
		    .ErrorLevelId = 1
		    Raiseevent(This, "OnShowErrorMessage", 1, "Invalid call to OpenXlsxWorkbook() method; must include file name to open")
		
		  Case Pcount() = 1
		    tlForceTextFormat = False
		  Endcase
		  lnWB = 0
		  If Adir(laTemp, tcFileName) > 0
		*-*	Open the Workbook as an archive (zip) file and extract contents
		    Try
		      lcBaseName = Sys(2015)
		      lcTempPath = Addbs(Sys(2023)) + lcBaseName
		      lcZipName  = lcTempPath + ".zip"
		      Copy File (tcFileName) To (lcZipName)
		      loShell = Createobject("shell.application")
		      Mkdir (lcTempPath)
		      loShell.NameSpace(lcTempPath).CopyHere(loShell.NameSpace(lcZipName).Items, FOF_SILENT)
		      lnCnt = 0
		      lnCntTot = loShell.NameSpace(lcZipName).Items.Count
		      Do While loShell.NameSpace(lcTempPath).Items.Count != lnCntTot
		        lnCnt = lnCnt + 1
		        apiSleep(100)
		        If lnCnt > lnCntTot
		          Set Step On
		        Endif
		      Enddo
		      Erase (lcZipName)
		
		    Catch To loException
		      Set Step On
		      .ErrorLevelId = 2
		      Raiseevent(This, "OnShowErrorMessage", 2, loException.Message)
		      lnWB = Null
		    Endtry
		    If Isnull(lnWB)
		      Return 0
		    Endif
		*-*	Add to the workbook table
		    lnWB = .CreateWorkbookEx(tcFileName)
		    If lnWB > 0
		*-*		Verify all required XML files are present
		      lcWbXmlPath = Addbs(lcTempPath)
		      If Adir(laTemp, lcWbXmlPath + "xl\workbook.xml") = 0
		        .ErrorLevelId = 3
		        Raiseevent(This, "OnShowErrorMessage", 3, "Invalid XLSX file - missing workbook.xml")
		        .DeleteWorkbook(lnWB)
		        Return 0
		      Endif
		      If Adir(laTemp, lcWbXmlPath + "xl\_rels\workbook.xml.rels") = 0
		        .ErrorLevelId = 4
		        Raiseevent(This, "OnShowErrorMessage", 4, "Invalid XLSX file - missing workbook.xml.rels")
		        .DeleteWorkbook(lnWB)
		        Return 0
		      Endif
		      If Adir(laTemp, lcWbXmlPath + "xl\styles.xml") = 0
		        .ErrorLevelId = 5
		        Raiseevent(This, "OnShowErrorMessage", 5, "Invalid XLSX file - missing styles.xml")
		        .DeleteWorkbook(lnWB)
		        Return 0
		      Endif
		
		*-*		Process the workbook
		      Raiseevent(This, "OnShowStatusMessage", 1, 1, 6)
		      Try
		*-*			Get the shared strings if present
		        If Adir(laTemp, lcWbXmlPath + "xl\sharedStrings.xml") > 0
		          If !This.ReadSharedStringsXML(lcWbXmlPath, lnWB)
		            .ErrorLevelId = 7
		            Raiseevent(This, "OnShowErrorMessage", 7, "Invalid XLSX file - error during shared string loading")
		            Throw
		          Endif
		        Endif
		
		*-*			Get the cell formatting styles
		        .ReadStylesXML(lcWbXmlPath, lnWB)
		
		*-*			Get the defined relationship files for this workbook
		        Raiseevent(This, "OnShowStatusMessage", 1, 3)
		        lcRelationsXml = Filetostr(lcWbXmlPath + "xl\_rels\workbook.xml.rels")
		        lcRelationships = .GetNodeElement(lcRelationsXml, 'Relationships', 1, False, 1)
		
		        lnNode = 1
		        lnLastRelId = 0
		        lcRelation = .GetNodeElement(lcRelationships, 'Relationship', lnNode)
		        Do While !Empty(lcRelation)
		          lnRelId   = Cast(Substr(.GetNodeAttributeValue(lcRelation, "Id"), 4) As I)
		          lcTarget  = .GetNodeAttributeValue(lcRelation, "Target")
		          lcRelType = .GetNodeAttributeValue(lcRelation, "Type")
		          lcRelType = Substr(lcRelType, Ratc("/", lcRelType)+1)
		          If lcRelType != "theme"
		            Insert Into xl_relationships (workbook, relid, reltype, Target) Values (lnWB, lnRelId, lcRelType, lcTarget)
		
		            If lnRelId > lnLastRelId
		              lnLastRelId = lnRelId
		            Endif
		          Endif
		          lnNode = lnNode + 1
		          lcRelation = .GetNodeElement(lcRelationships, 'Relationship', lnNode)
		        Enddo
		        .SetLastId(lnWB, lnLastRelId, "xl_relationships")
		
		*-*			Get the sheets
		        Raiseevent(This, "OnShowStatusMessage", 1, 4)
		        lcWorkbook = Filetostr(lcWbXmlPath + "xl\workbook.xml")
		
		        lcSheets   = .GetNodeElement(lcWorkbook, 'sheets', 1, False, 1)
		        lnNode     = 1
		        lcSheet    = .GetNodeElement(lcSheets, 'sheet', lnNode)
		        Do While !Empty(lcSheet)
		          lcShName  = .GetNodeAttributeValue(lcSheet, "name")
		          lnShRId   = Cast(Substr(.GetNodeAttributeValue(lcSheet, "r:id"), 4) As I)
		          lcShFile  = lcWbXmlPath + "xl\" + .GetRelationshipFileName(lnWB, lnShRId)
		          lcShState = .GetNodeAttributeValue(lcSheet, "state")
		          Do Case
		          Case lcShState = "visible"
		            lnShState = VISIBLE_SHEET_STATE
		
		          Case lcShState = "hidden"
		            lnShState = HIDDEN_SHEET_STATE
		
		          Case lcShState = "veryHidden"
		            lnShState = VERYHIDDEN_SHEET_STATE
		
		          Otherwise
		            lnShState = VISIBLE_SHEET_STATE
		          Endcase
		
		          If Adir(laTemp, lcShFile) = 0 Or !.ReadSheetXML(lcShFile, lnWB, lnNode, lcShName, lnShState, tlForceTextFormat)
		            .ErrorLevelId = 8
		            Raiseevent(This, "OnShowErrorMessage", 8, "Invalid XLSX file - missing sheet or invalid sheet: " + lcShFile)
		            .DeleteWorkbook(lnWB)
		            Throw
		          Endif
		          If Seek(BinToC(lnWB)+BinToC(lnShRId), "xl_relationships", "relid")
		            Replace xl_relationships.Sheet With lnNode In xl_relationships
		          Else
		            Set Step On
		          Endif
		
		          lnNode = lnNode + 1
		          lcSheet = .GetNodeElement(lcSheets, 'sheet', lnNode)
		        Enddo
		        .SetLastId(lnWB, lnNode-1, "xl_sheets")
		
		*-*			Get the defined name ranges
		        Raiseevent(This, "OnShowStatusMessage", 1, 5)
		        lcDefinedNames = .GetNodeElement(lcWorkbook, 'definedNames', 1)
		        If !Empty(lcDefinedNames)
		          lnNode  = 1
		          lcDefinedName = .GetNodeElement(lcDefinedNames, 'definedName', lnNode)
		          Do While !Empty(lcDefinedName)
		            lcRange = .GetNodeElementValue(lcDefinedName)
		            If !Empty(lcRange)
		              lnNdx = Atc("!", lcRange)
		              lcShName = Left(lcRange, lnNdx-1)
		              If !Empty(lcShName)
		                lcShName = Chrtran(lcShName, "'", "")
		                If Seek(BinToC(lnWB)+Upper(Padr(lcShName, Len(xl_sheets.shname))), "xl_sheets", "shname")
		
		                  lcRName   = .GetNodeAttributeValue(lcDefinedName, "name")
		                  lcComment = .GetNodeAttributeValue(lcDefinedName, "comment")
		                  lnRangeId = Cast(.GetNodeAttributeValue(lcDefinedName, "localSheetId") As I)
		
		                  lcCellRange = Substr(lcRange, lnNdx+1)
		                  lcCellRange = Chrtran(lcCellRange, "$", "")
		                  lcBegRange  = Getwordnum(lcCellRange, 1, ":")
		                  lcEndRange  = Getwordnum(lcCellRange, 2, ":")
		
		                  lnNdx = .GetAlphaNumericSplit(lcBegRange)
		                  Do Case
		                  Case lnNdx = 0                  && Column only range
		                    lnBegCol = This.ColumnAsciiToIndex(lcBegRange)
		                    lnBegRow = 0
		
		                  Case lnNdx = 1                  && Row only range
		                    lnBegCol = 0
		                    lnBegRow = Cast(lcBegRange As I)
		
		                  Otherwise
		                    lnBegCol = .ColumnAsciiToIndex(Left(lcBegRange, lnNdx-1))
		                    lnBegRow = Cast(Substr(lcBegRange, lnNdx) As I)
		                  Endcase
		
		                  lnNdx = .GetAlphaNumericSplit(lcEndRange)
		                  Do Case
		                  Case lnNdx = 0                  && Column only range
		                    lnEndCol = .ColumnAsciiToIndex(lcEndRange)
		                    lnEndRow = 0
		
		                  Case lnNdx = 1                  && Row only range
		                    lnEndCol = 0
		                    lnEndRow = Cast(lcEndRange As I)
		
		                  Otherwise
		                    lnEndCol = .ColumnAsciiToIndex(Left(lcEndRange, lnNdx-1))
		                    lnEndRow = Cast(Substr(lcEndRange, lnNdx) As I)
		                  Endcase
		
		                  Insert Into xl_namerange (workbook, Sheet, rname, scope, Comment, begrow, begcol, endrow, endcol) ;
		                    VALUES (lnWB, xl_sheets.Sheet, lcRName, lnRangeId, lcComment, lnBegRow, lnBegCol, lnEndRow, lnEndCol)
		                Endif
		              Endif
		            Endif
		            lnNode = lnNode + 1
		            lcDefinedName = .GetNodeElement(lcDefinedNames, 'definedName', lnNode)
		          Enddo
		        Endif
		
		*-*			Get the external references
		        Raiseevent(This, "OnShowStatusMessage", 1, 6)
		*			lcExternalRefs = this.GetNodeElement(lcWorkbook, 'externalReferences', 1)
		*			IF !EMPTY(lcExternalRefs)
		*				lnNode   = 1
		*				lcExtRef = this.GetNodeElement(lcExternalRefs, 'externalReference', lnNode)
		*				DO WHILE !EMPTY(lcExtRef)
		*					lnExRId = CAST(SUBSTR(this.GetNodeAttributeValue(lcExtRef, "r:id"), 4) AS I)
		*					lcFile  = lcWbXmlPath + "xl\" + this.GetRelationshipFileName(lnWB, lnExRId)
		*					this.ReadExternalRefXML(lnWB, lcFile, lnExRId)
		*
		*					lnNode = lnNode + 1
		*					lcExtRef = this.GetNodeElement(lcExternalRefs, 'externalReference', lnNode)
		*				ENDDO
		*			ENDIF
		
		      Catch To loException
		        Set Step On
		        .ErrorLevelId = 9
		        Raiseevent(This, "OnShowErrorMessage", 9, "Invalid XLSX file - error reading data; " + loException.Message)
		        .DeleteWorkbook(lnWB)
		        lnWB = 0
		
		      Finally
		        Try
		          loFS = Createobject("Scripting.FileSystemObject")
		          loDir = loFS.GetFolder(lcTempPath)
		          loDir.Delete()
		
		        Catch To loException
		          Set Step On
		        Endtry
		        Raiseevent(This, "OnShowStatusMessage", 1, -1)
		      Endtry
		      If .Debug
		        .DebugCursorsToFile("Extract")
		      Endif
		    Endif
		  Endif
		Endwith
		Return lnWB
		
	ENDPROC

	PROCEDURE parsestring		&& Parses a string based on a specified delimiter
		Lparameters tcText, tnPos, tcDelimiter
		Local lcWord, lnCnt, lnBeg, lnEnd
		lnCnt = Occurs(tcDelimiter, tcText) + 1
		If tnPos <= lnCnt
		  Do Case
		  Case lnCnt = 0
		    lcWord = tcText
		
		  Case tnPos = 1
		    lcWord = Left(tcText, Atc(tcDelimiter, tcText)-1)
		
		  Case tnPos = lnCnt
		    lcWord = Substr(tcText, Ratc(tcDelimiter, tcText)+1)
		
		  Otherwise
		    lnBeg = Atc(tcDelimiter, tcText, tnPos-1) + 1
		    lnEnd = Atc(tcDelimiter, tcText, tnPos)
		    lcWord = Substr(tcText, lnBeg, lnEnd-lnBeg)
		  Endcase
		  Return lcWord
		Else
		  Return ""
		Endif
		
	ENDPROC

	PROTECTED PROCEDURE readcellvalueformat		&& Reads the cell value and format for a sheet
		Lparameters tnWB, tcColumn, tnCellCol
		Local lcCellType, lnNode, lcBaseName, lcFormatCode, lnNdx, loCellFormat, lcWholeNbr, lcDecNbr
		Local lcPosFormat, lcNegFormat, lcZerFormat, lcInLineTxt
		loCellFormat = Createobject("Empty")
		AddProperty(loCellFormat, "CellVal", "")
		AddProperty(loCellFormat, "DataType", DATA_TYPE_NONE)
		AddProperty(loCellFormat, "Formula", "")
		AddProperty(loCellFormat, "StringNdx", 0)
		AddProperty(loCellFormat, "CellXfsId", 0)
		
		With This
		  lcCellType = .GetNodeAttributeValue(tcColumn, "t")
		  For lnChild=1 To .GetChildNodeCount(tcColumn)
		    lcChild = .GetChildNodeElement(tcColumn, lnChild)
		    Do Case
		    Case lcChild = "<f"                                   && Formula attribute - cell contains a formula
		      lcCellType = "f"
		      loCellFormat.Formula = .GetCellFormulaFromXML(lcChild, tnCellCol)
		
		    Case lcChild = "<v"                                   && Value assigned to cell
		      loCellFormat.CellVal = .GetNodeElementValue(lcChild)
		
		    Case lcChild = "<is"                                  && Value assigned to cell as inline text
		      lcInLineTxt = .GetNodeElement(lcChild, 't', 1)
		      loCellFormat.CellVal = .GetNodeElementValue(lcInLineTxt)
		    Endcase
		  Endfor
		
		  loCellFormat.CellXfsId = Cast(.GetNodeAttributeValue(tcColumn, "s") As I)
		  Do Case
		  Case lcCellType == "f"
		    loCellFormat.DataType = DATA_TYPE_FORMULA
		
		  Case lcCellType == "s" Or lcCellType == "str"
		    loCellFormat.StringNdx = Cast(loCellFormat.CellVal As I)
		    loCellFormat.CellVal   = "StringValue"
		    loCellFormat.DataType  = DATA_TYPE_CHAR
		
		  Case lcCellType == "inlineStr"
		    loCellFormat.StringNdx = .AddStringValue(tnWB, loCellFormat.CellVal, False)
		    loCellFormat.CellVal   = "StringValue"
		    loCellFormat.DataType  = DATA_TYPE_CHAR
		
		  Case Empty(loCellFormat.CellVal)
		    Return loCellFormat
		
		  Otherwise
		*-*		Determine the data type of the value based on assigned format
		    If Seek(BinToC(tnWB)+BinToC(loCellFormat.CellXfsId), "xl_cellxfs", "id")
		      Do Case
		      Case Inlist(xl_cellxfs.numFmtId, 1, 3, 37, 38)                           && Integer format
		        loCellFormat.DataType = DATA_TYPE_INT
		
		      Case Inlist(xl_cellxfs.numFmtId, 2, 4, 7, 8, 11, 12, 13, 39, 40)         && Float format
		        loCellFormat.DataType = DATA_TYPE_FLOAT
		
		      Case Inlist(xl_cellxfs.numFmtId, 9, 10)                                  && Numeric percent format
		        loCellFormat.DataType = DATA_TYPE_FLOAT
		
		      Case Inlist(xl_cellxfs.numFmtId, 14, 15, 16, 17)                         && Date format
		        Do Case
		        Case Atc(".", loCellFormat.CellVal) = 0 Or Right(loCellFormat.CellVal, 1) = "."
		          loCellFormat.DataType = DATA_TYPE_DATE
		
		        Case Atc(".", loCellFormat.CellVal) > 0
		          lnNdx = Atc(".", loCellFormat.CellVal)
		          lcWholeNbr = Left(loCellFormat.CellVal, lnNdx-1)
		          lcDecNbr   = Substr(loCellFormat.CellVal, lnNdx+1)
		          If Len(lcDecNbr) > 0
		            loCellFormat.CellVal  = lcWholeNbr + "." + Padr(lcDecNbr, 17, "0")
		            loCellFormat.DataType = DATA_TYPE_DATETIME
		          Else
		            loCellFormat.CellVal  = lcWholeNbr
		            loCellFormat.DataType = DATA_TYPE_DATE
		          Endif
		        Endcase
		
		      Case Inlist(xl_cellxfs.numFmtId, 18, 19, 20, 21, 45, 46)                 && Time format
		        Do Case
		        Case Atc("E-", loCellFormat.CellVal) > 0
		          loCellFormat.CellVal  = Padr(Transform(Eval(loCellFormat.CellVal)), 19, "0")
		          loCellFormat.DataType = DATA_TYPE_TIME
		
		        Case Atc("E", loCellFormat.CellVal) > 0
		          loCellFormat.CellVal = Transform(Eval(loCellFormat.CellVal))
		          lnNdx = Atc(".", loCellFormat.CellVal)
		          lcWholeNbr = Left(loCellFormat.CellVal, lnNdx-1)
		          lcDecNbr   = Substr(loCellFormat.CellVal, lnNdx+1)
		          loCellFormat.CellVal  = lcWholeNbr + "." + Padr(lcDecNbr, 17, "0")
		          loCellFormat.DataType = DATA_TYPE_DATETIME
		
		        Case Left(loCellFormat.CellVal, 2) = "0."
		          lcDecNbr = Substr(loCellFormat.CellVal, 3)
		          loCellFormat.CellVal  = "0." + Padr(lcDecNbr, 17, "0")
		          loCellFormat.DataType = DATA_TYPE_TIME
		
		        Otherwise
		          lnNdx = Atc(".", loCellFormat.CellVal)
		          lcWholeNbr = Left(loCellFormat.CellVal, lnNdx-1)
		          lcDecNbr   = Substr(loCellFormat.CellVal, lnNdx+1)
		          loCellFormat.CellVal  = lcWholeNbr + "." + Padr(lcDecNbr, 17, "0")
		          loCellFormat.DataType = DATA_TYPE_DATETIME
		        Endcase
		
		      Case Inlist(xl_cellxfs.numFmtId, 22, 29, 30, 31, 32, 33, 34)             && Date-time format
		        lnNdx = Atc(".", loCellFormat.CellVal)
		        lcWholeNbr = Iif(lnNdx=0, loCellFormat.CellVal, Left(loCellFormat.CellVal, lnNdx-1))     && Bug fix provide by Dan Goodwin from VFPx
		        lcDecNbr   = Iif(lnNdx=0, "", Substr(loCellFormat.CellVal, lnNdx+1))                     && Bug fix provide by Dan Goodwin from VFPx
		        loCellFormat.CellVal  = lcWholeNbr + "." + Padr(lcDecNbr, 17, "0")
		        loCellFormat.DataType = DATA_TYPE_DATETIME
		
		      Case xl_cellxfs.numFmtId = 49                                            && Numeric formatted as text
		        loCellFormat.StringNdx = This.AddStringValue(tnWB, loCellFormat.CellVal, False)
		        loCellFormat.CellVal   = "StringValue"
		        loCellFormat.DataType  = DATA_TYPE_CHAR
		
		      Case Seek(BinToC(tnWB)+BinToC(xl_cellxfs.numFmtId), "xl_numfmts", "id")  && Determine based on custom format
		        lcFormatCode = Alltrim(xl_numfmts.formatcode)
		        Do Case
		        Case Atc("h:m", lcFormatCode) > 0 Or Atc("m:s", lcFormatCode) > 0 Or Atc("AM/PM", lcFormatCode) > 0 Or Atc("A/P", lcFormatCode) > 0
		          loCellFormat.DataType = DATA_TYPE_DATETIME
		
		        Case Atc("yy", lcFormatCode) > 0 Or Atc("d\-m", lcFormatCode) > 0
		          loCellFormat.DataType = DATA_TYPE_DATE
		
		        Otherwise
		          lnNdx = Atc(".", lcFormatCode)
		          If lnNdx > 0
		            loCellFormat.DataType = DATA_TYPE_FLOAT
		            lnNdx = lnNdx + 1
		            Do While lnNdx < Len(lcFormatCode)
		              If Substr(lcFormatCode, lnNdx, 1) != "0"
		                Exit
		              Endif
		              lnNdx = lnNdx + 1
		            Enddo
		          Else
		            loCellFormat.DataType = DATA_TYPE_INT
		          Endif
		        Endcase
		
		      Otherwise
		        Do Case
		        Case Isnull(loCellFormat.CellVal) Or Empty(loCellFormat.CellVal)
		          loCellFormat.DataType = DATA_TYPE_NONE
		
		        Case Atc(".", loCellFormat.CellVal) > 0
		          loCellFormat.DataType = DATA_TYPE_FLOAT
		
		        Otherwise
		          loCellFormat.DataType = DATA_TYPE_INT
		        Endcase
		      Endcase
		    Else
		      Do Case
		      Case Isnull(loCellFormat.CellVal) Or Empty(loCellFormat.CellVal)
		        loCellFormat.CellVal  = ""
		        loCellFormat.DataType = DATA_TYPE_NONE
		
		      Case Atc(".", loCellFormat.CellVal) > 0
		        loCellFormat.DataType = DATA_TYPE_FLOAT
		
		      Otherwise
		        loCellFormat.DataType = DATA_TYPE_INT
		      Endcase
		    Endif
		  Endcase
		Endwith
		Return loCellFormat
		
	ENDPROC

	PROTECTED PROCEDURE readexternalrefxml		&& Reads the External References file
		Lparameters tnWB, tcFileName, tnRelId
		Local lcExternalLink, lcSheetNames, lnNode, lcSheetName, lcShName
		
		*-*	Open the external file for processing
		lcExternalLink = Filetostr(tcFileName)
		
		With This
		*-*	Get the sheet names
		  lcSheetNames = .GetNodeElement(lcExternalLink, 'sheetNames', 1)
		  If !Empty(lcSheetNames)
		    lnNode = 1
		    lcSheetName = .GetNodeElement(lcSheetNames, 'sheetName', lnNode)
		    Do While !Empty(lcSheetName)
		      lcShName = .GetNodeAttributeValue(lcSheetName, "val")
		
		      Insert Into xl_extsheets (workbook, extid, relid, sheetname) Values (tnWB, lnNode, tnRelId, lcShName)
		
		      lnNode = lnNode + 1
		      lcSheetName = .GetNodeElement(lcSheetNames, 'sheetName', lnNode)
		    Enddo
		
		*-*	Get each external sheet detail
		    lnNode = 1
		    lcSheetData = .GetNodeElement(lcExternalLink, 'sheetData', lnNode)
		    Do While !Empty(lcSheetData)
		      lnRow = 1
		      lcRowData = .GetNodeElement(lcSheetData, 'row', lnRow)
		      Do While !Empty(lcRowData)
		
		      Enddo
		
		      lnNode = lnNode + 1
		      lcSheetData = .GetNodeElement(lcExternalLink, 'sheetData', lnNode)
		    Enddo
		  Endif
		Endwith
		
	ENDPROC

	PROTECTED PROCEDURE readsharedstringsxml		&& Reads the sharedstrings.xml for opening workbooks
		Lparameters tcFilePath, tnWB
		Local lcStrings, lcString, lnNode, lcRichTextRun, lcText, lnIndex, llFBold, llFItalic, loException, lcT
		Local lnFColor, lcFName, lnFSize, lcULine, llStrkThr, lcFVPos, lnTheme, lnTint, lnIndexed, lcRunPrp
		Local lnR, lcRText, lcRunProp, lcColor, llPrsvSp, llFormatted, llSuccess, lhFile, lcSharedStringFile, lnSize
		Local lcStringXml, lcCheckSum
		
		With This
		  Raiseevent(This, "OnShowStatusMessage", 1, 1)
		  Try
		    lcSharedStringFile = Addbs(tcFilePath) + "xl\sharedStrings.xml"
		    lcStrings = Filetostr(lcSharedStringFile)
		    If .Codepage = 0
		      lcStrings = Strconv(lcStrings, 11)
		    Else
		      lcStrings = Strconv(lcStrings, 11, .Codepage, 1)
		    Endif
		
		    lnNode    = 1
		    lcString  = .GetNodeElement(lcStrings, 'si', lnNode)
		    Do While !Empty(lcString)
		      lnR = 1
		      lcRichTextRun = .GetNodeElement(lcString, 'r', lnR, True)
		      If Empty(lcRichTextRun)
		        llFormatted = False
		        lcT      = .GetNodeElement(lcString, 't', 1)
		        lcText   = .GetNodeElementValue(lcT)
		        llPrsvSp = Iif(Empty(.GetNodeAttributeValue(lcT, "xml:space")), False, True)
		
		        If llPrsvSp
		          lcRText = Chrtran(lcText, Chr(32), Chr(160))
		        Endif
		      Else
		        llFormatted = True
		        lcText   = ""
		        lnIndex  = 0
		        Do While !Empty(lcRichTextRun)
		          lnIndex   = lnIndex + 1
		          lcT       = .GetNodeElement(lcRichTextRun, 't', 1)
		          llPrsvSp  = Iif(Empty(.GetNodeAttributeValue(lcT, "xml:space")), False, True)
		          lcRText   = .GetNodeElementValue(lcT)
		          lcText    = lcText + lcRText
		
		          lcRunProp = .GetNodeElement(lcRichTextRun, 'rPr', 1, True)
		          llFBold   = Iif(Atc("<b/>", lcRunProp)>0, True, False)
		          llFItalic = Iif(Atc("<i/>", lcRunProp)>0, True, False)
		          llStrkThr = Iif(Atc("<strike/>", lcRunProp)>0, True, False)
		          If Atc("<u/>", lcRunProp) > 0
		            lcULine = UNDERLINE_SINGLE
		          Else
		            lcULine = .GetNodeAttributeValue(.GetNodeElement(lcRunProp, 'u', 1), "val")
		            lcULine = Iif(Empty(lcULine), UNDERLINE_NONE, lcULine)
		          Endif
		
		          lnFSize   = Cast(.GetNodeAttributeValue(.GetNodeElement(lcRunProp, 'sz', 1), "val") As I)
		          lcFName   = .GetNodeAttributeValue(.GetNodeElement(lcRunProp, 'rFont', 1), "val")
		          lcFVPos   = .GetNodeAttributeValue(.GetNodeElement(lcRunProp, 'vertAlign', 1), "val")
		
		          lcColor   = .GetNodeElement(lcRunProp, 'color', 1)
		          lnFColor  = .ConvertHexStringToNumeric(.GetNodeAttributeValue(lcColor, "rgb"))
		          lnTheme   = Cast(.GetNodeAttributeValue(lcColor, "theme") As I)
		          lnTint    = Cast(.GetNodeAttributeValue(lcColor, "tint") As I)
		          lnIndexed = Cast(.GetNodeAttributeValue(lcColor, "indexed") As I)
		
		          If llPrsvSp
		            lcRText = Chrtran(lcRText, Chr(32), Chr(160))
		          Endif
		
		          Insert Into xl_strformat (workbook, Id, Index, stringxml, stringval, fbold, fitalic, fcolor, fname, Fsize, uline, strkthr, fvpos, Theme, tint, indexed, presvspace) ;
		            VALUES (tnWB, lnNode-1, lnIndex, lcRText, .GetStringXML(lcRText), llFBold, llFItalic, lnFColor, lcFName, lnFSize, lcULine, llStrkThr, ;
		            lcFVPos, lnTheme, lnTint, lnIndexed, llPrsvSp)
		
		          lnR = lnR + 1
		          lcRichTextRun = .GetNodeElement(lcString, 'r', lnR, True)
		        Enddo
		        llPrsvSp = False
		      Endif
		      lcStringXml = .GetXMLString(lcText)
		      lcCheckSum  = .GetCheckSum(lcText)
		
		      Insert Into xl_strings (Id, workbook, checksum, stringxml, stringval, presvspace, Formatted) ;
		        VALUES (lnNode-1, tnWB, lcCheckSum, lcText, lcStringXml, llPrsvSp, llFormatted)
		
		      lnNode = lnNode + 1
		      lcString = .GetNodeElement(lcStrings, 'si', lnNode)
		    Enddo
		    .SetLastId(tnWB, lnNode-2, "xl_strings")    && Decrement by 2 to account for empty string not assigned
		    llSuccess = True
		
		  Catch To loException
		    Set Step On
		    llSuccess = False
		  Endtry
		Endwith
		Return llSuccess
		
	ENDPROC

	PROTECTED PROCEDURE readsheetxml		&& Reads the sheet.xml for opening a workbook
		Lparameters tcShFile, tnWB, tnSheet, tcShName, tnShState, tlForceTextFormat
		Local lcSheet, lcSheetViews, lcSheetView, lcPane, lcMargin, lnXSplit, lnYSplit, lnLeft, lcDimen, lnScale, lnFitToWidth, lnFitToHeight
		Local lnRight, lnTop, lnBottom, lnHeader, lnFooter, lcPageSetup, lnOrientation, lnPaperSize, lnWidth, lnHeight, lnNode, lcMergeCells
		Local lnCnt, lcMergeCell, lcCellRef, lnBegCol, lnBegRow, lnEndCol, lnEndRow, lcTemp, lnNdx, lcSheetData
		Local lcRow, lnRowHt, lnCellRow, lnCellCol, lnCol, loCell, lnTabColNdx, lcTabColRgb, lcTabColor, lcSheetPr
		Local lcValidations, lnValidType, lcValidation, lnValidStyle, lnOperator, lcErrMsg, lcErrTitle, lcPrompt, lcFormula1
		Local lcFormula2, llAllowBlank, llShowInputMsg, llShowErrMsg, llFormula, llCustHt, lcValidType, lcValidStyle
		Local lcValidSqRef, lnIndex
		
		With This
		*-*	Open the sheet for processing
		  lcSheet = Filetostr(tcShFile)
		  If .Codepage = 0
		    lcSheet = Strconv(lcSheet, 11)
		  Else
		    lcSheet = Strconv(lcSheet, 11, .Codepage, 1)
		  Endif
		
		*-*	Get the freeze rows/columns settings
		  lcSheetViews = .GetNodeElement(lcSheet, 'sheetViews', 1, True)
		  lcSheetView  = .GetNodeElement(lcSheetViews, 'sheetView', 1)
		  lcPane       = .GetNodeElement(lcSheetView, 'pane', 1)
		  lnXSplit     = Cast(.GetNodeAttributeValue(lcPane, "xSplit") As I)
		  lnYSplit     = Cast(.GetNodeAttributeValue(lcPane, "ySplit") As I)
		
		*-*	Get the tab color settings
		  lcSheetPr = .GetNodeElement(lcSheet, 'sheetPr', 1)
		  If Empty(lcSheetPr)
		    lnTabColNdx = 0
		    lcTabColRgb = ""
		  Else
		    lcTabColor  = .GetNodeElement(lcSheetPr, 'tabColor', 1)
		    lnTabColNdx = Cast(.GetNodeAttributeValue(lcTabColor, "indexed") As I)
		    lcTabColRgb = .GetNodeAttributeValue(lcTabColor, "rgb")
		  Endif
		
		*-*	Get the worksheet margins
		  lcMargin = .GetNodeElement(lcSheet, 'pageMargins', 1)
		  lnLeft   = Cast(.GetNodeAttributeValue(lcMargin, "left") As N(6,3))
		  lnLeft   = Iif(lnLeft = 0.000, 0.75, lnLeft)
		  lnRight  = Cast(.GetNodeAttributeValue(lcMargin, "right") As N(6,3))
		  lnRight  = Iif(lnRight = 0.000, 0.75, lnRight)
		  lnTop    = Cast(.GetNodeAttributeValue(lcMargin, "top") As N(6,3))
		  lnTop    = Iif(lnTop = 0.000, 0.75, lnTop)
		  lnBottom = Cast(.GetNodeAttributeValue(lcMargin, "bottom") As N(6,3))
		  lnBottom = Iif(lnBottom = 0.000, 0.75, lnBottom)
		  lnFooter = Cast(.GetNodeAttributeValue(lcMargin, "footer") As N(6,3))
		  lnFooter = Iif(lnFooter = 0.000, 0.30, lnFooter)
		  lnHeader = Cast(.GetNodeAttributeValue(lcMargin, "header") As N(6,3))
		  lnHeader = Iif(lnHeader = 0.000, 0.30, lnHeader)
		
		*-*	Get the page setup
		  lcPageSetup   = .GetNodeElement(lcSheet, 'pageMargins', 1)
		  lnOrientation = Iif(.GetNodeAttributeValue(lcPageSetup, "orientation")='portrait', PORTRAIT_PRINT_ORIENTATION, LANDSCAPE_PRINT_ORIENTATION)
		  lnPaperSize   = Cast(.GetNodeAttributeValue(lcPageSetup, "paperSize") As I)
		  lnPaperSize   = Iif(lnPaperSize=0, PAPERSIZE_LTR, lnPaperSize)
		  lnWidth       = Cast(.GetNodeAttributeValue(lcPageSetup, "paperWidth") As I)
		  lnHeight      = Cast(.GetNodeAttributeValue(lcPageSetup, "paperHeight") As I)
		  lcDimen       = Right(.GetNodeAttributeValue(lcPageSetup, "paperHeight"), 2)
		  lnScale       = Cast(.GetNodeAttributeValue(lcPageSetup, "scale") As I)
		  lnScale       = Iif(lnScale=0, 100, lnScale)
		  lnFitToWidth  = Cast(.GetNodeAttributeValue(lcPageSetup, "fitToWidth") As I)
		  lnFitToHeight = Cast(.GetNodeAttributeValue(lcPageSetup, "fitToHeight") As I)
		
		*-*	Save the worksheet to the cursor
		  Insert Into xl_sheets (workbook, Sheet, shname, state, mleft, mright, mtop, mbot, mheader, mfooter, shdeleted, xsplit, ysplit, prnorient, ;
		    papersize, Paperwidth, paperheight, paperdimen, Scale, fittowidth, fittoheight, tabcolorndx, tabcolorrgb) ;
		    VALUES (tnWB, tnSheet, tcShName, tnShState, lnLeft, lnRight, lnTop, lnBottom, lnHeader, lnFooter, False, lnXSplit, lnYSplit, lnOrientation, ;
		    lnPaperSize, lnWidth, lnHeight, lcDimen, lnScale, lnFitToWidth, lnFitToHeight, lnTabColNdx, lcTabColRgb)
		
		*-*	Get the defined column widths
		  lcCols = .GetNodeElement(lcSheet, 'cols', 1, True)
		  lnNode = 1
		  lcCol  = .GetNodeElement(lcCols, 'col', lnNode)
		  Do While !Empty(lcCol)
		    lnMinCol = Cast(.GetNodeAttributeValue(lcCol, "min") As I)
		    lnMaxCol = Cast(.GetNodeAttributeValue(lcCol, "max") As I)
		    lnWidth  = Cast(.GetNodeAttributeValue(lcCol, "width") As N(16,9)) - 0.71093750
		    For lnCol=lnMinCol To lnMaxCol
		      Insert Into xl_colwidths (workbook, Sheet, Column, Width) Values (tnWB, tnSheet, lnCol, lnWidth)
		    Endfor
		    lnNode = lnNode + 1
		    lcCol  = .GetNodeElement(lcCols, 'col', lnNode)
		  Enddo
		
		*-*	Get the defined merged cells
		  lcMergeCells = .GetNodeElement(lcSheet, 'mergeCells', 1)
		  lnCnt = Cast(.GetNodeAttributeValue(lcMergeCells, "count") As I)
		  For lnNode=1 To lnCnt
		    lcMergeCell = .GetNodeElement(lcMergeCells, 'mergeCell', lnNode)
		    If Empty(lcMergeCell)
		      Set Step On
		      Loop
		    Endif
		    lcCellRef = .GetNodeAttributeValue(lcMergeCell, "ref")
		    lnBegCol = 0
		    lnBegRow = 0
		    lnEndCol = 0
		    lnEndRow = 0
		    lcTemp = Getwordnum(lcCellRef, 1, ":")
		    lnNdx = 0
		    Do While lnNdx < Len(lcTemp)
		      lnNdx = lnNdx + 1
		      If Isdigit(Substr(lcTemp, lnNdx, 1))
		        lnBegCol = .ColumnAsciiToIndex(Left(lcTemp, lnNdx-1))
		        lnBegRow = Int(Val(Substr(lcTemp, lnNdx)))
		        Exit
		      Endif
		    Enddo
		    If lnBegCol > 0
		      lcTemp = Getwordnum(lcCellRef, 2, ":")
		      lnNdx = 0
		      Do While lnNdx < Len(lcTemp)
		        lnNdx = lnNdx + 1
		        If Isdigit(Substr(lcTemp, lnNdx, 1))
		          lnEndCol = .ColumnAsciiToIndex(Left(lcTemp, lnNdx-1))
		          lnEndRow = Int(Val(Substr(lcTemp, lnNdx)))
		          Exit
		        Endif
		      Enddo
		      If lnEndCol > 0
		        Insert Into xl_mergecells (workbook, Sheet, begrow, begcol, endrow, endcol) ;
		          VALUES (tnWB, tnSheet, lnBegRow, lnBegCol, lnEndRow, lnEndCol)
		      Endif
		    Endif
		  Endfor
		
		*-*	Get the sheet cell values and formatting
		  lcSheetData = .GetNodeElement(lcSheet, 'sheetData', 1, True)
		  lnNode = 1
		  lcRow = .GetNodeElement(lcSheetData, 'row', lnNode)
		  Do While !Empty(lcRow)                                                   && Process each row in the sheet
		    lnCellRow = Cast(.GetNodeAttributeValue(lcRow, "r") As I)
		    lnRowHt   = Cast(.GetNodeAttributeValue(lcRow, "ht") As N(14,7))
		    llCustHt  = Iif(Cast(.GetNodeAttributeValue(lcRow, "customHeight") As I) = 1, True, False)
		    If llCustHt Or (lnRowHt > 0.00 And lnRowHt != 30)
		      Insert Into xl_rowheights (workbook, Sheet, Row, Height) Values (tnWB, tnSheet, lnCellRow, lnRowHt)
		    Endif
		
		    lnCol     = 1
		    lnCellCol = 1
		    lcColumn  = .GetNodeElement(lcRow, 'c', lnCol)
		    Do While !Empty(lcColumn)                                            && Process each column in a row
		      lnCellCol = .ColumnAsciiToIndex(.GetNodeAttributeValue(lcColumn, "r"))
		      loCell    = .ReadCellValueFormat(tnWB, lcColumn, lnCellCol)
		      If tlForceTextFormat And loCell.DataType != DATA_TYPE_CHAR
		        loCell.DataType  = DATA_TYPE_CHAR
		        loCell.StringNdx = .AddStringValue(tnWB, Transform(loCell.CellVal), False)
		        loCell.CellVal   = "StringValue"
		        loCell.Formula   = ""
		      Endif
		      Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, cellvalue, DataType, cellformula, stringid, cellxfs, celldeleted) ;
		        VALUES (tnWB, tnSheet, lnCellRow, lnCellCol, loCell.CellVal, loCell.DataType, loCell.Formula, loCell.StringNdx, loCell.CellXfsId, False)
		
		      lnCol = lnCol + 1
		      lcColumn = .GetNodeElement(lcRow, 'c', lnCol)
		    Enddo
		    Insert Into xl_rows (workbook, Sheet, Row, maxcol) Values (tnWB, tnSheet, lnCellRow, lnCellCol)
		
		    lnNode = lnNode + 1
		    lcRow = .GetNodeElement(lcSheet, 'row', lnNode)
		  Enddo
		
		*-*	Get the validations
		  lcValidations = .GetNodeElement(lcSheet, 'dataValidations', 1)
		  lnCnt = Cast(.GetNodeAttributeValue(lcValidations, "count") As I)
		  For lnNode=1 To lnCnt
		    lcValidation = .GetNodeElement(lcValidations, 'dataValidation', lnNode)
		    If Empty(lcValidation)
		      Set Step On
		      Loop
		    Endif
		    lcValidSqRef = .GetNodeAttributeValue(lcValidation, "sqref")
		    If Empty(lcValidSqRef)
		      Set Step On
		      Loop
		    Endif
		    lcValidType = .GetNodeAttributeValue(lcValidation, "type")
		    Do Case
		    Case lcValidType = "none"
		      lnValidType = NONE_VALID_TYPE
		
		    Case lcValidType = "whole"
		      lnValidType = WHOLE_VALID_TYPE
		
		    Case lcValidType = "decimal"
		      lnValidType = DECIMAL_VALID_TYPE
		
		    Case lcValidType = "list"
		      lnValidType = LIST_VALID_TYPE
		
		    Case lcValidType = "date"
		      lnValidType = DATE_VALID_TYPE
		
		    Case lcValidType = "time"
		      lnValidType = TIME_VALID_TYPE
		
		    Case lcValidType = "textLength"
		      lnValidType = TXTLEN_VALID_TYPE
		
		    Case lcValidType = "custom"
		      lnValidType = CUSTOM_VALID_TYPE
		
		    Otherwise
		      lnValidType = NONE_VALID_TYPE
		    Endcase
		
		    lcValidStyle = .GetNodeAttributeValue(lcValidation, "errorStyle")
		    Do Case
		    Case lcValidStyle = "stop"
		      lnValidStyle = STOP_VALID_STYLE
		
		    Case lcValidStyle = "warning"
		      lnValidStyle = WARN_VALID_STYLE
		
		    Case lcValidStyle = "information"
		      lnValidStyle = INFO_VALID_STYLE
		
		    Otherwise
		      lnValidStyle = 0
		    Endcase
		
		    lcOperator = .GetNodeAttributeValue(lcValidation, "operator")
		    Do Case
		    Case lcOperator = "between"
		      lnOperator = BETWEEN_VALID_OPER
		
		    Case lcOperator = "notBetween"
		      lnOperator = NOTBETW_VALID_OPER
		
		    Case lcOperator = "equal"
		      lnOperator = EQUAL_VALID_OPER
		
		    Case lcOperator = "notEqual"
		      lnOperator = NOTEQUAL_VALID_OPER
		
		    Case lcOperator = "lessThan"
		      lnOperator = LESSTHAN_VALID_OPER
		
		    Case lcOperator = "lessThanOrEqual"
		      lnOperator = LESSOREQUAL_VALID_OPER
		
		    Case lcOperator = "greaterThan"
		      lnOperator = GREATTHAN_VALID_OPER
		
		    Case lcOperator = "greaterThanOrEqual"
		      lnOperator = GREATOREQUAL_VALID_OPER
		
		    Otherwise
		      lnOperator = 0
		    Endcase
		
		    lcErrMsg       = .GetNodeAttributeValue(lcValidation, "error")
		    lcErrTitle     = .GetNodeAttributeValue(lcValidation, "errorTitle")
		    lcPrompt       = .GetNodeAttributeValue(lcValidation, "prompt")
		    llAllowBlank   = Iif(Cast(.GetNodeAttributeValue(lcValidation, "allowBlank") As I)=1, True, False)
		    llShowInputMsg = Iif(Cast(.GetNodeAttributeValue(lcValidation, "showInputMessage") As I)=1, True, False)
		    llShowErrMsg   = Iif(Cast(.GetNodeAttributeValue(lcValidation, "showErrorMessage") As I)=1, True, False)
		
		    lcFormula1     = .GetNodeElementValue(.GetNodeElement(lcValidation, 'formula1', 1, True))
		    lcFormula2     = .GetNodeElementValue(.GetNodeElement(lcValidation, 'formula2', 1, True))
		
		    If Left(lcFormula1, 1) = '"' Or Left(lcFormula2, 1) = '"'
		      lcFormula1 = Alltrim(lcFormula1, 1, '"')
		      lcFormula2 = Alltrim(lcFormula2, 1, '"')
		      llFormula  = False
		    Else
		      llFormula = True
		    Endif
		    Insert Into xl_validation (workbook, Sheet, vtype, vstyle, voperator, errmsg, errtitle, vprompt, allowblank, showinpmsg, showerrmsg, Formula, formula1, formula2) ;
		      VALUES (tnWB, tnSheet, lnValidType, lnValidStyle, lnOperator, lcErrMsg, lcErrTitle, lcPrompt, llAllowBlank, llShowInputMsg, llShowErrMsg, llFormula, lcFormula1, lcFormula2)
		    lnIndex = xl_validation.validndx
		
		    loCell = .CellRefAsciiToIndex(lcValidSqRef)
		    If .GetCellRecord(tnWB, tnSheet, loCell.Row, loCell.Column)
		      Replace xl_cells.validndx With lnIndex In xl_cells
		    Else
		      Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted, numdec, validndx) ;
		        VALUES (tnWB, tnSheet, loCell.Row, loCell.Column, DATA_TYPE_NONE, 0, False, -1, lnIndex)
		
		      .SetRowMaxColumn(tnWB, tnSheet, loCell.Row, loCell.Column)
		    Endif
		  Endfor
		Endwith
		Return True
		
	ENDPROC

	PROTECTED PROCEDURE readstylesxml		&& Reads the styles.xml file for opening a workbook
		Lparameters tcFilePath, tnWB
		Local lcCellXfs, lnCnt, lcXf, lnIndent, lnWrapTx, lcAlign, lcStyleSheet, lnNode, lnNumFmtId, lnFontId, lnFillId, lnBorderId
		Local lcHAlign, lcVAlign, lcNumFmts, lcFonts, lcNumFmt, lcFormatCode, lcFont, lnIndexed, lnFSize, lcFName, llFBold, llFItalic, llStrkthr
		Local lcFVPos, lcULine, lnFColor, lnTheme, lnTint, lcColor, lcFills, lcFill, lcPatternFill, lcPatternType, lnFgColor, lnFgIndexed, lcBorder
		Local lnBgColor, lnBgIndexed, lcBorders, lcBLeft, lcLStyle, lnLColor, lnLTheme, lnLTint, lnLIndex, lcBRight, lcRStyle, lnRColor, lnRTheme
		Local lnRTint, lnRIndex, lcBTop, lcTStyle, lnTColor, lnTTheme, lnTTint, lnTIndex, lcBBottm, lcBStyle, lnBColor, lnBTheme, lnBTint, lnBIndex
		Local lnDTint, lnDIndex, lcBDiag, lcDStyle, lnDColor, lnDTheme, lcIndexedColors, lcRgbColor, lcMruColors, lnIdCnt
		
		Raiseevent(This, "OnShowStatusMessage", 1, 2)
		
		With This
		*-*	Open the styles sheet for processing
		  lcStyleSheet = Filetostr(Addbs(tcFilePath) + "xl\styles.xml")
		
		*-*	Retreive the cell format mapping information
		  lnIdCnt   = -1
		  lcCellXfs = .GetNodeElement(lcStyleSheet, 'cellXfs', 1)
		  lnCnt     = Cast(.GetNodeAttributeValue(lcCellXfs, "count") As I)
		  For lnNode=1 To lnCnt
		    lcXf = .GetNodeElement(lcCellXfs, 'xf', lnNode)
		    If Empty(lcXf)
		      Set Step On
		      Loop
		    Endif
		    lnIdCnt    = lnIdCnt + 1
		    lcAlign    = .GetNodeElement(lcXf, 'alignment', 1)
		    lcHAlign   = .GetNodeAttributeValue(lcAlign, "horizontal")
		    lcVAlign   = .GetNodeAttributeValue(lcAlign, "vertical")
		    lnNumFmtId = Cast(.GetNodeAttributeValue(lcXf, "numFmtId") As I)
		    lnFontId   = Cast(.GetNodeAttributeValue(lcXf, "fontId") As I)
		    lnFillId   = Cast(.GetNodeAttributeValue(lcXf, "fillId") As I)
		    lnBorderId = Cast(.GetNodeAttributeValue(lcXf, "borderId") As I)
		    lnIndent   = Cast(.GetNodeAttributeValue(lcAlign, "indent") As I)
		    lnWrapTx   = Cast(.GetNodeAttributeValue(lcAlign, "wrapText") As I)
		    lnRotation = Cast(.GetNodeAttributeValue(lcAlign, "textRotation") As I)
		
		    Insert Into xl_cellxfs (workbook, Id, numFmtId, fontId, fillId, borderId, halign, valign, indent, wraptext, Rotation) ;
		      VALUES (tnWB, lnIdCnt, lnNumFmtId, lnFontId, lnFillId, lnBorderId, lcHAlign, lcVAlign, lnIndent, lnWrapTx, lnRotation)
		  Endfor
		  .SetLastId(tnWB, lnIdCnt, "xl_cellxfs")
		
		*-*	Retreive the number format information
		  lnIdCnt   = -1
		  lcNumFmts = .GetNodeElement(lcStyleSheet, 'numFmts', 1)
		  lnCnt     = Cast(.GetNodeAttributeValue(lcNumFmts, "count") As I)
		  For lnNode=1 To lnCnt
		    lcNumFmt = .GetNodeElement(lcNumFmts, 'numFmt', lnNode)
		    If Empty(lcNumFmt)
		      Set Step On
		      Loop
		    Endif
		    lnNumFmtId   = Cast(.GetNodeAttributeValue(lcNumFmt, "numFmtId") As I)
		    lcFormatCode = .GetNodeAttributeValue(lcNumFmt, "formatCode")
		
		    Insert Into xl_numFmts (workbook, Id, formatxml, formatcode, applydec) ;
		      VALUES (tnWB, lnNumFmtId, lcFormatCode, .GetStringXML(lcFormatCode), False)
		  Endfor
		
		*-*	Retreive the font informaton
		  lnIdCnt = -1
		  lcFonts = .GetNodeElement(lcStyleSheet, 'fonts', 1)
		  lnCnt   = Cast(.GetNodeAttributeValue(lcFonts, "count") As I)
		  For lnNode=1 To lnCnt
		    lcFont = .GetNodeElement(lcFonts, 'font', lnNode)
		    If Empty(lcFont)
		      Set Step On
		      Loop
		    Endif
		    lnIdCnt   = lnIdCnt + 1
		    lnFSize   = Cast(.GetNodeAttributeValue(.GetNodeElement(lcFont, 'sz', 1), "val") As I)
		    lnFSize   = Iif(lnFSize>0, lnFSize, 10)
		    lcFName   = .GetNodeAttributeValue(.GetNodeElement(lcFont, 'name', 1), "val")
		    llFBold   = Iif(Atc("<b/>", lcFont)>0, True, False)
		    llFItalic = Iif(Atc("<i/>", lcFont)>0, True, False)
		    llStrkthr = Iif(Atc("<strike/>", lcFont)>0, True, False)
		    lcFVPos   = .GetNodeAttributeValue(.GetNodeElement(lcFont, 'vertAlign', 1), "val")
		
		    If Atc("<u/>", lcFont) > 0
		      lcULine = UNDERLINE_SINGLE
		    Else
		      lcULine = .GetNodeAttributeValue(.GetNodeElement(lcFont, 'u', 1), "val")
		      lcULine = Iif(Empty(lcULine), UNDERLINE_NONE, lcULine)
		    Endif
		
		    lcColor   = .GetNodeElement(lcFont, 'color', 1)
		    lnFColor  = .ConvertHexStringToNumeric(.GetNodeAttributeValue(lcColor, "rgb"))
		    lnTheme   = Cast(.GetNodeAttributeValue(lcColor, "theme") As I)
		    lnTint    = Cast(.GetNodeAttributeValue(lcColor, "tint") As I)
		    lnIndexed = Cast(.GetNodeAttributeValue(lcColor, "indexed") As I)
		
		    Insert Into xl_fonts (workbook, Id, fname, Fsize, fcolor, fbold, fitalic, uline, strkthr, fvpos, Theme, tint, indexed) ;
		      VALUES (tnWB, lnIdCnt, lcFName, lnFSize, lnFColor, llFBold, llFItalic, lcULine, llStrkthr, lcFVPos, lnTheme, lnTint, lnIndexed)
		  Endfor
		  .SetLastId(tnWB, lnIdCnt, "xl_fonts")
		
		*-*	Retreive the cell fill information
		  lnIdCnt = -1
		  lcFills = .GetNodeElement(lcStyleSheet, 'fills', 1)
		  lnCnt   = Cast(.GetNodeAttributeValue(lcFills, "count") As I)
		  For lnNode=1 To lnCnt
		    lcFill = .GetNodeElement(lcFills, 'fill', lnNode)
		    If Empty(lcFill)
		      Set Step On
		      Loop
		    Endif
		    lnIdCnt       = lnIdCnt + 1
		    lcPatternFill = .GetNodeElement(lcFill, 'patternFill', 1)
		    lcPatternType = .GetNodeAttributeValue(lcPatternFill, "patternType")
		    lcPatternType = Iif(Empty(lcPatternType), "none", lcPatternType)
		    lnTheme       = Cast(.GetNodeAttributeValue(lcPatternFill, "theme") As I)
		
		    lcColor = .GetNodeElement(lcPatternFill, 'fgColor', 1)
		    If Empty(lcColor)
		      lnFgColor   = 0
		      lnFgIndexed = 0
		    Else
		      lnFgColor   = .ConvertHexStringToNumeric(.GetNodeAttributeValue(lcColor, "rgb"))
		      lnFgIndexed = Cast(.GetNodeAttributeValue(lcColor, "indexed") As I)
		    Endif
		    lcColor = .GetNodeElement(lcPatternFill, 'bgColor', 1)
		    If Empty(lcColor)
		      lnBgColor   = 0
		      lnBgIndexed = 0
		    Else
		      lnBgColor   = .ConvertHexStringToNumeric(.GetNodeAttributeValue(lcColor, "rgb"))
		      lnBgIndexed = Cast(.GetNodeAttributeValue(lcColor, "indexed") As I)
		    Endif
		    Insert Into xl_fills (workbook, Id, patttype, Theme, tint, fgcolor, bgcolor, fgindexed, bgindexed) ;
		      VALUES (tnWB, lnIdCnt, lcPatternType, lnTheme, lnTint, lnFgColor, lnBgColor, lnFgIndexed, lnBgIndexed)
		  Endfor
		  .SetLastId(tnWB, lnIdCnt, "xl_fills")
		
		*-*	Retreive the cell border information
		  lnIdCnt   = -1
		  lcBorders = .GetNodeElement(lcStyleSheet, 'borders', 1)
		  lnCnt     = Cast(.GetNodeAttributeValue(lcBorders, "count") As I)
		  For lnNode=1 To lnCnt
		    lcBorder = .GetNodeElement(lcBorders, 'border', lnNode)
		    If Empty(lcBorder)
		      Set Step On
		      Loop
		    Endif
		    lnIdCnt  = lnIdCnt + 1
		    lcBLeft  = .GetNodeElement(lcBorder, 'left', 1)
		    lcLStyle = .GetNodeAttributeValue(lcBLeft, "style")
		    lcColor  = .GetNodeElement(lcBLeft, 'color', 1)
		    If Empty(lcColor)
		      lnLColor = Rgb(0, 0, 0)
		      lnLTheme = 0
		      lnLTint  = 0
		      lnLIndex = 0
		    Else
		      lnLColor = .ConvertHexStringToNumeric(.GetNodeAttributeValue(lcColor, "rgb"))
		      lnLTheme = Cast(.GetNodeAttributeValue(lcColor, "theme") As I)
		      lnLTint  = Cast(.GetNodeAttributeValue(lcColor, "tint") As I)
		      lnLIndex = Cast(.GetNodeAttributeValue(lcColor, "indexed") As I)
		    Endif
		
		    lcBRight = .GetNodeElement(lcBorder, 'right', 1)
		    lcRStyle = .GetNodeAttributeValue(lcBRight, "style")
		    lcColor  = .GetNodeElement(lcBRight, 'color', 1)
		    If Empty(lcColor)
		      lnRColor = Rgb(0, 0, 0)
		      lnRTheme = 0
		      lnRTint  = 0
		      lnRIndex = 0
		    Else
		      lnRColor = .ConvertHexStringToNumeric(.GetNodeAttributeValue(lcColor, "rgb"))
		      lnRTheme = Cast(.GetNodeAttributeValue(lcColor, "theme") As I)
		      lnRTint  = Cast(.GetNodeAttributeValue(lcColor, "tint") As I)
		      lnRIndex = Cast(.GetNodeAttributeValue(lcColor, "indexed") As I)
		    Endif
		
		    lcBTop   = .GetNodeElement(lcBorder, 'top', 1)
		    lcTStyle = .GetNodeAttributeValue(lcBTop, "style")
		    lcColor  = .GetNodeElement(lcBTop, 'color', 1)
		    If Empty(lcColor)
		      lnTColor = Rgb(0, 0, 0)
		      lnTTheme = 0
		      lnTTint  = 0
		      lnTIndex = 0
		    Else
		      lnTColor = .ConvertHexStringToNumeric(.GetNodeAttributeValue(lcColor, "rgb"))
		      lnTTheme = Cast(.GetNodeAttributeValue(lcColor, "theme") As I)
		      lnTTint  = Cast(.GetNodeAttributeValue(lcColor, "tint") As I)
		      lnTIndex = Cast(.GetNodeAttributeValue(lcColor, "indexed") As I)
		    Endif
		
		    lcBBottm = .GetNodeElement(lcBorder, 'bottom', 1)
		    lcBStyle = .GetNodeAttributeValue(lcBBottm, "style")
		    lcColor  = .GetNodeElement(lcBBottm, 'color', 1)
		    If Empty(lcColor)
		      lnBColor = Rgb(0, 0, 0)
		      lnBTheme = 0
		      lnBTint  = 0
		      lnBIndex = 0
		    Else
		      lnBColor = .ConvertHexStringToNumeric(.GetNodeAttributeValue(lcColor, "rgb"))
		      lnBTheme = Cast(.GetNodeAttributeValue(lcColor, "theme") As I)
		      lnBTint  = Cast(.GetNodeAttributeValue(lcColor, "tint") As I)
		      lnBIndex = Cast(.GetNodeAttributeValue(lcColor, "indexed") As I)
		    Endif
		
		    lcBDiag  = .GetNodeElement(lcBorder, 'diagonal', 1)
		    lcDStyle = .GetNodeAttributeValue(lcBDiag, "style")
		    lnDiagDn = Cast(.GetNodeAttributeValue(lcBDiag, "diagonalDown") As I)
		    lnDiagUp = Cast(.GetNodeAttributeValue(lcBDiag, "diagonalUp") As I)
		    lcColor  = Cast(.GetNodeElement(lcBDiag, 'color', 1) As I)
		    If Empty(lcColor)
		      lnDColor = Rgb(0, 0, 0)
		      lnDTheme = 0
		      lnDTint  = 0
		      lnDIndex = 0
		    Else
		      lnDColor = .ConvertHexStringToNumeric(.GetNodeAttributeValue(lcColor, "rgb"))
		      lnDTheme = Cast(.GetNodeAttributeValue(lcColor, "theme") As I)
		      lnDTint  = Cast(.GetNodeAttributeValue(lcColor, "tint") As I)
		      lnDIndex = Cast(.GetNodeAttributeValue(lcColor, "indexed") As I)
		    Endif
		
		    Insert Into xl_borders (workbook, Id, lstyle, lcolor, ltheme, ltint, lindexed, rstyle, rcolor, rtheme, rtint, rindexed, tstyle, tcolor, ttheme, ttint, tindexed, ;
		      bstyle, bcolor, btheme, btint, bindexed, dstyle, dcolor, dtheme, dtint, dindexed, diagdn, diagup) ;
		      VALUES (tnWB, lnIdCnt, lcLStyle, lnLColor, lnLTheme, lnLTint, lnLIndex, lcRStyle, lnRColor, lnRTheme, lnRTint, lnRIndex, lcTStyle, lnTColor, lnTTheme, ;
		      lnTTint, lnTIndex, lcBStyle, lnBColor, lnBTheme, lnBTint, lnBIndex, lcDStyle, lnDColor, lnDTheme, lnDTint, lnDIndex, lnDiagDn, lnDiagUp)
		  Endfor
		  .SetLastId(tnWB, lnIdCnt, "xl_borders")
		
		*-*	Retreive the indexed color information
		  lcColors = .GetNodeElement(lcStyleSheet, 'colors', 1)
		  If !Empty(lcColors)
		    lcIndexedColors = .GetNodeElement(lcColors, 'indexedColors', 1)
		    If !Empty(lcIndexedColors)
		      lnNode = 1
		      lcRgbColor = .GetNodeElement(lcIndexedColors, 'rgbColor', lnNode)
		      Do While !Empty(lcRgbColor)
		        lcHexColor = .GetNodeAttributeValue(lcRgbColor, "rgb")
		
		        Insert Into xl_ndxcolors (workbook, indexid, rgbcolor) Values (tnWB, lnNode, lcHexColor)
		
		        lnNode = lnNode + 1
		        lcRgbColor = .GetNodeElement(lcIndexedColors, 'rgbColor', lnNode)
		      Enddo
		      .SetLastId(tnWB, lnNode-1, "xl_ndxcolors")
		    Endif
		
		    lcMruColors = .GetNodeElement(lcColors, 'mruColors', 1)
		    If !Empty(lcMruColors)
		      lnNode = 1
		      lcRgbColor = .GetNodeElement(lcMruColors, 'color', lnNode)
		      Do While !Empty(lcRgbColor)
		        lcHexColor = .GetNodeAttributeValue(lcRgbColor, "rgb")
		
		        Insert Into xl_mrucolors (workbook, indexid, rgbcolor) Values (tnWB, lnNode, lcHexColor)
		
		        lnNode = lnNode + 1
		        lcRgbColor = .GetNodeElement(lcMruColors, 'color', lnNode)
		      Enddo
		      .SetLastId(tnWB, lnNode-1, "xl_mrucolors")
		    Endif
		  Endif
		Endwith
		
	ENDPROC

	PROTECTED PROCEDURE removeworkingdirectories		&& Removes the working directories
		Lparameters tcDir
		Local llReturn, loException
		Try
		  llReturn = apiRemoveDirectory(tcDir) != 0
		
		Catch To loException
		  Set Step On
		  llReturn = False
		Endtry
		Return llReturn
		
	ENDPROC

	PROCEDURE renamesheet		&& Renames the selected sheet
		Lparameters tnWB, txSheet, tcSheetName
		Local llReturn
		llReturn = False
		Do Case
		Case Vartype(txSheet) = "C"
		  If Seek(BinToC(tnWB)+Upper(txSheet), "xl_sheets", "shname")
		    Replace xl_sheets.shname With tcSheetName In xl_sheets
		    llReturn = True
		  Endif
		
		Case Vartype(txSheet) = "N"
		  If Seek(BinToC(tnWB)+BinToC(txSheet), "xl_sheets", "sheetndx")
		    Replace xl_sheets.shname With tcSheetName In xl_sheets
		    llReturn = True
		  Endif
		Endcase
		Return llReturn
		
	ENDPROC

	PROCEDURE resetcolumnwidth		&& Resets the column width to default
		Lparameters tnWB, tnSheet, tnColumn
		If Seek(This.GetColWidthKeyExpr(tnWB, tnSheet, tnColumn), "xl_colwidths", "shcolumn")
		  Delete In xl_colwidths
		Endif
		
	ENDPROC

	PROTECTED PROCEDURE saveasutf8		&& Saves the file as a UTF-8
		Lparameters tcFileName
		Strtofile(Strconv(Filetostr(tcFileName), 9), tcFileName, 4)
		
	ENDPROC

	PROCEDURE savegridtoworkbook		&& Saves the selected grid to a workbook
		Lparameters toGrid, txWB, tlFreeze, tlSaveWB, tcSheetName, tlInclHiddenCols
		Local lcAlias, lnCol, lnWB, lnSh, lnRow, lcField, loReturn, loColumn, lnStyle, lnColCount, lnDefStyle
		Local Array laRowCount[1], laColOrder[1]
		loReturn = Createobject("Empty")
		AddProperty(loReturn, "Workbook",  0)
		AddProperty(loReturn, "Sheet", 0)
		With This
		  Do Case
		  Case Inlist(Pcount(), 0, 1)
		    Return loReturn
		
		  Case Pcount() = 2
		    tlFreeze     = True
		    tlSaveWB     = True
		    tcSheetName  = .DeriveSheetName(txWB)
		    tlInclHiddenCols = True
		
		  Case Pcount() = 3
		    tlSaveWB     = True
		    tcSheetName  = .DeriveSheetName(txWB)
		    tlInclHiddenCols = True
		
		  Case Pcount() = 4
		    tcSheetName  = .DeriveSheetName(txWB)
		    tlInclHiddenCols = True
		
		  Case Pcount() = 5
		    tlInclHiddenCols = True
		  Endcase
		  If Vartype(tcSheetName) != 'C' Or Empty(tcSheetName)
		    tcSheetName = .DeriveSheetName(txWB)
		  Endif
		  tcSheetName = Chrtran(tcSheetName, ":\/?*", "_____")
		  If Len(tcSheetName) > LIMITS_MAX_SH_NAME
		    If .AutoTrimSheetName
		      tcSheetName = Left(Alltrim(tcSheetName), LIMITS_MAX_SH_NAME)
		    Else
		      Return loReturn
		    Endif
		  Endif
		  If Vartype(toGrid) != "O" And Pemstatus(toGrid, "BaseClass", 5) And Lower(toGrid.BaseClass) != "grid"
		    Return loReturn
		  Endif
		  Do Case
		  Case Vartype(txWB) = "C"
		    lnWB = .CreateWorkbook(txWB)
		    If lnWB = 0
		      lnWB = .GetWorkbook(txWB)
		    Endif
		
		  Case Vartype(txWB) = "N"
		    If Seek(BinToC(txWB), "xl_workbooks", "workbook")
		      lnWB = txWB
		    Else
		      Return loReturn
		    Endif
		
		  Otherwise
		    Return loReturn
		  Endcase
		  If lnWB > 0
		    lnSh = .AddSheet(lnWB, tcSheetName)
		    If lnSh > 0
		      lcAlias = Juststem(toGrid.RecordSource)
		
		*-*		Get the record count and display a status window
		      Select Count(*) From &lcAlias Into Array laRowCount
		      Raiseevent(This, "OnShowStatusMessage", 3, 0, laRowCount[1])
		
		*-*		Get the number of columns to process and
		*-*		Get the column output order based on grid display order                       && Change requested by Matt Slay to output by grid display order and visible setting
		      If tlInclHiddenCols
		        lnColCount = toGrid.ColumnCount
		        Dimension laColOrder[lnColCount, 2]
		        For lnCol=1 To toGrid.ColumnCount
		          laColOrder[lnCol, 1] = toGrid.Columns(lnCol).ColumnOrder              && Grid display order
		          laColOrder[lnCol, 2] = lnCol                                          && Column property order
		        Endfor
		      Else
		        lnColCount = 0
		        For lnCol=1 To toGrid.ColumnCount
		          If toGrid.Columns(lnCol).Visible
		            lnColCount = lnColCount + 1
		            Dimension laColOrder[lnColCount, 2]
		            laColOrder[lnColCount, 1] = toGrid.Columns(lnCol).ColumnOrder     && Grid display order
		            laColOrder[lnColCount, 2] = lnCol                                 && Column property order
		          Endif
		        Endfor
		      Endif
		      If lnColCount = 0
		        Return False
		      Endif
		      Asort(laColOrder)
		
		*-*		Add the header row if defined and set the column widths; get the column font info
		      If toGrid.HeaderHeight > 0                                                    && Change recommendation by Doug Hennig (if no headers, start in first row)
		        lnRow = 1
		        For lnCol=1 To lnColCount
		          loColumn = toGrid.Columns(laColOrder[lnCol, 2])
		          .SetCellValue(lnWB, lnSh, 1, lnCol, loColumn.Header1.Caption)
		          .SetColumnWidth(lnWB, lnSh, lnCol, .ConvertPixelsToExcelUnits(loColumn.Width))
		        Endfor
		      Else
		        lnRow = 0
		        For lnCol=1 To lnColCount
		          loColumn = toGrid.Columns(laColOrder[lnCol, 2])
		          .SetColumnWidth(lnWB, lnSh, lnCol, .ConvertPixelsToExcelUnits(loColumn.Width))
		        Endfor
		      Endif
		
		*-*		Add the cell data values
		      Select (lcAlias)
		      Scan
		        lnRow = lnRow + 1
		        Raiseevent(This, "OnShowStatusMessage", 3, lnRow)
		        For lnCol=1 To lnColCount
		          loColumn = toGrid.Columns(laColOrder[lnCol, 2])
		          lcField  = loColumn.ControlSource
		          .SetCellValue(lnWB, lnSh, lnRow, lnCol, &lcField)
		        Endfor
		      Endscan
		
		*-*		Set the cell style formatting
		      lnDefStyle = .IsFormatStyleDefined(lnWB, .DefaultFont, .DefaultFontSize)
		      If Isnull(lnDefStyle)
		        lnDefStyle = .CreateFormatStyle(lnWB)
		        .AddStyleFont(lnWB, lnDefStyle, .DefaultFont, .DefaultFontSize)
		      Endif
		
		      For lnCol=1 To lnColCount
		        loColumn = toGrid.Columns(laColOrder[lnCol, 2])
		        lcField  = loColumn.ControlSource
		        If Vartype(&lcField) != DATA_TYPE_DATE
		          If .DefaultFont != loColumn.FontName Or .DefaultFontSize != loColumn.FontSize   && Change recommended by Doug Hennig; 2017-06-12
		            lnStyle = .IsFormatStyleDefined(lnWB, loColumn.FontName, loColumn.FontSize)
		            If Isnull(lnStyle)
		              lnStyle = .CreateFormatStyle(lnWB)
		              .AddStyleFont(lnWB, lnStyle, loColumn.FontName, loColumn.FontSize)
		            Endif
		          Else
		            lnStyle = lnDefStyle
		          Endif
		          .SetCellStyleRange(lnWB, lnSh, 1, lnCol, laRowCount[1]+1, lnCol, lnStyle)
		        Endif
		      Endfor
		
		*-*		Freeze the first row if specified
		      If tlFreeze
		        .FreezePanes(lnWB, lnSh, 1, 0)
		      Endif
		      Raiseevent(This, "OnShowStatusMessage", 3, -1)
		      If tlSaveWB
		        .SaveWorkbook(lnWB)
		      Endif
		      loReturn.Sheet    = lnSh
		      loReturn.Workbook = lnWB
		    Endif
		  Endif
		Endwith
		Return loReturn
		
	ENDPROC

	PROCEDURE savegridtoworkbookex		&& Saves the passed grid to a workbook without adding the content to the internal cursors
		Lparameters toGrid, tcFileName, tlFreeze, tcSheetName, tlInclHiddenCols
		Local llError, lcTempPath, lcAlias, lcFileName, lhFile, lcRowDefHt, lnCol, lnRow, lcSETCentury, lxCellValue
		Local lnColCount, lnColWidth, lcCurAlias
		Local Array laColOrder[1], laSheetNames[1]
		llError    = False
		lcCurAlias = Alias()
		If Vartype(toGrid) != "O" And Pemstatus(toGrid, "BaseClass", 5) And Lower(toGrid.BaseClass) != "grid"
		  Return False
		Endif
		With This
		  Do Case
		  Case Pcount() < 2
		    Return False
		
		  Case Pcount() = 2
		    tlFreeze     = True
		    tcSheetName  = toGrid.Name
		    tlInclHiddenCols = True
		
		  Case Pcount() = 3
		    tcSheetName  = toGrid.Name
		    tlInclHiddenCols = True
		
		  Case Pcount() = 4
		    tlInclHiddenCols = True
		  Endcase
		  If Vartype(tcSheetName) != 'C' Or Empty(tcSheetName)
		    tcSheetName = toGrid.Name
		  Endif
		  tcSheetName = Chrtran(tcSheetName, ":\/?*", "_____")
		  If Len(tcSheetName) > LIMITS_MAX_SH_NAME
		    If .AutoTrimSheetName
		      tcSheetName = Left(Alltrim(tcSheetName), LIMITS_MAX_SH_NAME)
		    Else
		      Return False
		    Endif
		  Endif
		
		*-* Set temporary output path
		  lcTempPath = .CreateWorkingDirectories()
		  If Isnull(lcTempPath)
		    Return False
		  Endif
		
		*-*	Save current settings and then set to US formats
		  lcSetPoint  = Set("POINT")
		  lcSeparator = Set("SEPARATOR")
		  If lcSetPoint != "."
		    Set Point To "."
		    Set Separator To ","
		  Endif
		
		*-*	Output the workbook
		  lcAlias = Juststem(toGrid.RecordSource)
		
		*-*	Get the number of columns to process
		*-*	Get the column output order based on grid display order                          && Change requested by Matt Slay to output by grid display order and visible setting
		  If tlInclHiddenCols
		    lnColCount = toGrid.ColumnCount
		    Dimension laColOrder[lnColCount, 2]
		    For lnCol=1 To toGrid.ColumnCount
		      laColOrder[lnCol, 1] = toGrid.Columns(lnCol).ColumnOrder                     && Grid display order
		      laColOrder[lnCol, 2] = lnCol                                                 && Column property order
		    Endfor
		  Else
		    lnColCount = 0
		    For lnCol=1 To toGrid.ColumnCount
		      If toGrid.Columns(lnCol).Visible
		        lnColCount = lnColCount + 1
		        Dimension laColOrder[lnColCount, 2]
		        laColOrder[lnColCount, 1] = toGrid.Columns(lnCol).ColumnOrder             && Grid display order
		        laColOrder[lnColCount, 2] = lnCol                                         && Column property order
		      Endif
		    Endfor
		  Endif
		  If lnColCount = 0
		    Return False
		  Endif
		  Asort(laColOrder)
		
		  Dimension laSheetNames[1]
		  laSheetNames[1] = tcSheetName
		  If .WriteDirectXMLs(lcTempPath, @laSheetNames)
		*-*	Write the sheet XML
		    Try
		      lcFileName = lcTempPath + "xl\worksheets\sheet1.xml"
		      lhFile = Fcreate(lcFileName)
		      If lhFile < 0
		        Throw
		      Endif
		
		*-*		Write sheet XML header information
		      Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		      Fwrite(lhFile, '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"')
		      Fwrite(lhFile, ' xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"')
		      Fwrite(lhFile, ' xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac"')
		      Fwrite(lhFile, ' xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">')
		
		*-*		Write the sheet view information which includes the freeze pane information
		      Fwrite(lhFile, '<dimension ref="A1:' + .ColumnIndexToAscii(lnColCount) + Transform(Reccount(lcAlias)+1) + '"/>')
		      If tlFreeze
		        Fwrite(lhFile, '<sheetViews><sheetView workbookViewId="0">')
		        Fwrite(lhFile, '<pane state="frozenSplit" activePane="bottomLeft" topLeftCell="A2" ySplit="1"/>')
		        Fwrite(lhFile, '<selection activeCell="A2" sqref="A2" pane="bottomLeft"/>')
		        Fwrite(lhFile, '</sheetView></sheetViews>')
		      Endif
		      Fwrite(lhFile, '<sheetFormatPr defaultRowHeight="15"/>')
		
		*-*		Write sheet Column widths
		      Fwrite(lhFile, '<cols>')
		      For lnCol=1 To lnColCount
		        lnColWidth = .ConvertPixelsToExcelUnits(toGrid.Columns(laColOrder[lnCol, 2]).Width)
		        Fwrite(lhFile, '<col min="' + Transform(lnCol) + '" max="' + Transform(lnCol) + '" width="' + Transform(lnColWidth+0.7109375) + '" customWidth="1"/>')
		      Endfor
		      Fwrite(lhFile, '</cols>')
		
		*-*		Write sheet cell data values
		      lcRowDefHt = ' ht="30"'
		      Fwrite(lhFile, '<sheetData>')
		
		*-*		Place field names in the first row
		      If toGrid.HeaderHeight > 0                                               && Change recommendation by Doug Hennig (if no headers, then no output)
		        Fwrite(lhFile, '<row r="1" spans="1:' + Transform(lnColCount) + '"' + lcRowDefHt + '>')
		        If .DefaultFont = "Calibri" And .DefaultFontSize = 11
		          For lnCol=1 To lnColCount
		            .WriteAsInLineString(lhFile, 1, lnCol, toGrid.Columns(laColOrder[lnCol, 2]).Header1.Caption)
		          Endfor
		        Else
		          For lnCol=1 To lnColCount
		            .WriteAsInLineFormattedString(lhFile, 1, lnCol, toGrid.Columns(laColOrder[lnCol, 2]).Header1.Caption)
		          Endfor
		        Endif
		        Fwrite(lhFile, '</row>')
		        lnRow = 1
		      Else
		        lnRow = 0
		      Endif
		
		*-*		Write the grid field values to cells
		      lcSETCentury = Set("CENTURY")
		      Set Century On
		      Select (lcAlias)
		      If .DefaultFont = "Calibri" And .DefaultFontSize = 11
		        Scan
		          lnRow = lnRow + 1
		          Fwrite(lhFile, '<row r="' + Transform(lnRow) + '" spans="1:' + Transform(lnColCount) + '"' + lcRowDefHt + '>')
		          For lnCol=1 To lnColCount
		            lxCellValue = Evaluate(toGrid.Columns(laColOrder[lnCol, 2]).ControlSource)
		            .WriteDirectCellValue(lhFile, lnRow, lnCol, lxCellValue)
		          Endfor
		          Fwrite(lhFile, '</row>')
		        Endscan
		      Else
		        Scan
		          lnRow = lnRow + 1
		          Fwrite(lhFile, '<row r="' + Transform(lnRow) + '" spans="1:' + Transform(lnColCount) + '"' + lcRowDefHt + '>')
		          For lnCol=1 To lnColCount
		            lxCellValue = Evaluate(toGrid.Columns(laColOrder[lnCol, 2]).ControlSource)
		            .WriteDirectCellFormattedValue(lhFile, lnRow, lnCol, lxCellValue)
		          Endfor
		          Fwrite(lhFile, '</row>')
		        Endscan
		      Endif
		      Set Century &lcSETCentury
		
		*-*		End the sheet cell data values and worksheet
		      Fwrite(lhFile, '</sheetData>')
		      Fwrite(lhFile, '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>')
		      Fwrite(lhFile, '</worksheet>')
		
		    Catch To loException
		      Set Step On
		      llError = True
		      .ErrorLevelId = 14
		      Raiseevent(This, "OnShowErrorMessage", 14, loException.Message)
		
		    Finally
		      Fclose(lhFile)
		      .SaveAsUTF8(lcFileName)
		    Endtry
		    If llError
		      llSuccess = False
		    Else
		      llSuccess = .CreateExcelFile(lcTempPath, Justpath(tcFileName), Juststem(tcFileName))    && Change recommendation by Doug Hennig [placement of code after ELSE]
		    Endif
		    .RemoveWorkingDirectories(lcTempPath)
		
		  Else
		    llSuccess = False
		  Endif
		  If !Empty(lcCurAlias)
		    Select (lcCurAlias)
		  Endif
		
		*-*	Restore default settings
		  If lcSetPoint != "."
		    Set Point To (lcSetPoint)
		    Set Separator To (lcSeparator)
		  Endif
		Endwith
		Return llSuccess
		
	ENDPROC

	PROCEDURE savemultigridtoworkbookex		&& Same as SaveGridToWorkbookEx() method but handles multiple grids being passed
		Lparameters toGrids, tcFileName
		Local llError, lcTempPath, lcAlias, lcFileName, lhFile, lcRowDefHt, lnCol, lnRow, lcSETCentury, lxCellValue
		Local lnColCount, lnColWidth, lcCurAlias, lnGrid, loGrid, loException, lcSheetName
		Local Array laColOrder[1], laSheetNames[1]
		llError    = False
		lcCurAlias = Alias()
		If Pcount() < 2
		  Return False
		Endif
		With This
		  If Vartype(toGrids) = "O"
		    If Pemstatus(toGrids, "Count", 5) And Vartype(toGrids.Count) != "N"
		      Return False
		    Else
		      If toGrids.Count < 1
		        Return False
		      Endif
		    Endif
		
		    If Pemstatus(toGrids, "List", 5)
		      llError = False
		      Try
		        If Alen(toGrids.List, 2) != 4   && Column 1 Grid; Column 2  SheetName; Column 3 Freeze indicator, Column 4 HiddenCols indicator
		          Throw
		        Endif
		      Catch To loException
		        llError = True
		      Endtry
		      If llError
		        Return False
		      Endif
		      For lnGrid=1 To toGrids.Count
		*-*			Validate grid object
		        loGrid = toGrids.List[lnGrid, 1]
		        If Vartype(loGrid) != "O" And Pemstatus(loGrid, "BaseClass", 5) And Lower(loGrid.BaseClass) != "grid"
		          Return False
		        Endif
		*-*			Validate sheet name
		        lcSheetName = toGrids.List[lnGrid, 2]
		        If Vartype(lcSheetName) != 'C' Or Empty(lcSheetName)
		          lcSheetName = loGrid.Name
		        Endif
		        lcSheetName = Chrtran(lcSheetName, ":\/?*", "_____")
		        If Len(lcSheetName) > LIMITS_MAX_SH_NAME
		          If .AutoTrimSheetName
		            lcSheetName = Left(Alltrim(lcSheetName), LIMITS_MAX_SH_NAME)
		          Else
		            Return False
		          Endif
		        Endif
		        toGrids.List[lnGrid, 2] = lcSheetName
		*-*			Validate freeze indicator
		        If Vartype(toGrids.List[lnGrid, 3]) != 'L'
		          toGrids.List[lnGrid, 3] = False
		        Endif
		*-*			Validate hidden column indicator
		        If Vartype(toGrids.List[lnGrid, 4]) != 'L'
		          toGrids.List[lnGrid, 4] = False
		        Endif
		      Endfor
		    Endif
		  Else
		    Return False
		  Endif
		
		*-* Set temporary output path
		  lcTempPath = .CreateWorkingDirectories()
		  If Isnull(lcTempPath)
		    Return False
		  Endif
		
		*-*	Save current settings and then set to US formats
		  lcSetPoint  = Set("POINT")
		  lcSeparator = Set("SEPARATOR")
		  If lcSetPoint != "."
		    Set Point To "."
		    Set Separator To ","
		  Endif
		
		*-*	Output the workbook
		  Dimension laSheetNames[toGrids.Count]
		  For lnGrid=1 To toGrids.Count
		    laSheetNames[lnGrid] = toGrids.List[lnGrid, 2]
		  Endfor
		  If !.WriteDirectXMLs(lcTempPath, @laSheetNames)
		    Return False
		  Endif
		
		*-*	Write the sheet xml for each grid
		  For lnGrid=1 To toGrids.Count
		    loGrid  = toGrids.List[lnGrid, 1]
		    lcAlias = Juststem(loGrid.RecordSource)
		
		*-*	Get the number of columns to process
		*-*	Get the column output order based on grid display order       && Change requested by Matt Slay to output by grid display order and visible setting
		    If toGrids.List[lnGrid, 4]
		      lnColCount = loGrid.ColumnCount
		      Dimension laColOrder[lnColCount, 2]
		      For lnCol=1 To loGrid.ColumnCount
		        laColOrder[lnCol, 1] = loGrid.Columns(lnCol).ColumnOrder     && Grid display order
		        laColOrder[lnCol, 2] = lnCol                                 && Column property order
		      Endfor
		    Else
		      lnColCount = 0
		      For lnCol=1 To loGrid.ColumnCount
		        If loGrid.Columns(lnCol).Visible
		          lnColCount = lnColCount + 1
		          Dimension laColOrder[lnColCount, 2]
		          laColOrder[lnColCount, 1] = loGrid.Columns(lnCol).ColumnOrder   && Grid display order
		          laColOrder[lnColCount, 2] = lnCol                        && Column property order
		        Endif
		      Endfor
		    Endif
		    If lnColCount = 0
		      Return False
		    Endif
		    Asort(laColOrder)
		
		    Try
		      lcFileName = lcTempPath + "xl\worksheets\sheet" + Transform(lnGrid) + ".xml"
		      lhFile = Fcreate(lcFileName)
		      If lhFile < 0
		        Throw
		      Endif
		
		*-*		Write sheet XML header information
		      Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		      Fwrite(lhFile, '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"')
		      Fwrite(lhFile, ' xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"')
		      Fwrite(lhFile, ' xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac"')
		      Fwrite(lhFile, ' xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">')
		
		*-*		Write the sheet view information which includes the freeze pane information
		      Fwrite(lhFile, '<dimension ref="A1:' + .ColumnIndexToAscii(lnColCount) + Transform(Reccount(lcAlias)+1) + '"/>')
		      If toGrids.List[lnGrid, 3]
		        Fwrite(lhFile, '<sheetViews><sheetView workbookViewId="0">')
		        Fwrite(lhFile, '<pane state="frozenSplit" activePane="bottomLeft" topLeftCell="A2" ySplit="1"/>')
		        Fwrite(lhFile, '<selection activeCell="A2" sqref="A2" pane="bottomLeft"/>')
		        Fwrite(lhFile, '</sheetView></sheetViews>')
		      Endif
		      Fwrite(lhFile, '<sheetFormatPr defaultRowHeight="15"/>')
		
		*-*		Write sheet Column widths
		      Fwrite(lhFile, '<cols>')
		      For lnCol=1 To lnColCount
		        lnColWidth = .ConvertPixelsToExcelUnits(loGrid.Columns(laColOrder[lnCol, 2]).Width)
		        Fwrite(lhFile, '<col min="' + Transform(lnCol) + '" max="' + Transform(lnCol) + '" width="' + Transform(lnColWidth+0.7109375) + '" customWidth="1"/>')
		      Endfor
		      Fwrite(lhFile, '</cols>')
		
		*-*		Write sheet cell data values
		      lcRowDefHt = ' ht="30"'
		      Fwrite(lhFile, '<sheetData>')
		
		*-*		Place field names in the first row
		      If loGrid.HeaderHeight > 0                                   && Change recommendation by Doug Hennig (if no headers, then no output)
		        Fwrite(lhFile, '<row r="1" spans="1:' + Transform(lnColCount) + '"' + lcRowDefHt + '>')
		        If .DefaultFont = "Calibri" And .DefaultFontSize = 11
		          For lnCol=1 To lnColCount
		            .WriteAsInLineString(lhFile, 1, lnCol, loGrid.Columns(laColOrder[lnCol, 2]).Header1.Caption)
		          Endfor
		        Else
		          For lnCol=1 To lnColCount
		            .WriteAsInLineFormattedString(lhFile, 1, lnCol, loGrid.Columns(laColOrder[lnCol, 2]).Header1.Caption)
		          Endfor
		        Endif
		        Fwrite(lhFile, '</row>')
		        lnRow = 1
		      Else
		        lnRow = 0
		      Endif
		
		*-*		Write the grid field values to cells
		      lcSETCentury = Set("CENTURY")
		      Set Century On
		      Select (lcAlias)
		      If .DefaultFont = "Calibri" And .DefaultFontSize = 11
		        Scan
		          lnRow = lnRow + 1
		          Fwrite(lhFile, '<row r="' + Transform(lnRow) + '" spans="1:' + Transform(lnColCount) + '"' + lcRowDefHt + '>')
		          For lnCol=1 To lnColCount
		            lxCellValue = Evaluate(loGrid.Columns(laColOrder[lnCol, 2]).ControlSource)
		            .WriteDirectCellValue(lhFile, lnRow, lnCol, lxCellValue)
		          Endfor
		          Fwrite(lhFile, '</row>')
		        Endscan
		      Else
		        Scan
		          lnRow = lnRow + 1
		          Fwrite(lhFile, '<row r="' + Transform(lnRow) + '" spans="1:' + Transform(lnColCount) + '"' + lcRowDefHt + '>')
		          For lnCol=1 To lnColCount
		            lxCellValue = Evaluate(loGrid.Columns(laColOrder[lnCol, 2]).ControlSource)
		            .WriteDirectCellFormattedValue(lhFile, lnRow, lnCol, lxCellValue)
		          Endfor
		          Fwrite(lhFile, '</row>')
		        Endscan
		      Endif
		      Set Century &lcSETCentury
		
		*-*		End the sheet cell data values and worksheet
		      Fwrite(lhFile, '</sheetData>')
		      Fwrite(lhFile, '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>')
		      Fwrite(lhFile, '</worksheet>')
		
		    Catch To loException
		      Set Step On
		      llError = True
		      .ErrorLevelId = 14
		      Raiseevent(This, "OnShowErrorMessage", 14, loException.Message)
		
		    Finally
		      Fclose(lhFile)
		      .SaveAsUTF8(lcFileName)
		    Endtry
		  Endfor
		  If llError
		    llSuccess = False
		  Else
		    llSuccess = .CreateExcelFile(lcTempPath, Justpath(tcFileName), Juststem(tcFileName))   && Change recommendation by Doug Hennig [placement of code after ELSE]
		  Endif
		*-*	Cleanup
		  .RemoveWorkingDirectories(lcTempPath)
		  If !Empty(lcCurAlias)
		    Select (lcCurAlias)
		  Endif
		
		*-*	Restore default settings
		  If lcSetPoint != "."
		    Set Point To (lcSetPoint)
		    Set Separator To (lcSeparator)
		  Endif
		Endwith
		Return llSuccess
		
	ENDPROC

	PROCEDURE savetabletoworkbook		&& Saves the table passed (alias) as a workbook sheet
		Lparameters tcAlias, tnWB, tlFreeze, tlSaveWB, tcSheetName
		Local lcAlias, lnCol, lnWB, lnSh, lnRow, lcField, lnFldCnt, llError, llOpenedTbl, loException, lcCurAlias, loReturn
		Local lnNdx, lcCaption
		Local Array laFields[1], laRowCount[1]
		loReturn = Createobject("Empty")
		AddProperty(loReturn, "Workbook",  0)
		AddProperty(loReturn, "Sheet", 0)
		Do Case
		Case Pcount() < 2
		  Return loReturn
		
		Case Pcount() = 2
		  tlFreeze = True
		  tlSaveWB = False
		  tcSheetName = Juststem(tcAlias)
		
		Case Pcount() = 3
		  tlSaveWB = False
		  tcSheetName = Juststem(tcAlias)
		
		Case Pcount() = 4
		  tcSheetName = Juststem(tcAlias)
		Endcase
		If Vartype(tcSheetName) != 'C' Or Empty(tcSheetName)
		  tcSheetName = This.DeriveSheetName(tnWB)
		Endif
		tcSheetName = Chrtran(tcSheetName, ":\/?*", "_____")
		If Len(tcSheetName) > LIMITS_MAX_SH_NAME
		  If This.AutoTrimSheetName
		    tcSheetName = Left(Alltrim(tcSheetName), LIMITS_MAX_SH_NAME)
		  Else
		    Return loReturn
		  Endif
		Endif
		Do Case
		Case Used(tcAlias)
		  lcCurAlias  = Alias()
		  llOpenedTbl = False
		  lcAlias = tcAlias
		
		Case Occurs("\", tcAlias) > 0
		  Try
		    lcAlias = Juststem(tcAlias)
		    Use (tcAlias) In 0 Alias (lcAlias) Shared
		    llOpenedTbl = True
		
		  Catch To loException
		    llError = True
		  Endtry
		  If llError
		    Return loReturn
		  Endif
		
		Otherwise
		  Return loReturn
		Endcase
		Do Case
		Case Vartype(tnWB) = "C"
		  lnWB = This.CreateWorkbook(tnWB)
		  If lnWB = 0
		    lnWB = This.GetWorkbook(tnWB)
		  Endif
		
		Case Vartype(tnWB) = "N"
		  If Seek(BinToC(tnWB), "xl_workbooks", "workbook")
		    lnWB = tnWB
		  Else
		    Return loReturn
		  Endif
		
		Otherwise
		  Return loReturn
		Endcase
		If lnWB > 0
		  lnSh = This.AddSheet(lnWB, tcSheetName)
		  If lnSh > 0
		*-*		Get the record count and display a status window
		    Select Count(*) From &lcAlias Into Array laRowCount
		    Raiseevent(This, "OnShowStatusMessage", 3, 0, laRowCount[1])
		
		    Select (lcAlias)
		    lnFldCnt = Afields(laFields, lcAlias)
		    For lnNdx=1 To lnFldCnt
		      Try
		        lcCaption = DBGetProp(lcAlias + "." + laFields[lnNdx, 1], "FIELD", "CAPTION")
		        laFields[lnNdx, 3] = Iif(Empty(lcCaption), laFields[lnNdx, 1], lcCaption)
		
		      Catch To loException
		        laFields[lnNdx, 3] = laFields[lnNdx, 1]
		      Endtry
		    Endfor
		
		*-*		Place field names in the first row
		    For lnCol=1 To lnFldCnt
		      This.SetCellValue(lnWB, lnSh, 1, lnCol, laFields[lnCol, 3])
		    Endfor
		*-*		Populate next rows with data
		    lnRow = 0
		    Scan
		      lnRow = lnRow + 1
		      Raiseevent(This, "OnShowStatusMessage", 3, lnRow)
		      For lnCol=1 To lnFldCnt
		        If laFields[lnCol, 2] = "G"
		          This.SetCellValue(lnWB, lnSh, 1 + lnRow, lnCol, "General")
		        Else
		          This.SetCellValue(lnWB, lnSh, 1 + lnRow, lnCol, Evaluate(lcAlias + '.' + laFields[lnCol, 1]))
		        Endif
		      Endfor
		    Endscan
		
		    If tlFreeze
		      This.FreezePanes(lnWB, lnSh, 1, 0)
		    Endif
		    Raiseevent(This, "OnShowStatusMessage", 3, -1)
		    If tlSaveWB
		      This.SaveWorkbook(lnWB)
		    Endif
		  Else
		    lnWB = 0
		    lnSh = 0
		  Endif
		Else
		  lnSh = 0
		  lnWB = 0
		Endif
		If llOpenedTbl
		  Use In &lcAlias
		Else
		  lnSh = 0
		  lnWB = 0
		  If !Empty(lcCurAlias)
		    Select &lcCurAlias
		  Endif
		Endif
		loReturn.Sheet    = lnSh
		loReturn.Workbook = lnWB
		Return loReturn
		
	ENDPROC

	PROCEDURE savetabletoworkbookex		&& Creates a new workbook from a table; direct write to XLSX file without loading internal cursors
		Lparameters tcAlias, tcXlsxName, taFields, tlFreeze, tcSheetName
		Local lcCurAlias, llOpenedTbl, lcAlias, llError, loException, lhFile, lnCol, lcRowDefHt
		Local lnFldCnt, lnRow, lxCellValue, lcTempPath, lcFileName, lcSETCentry, lcCaption, llSuccess, lcSetPoint
		Local lcSeparator
		Local Array laSheetNames[1]
		External Array taFields
		llError = False
		Do Case
		Case Pcount() < 2
		  Return False
		
		Case Pcount() = 2
		  Dimension taFields[1, 2]
		  taFields[1, 1] = Null
		  tlFreeze       = True
		  tcSheetName    = Juststem(tcAlias)
		
		Case Pcount() = 3
		  tlFreeze    = True
		  tcSheetName = Juststem(tcAlias)
		
		Case Pcount() = 4
		  tcSheetName = Juststem(tcAlias)
		Endcase
		If Vartype(tcSheetName) != 'C' Or Empty(tcSheetName)
		  tcSheetName = Juststem(tcAlias)
		Endif
		tcSheetName = Chrtran(tcSheetName, ":\/?*", "_____")
		If Len(tcSheetName) > LIMITS_MAX_SH_NAME
		  If This.AutoTrimSheetName
		    tcSheetName = Left(Alltrim(tcSheetName), LIMITS_MAX_SH_NAME)
		  Else
		    Return False
		  Endif
		Endif
		lcCurAlias = Alias()
		lcAlias    = Juststem(tcAlias)
		Do Case
		Case Used(lcAlias)
		  llOpenedTbl = False
		
		Case Occurs("\", tcAlias) > 0
		  Try
		    Use (tcAlias) In 0 Alias (lcAlias) Shared
		    llOpenedTbl = True
		
		  Catch To loException
		    llError = True
		  Endtry
		  If llError
		    Return False
		  Endif
		
		Otherwise
		  Return False
		Endcase
		*-*	Get the table fields to export if not passed as a parameter
		Select (lcAlias)
		If Isnull(taFields) Or Empty(taFields[1])
		  Dimension taFields[1, 5]
		  taFields = ""
		  lnFldCnt = Afields(taFields, lcAlias)
		  For lnCol=1 To lnFldCnt
		    Try
		      lcCaption = DBGetProp(lcAlias + "." + taFields[lnCol, 1], "FIELD", "CAPTION")
		      taFields[lnCol, 2] = Iif(Empty(lcCaption), taFields[lnCol, 1], lcCaption)
		
		    Catch To loException
		      taFields[lnCol, 2] = taFields[lnCol, 1]
		    Endtry
		  Endfor
		Else
		  lnFldCnt = Alen(taFields, 1)
		  If Alen(taFields, 2) < 2 Or Vartype(taFields[1, 2]) != "C"
		    Return False
		  Endif
		Endif
		
		*-* Set temporary output path
		lcTempPath = This.CreateWorkingDirectories()
		If Isnull(lcTempPath)
		  Return False
		Endif
		
		*-*	Save current settings and then set to US formats
		lcSetPoint  = Set("POINT")
		lcSeparator = Set("SEPARATOR")
		If lcSetPoint != "."
		  Set Point To "."
		  Set Separator To ","
		Endif
		
		Dimension laSheetNames[1]
		laSheetNames[1] = tcSheetName
		If This.WriteDirectXMLs(lcTempPath, @laSheetNames)
		*-*	Write the sheet XML
		  Try
		    lcFileName = lcTempPath + "xl\worksheets\sheet1.xml"
		    lhFile = Fcreate(lcFileName)
		    If lhFile < 0
		      Throw
		    Endif
		
		*-*		Write sheet XML header information
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"')
		    Fwrite(lhFile, ' xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"')
		    Fwrite(lhFile, ' xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac"')
		    Fwrite(lhFile, ' xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">')
		
		*-*		Write the sheet view information which includes the freeze pane information
		    Fwrite(lhFile, '<dimension ref="A1:' + This.ColumnIndexToAscii(lnFldCnt) + Transform(Reccount(lcAlias)+1) + '"/>')
		    If tlFreeze
		      Fwrite(lhFile, '<sheetViews><sheetView workbookViewId="0">')
		      Fwrite(lhFile, '<pane state="frozenSplit" activePane="bottomLeft" topLeftCell="A2" ySplit="1"/>')
		      Fwrite(lhFile, '<selection activeCell="A2" sqref="A2" pane="bottomLeft"/>')
		    Endif
		    Fwrite(lhFile, '</sheetView></sheetViews>')
		    Fwrite(lhFile, '<sheetFormatPr defaultRowHeight="15"/>')
		
		*-*		Write sheet cell data values
		    Fwrite(lhFile, '<sheetData>')
		
		*-*		Place field names in the first row
		    lcRowDefHt = ' ht="30"'
		    Fwrite(lhFile, '<row r="1" spans="1:' + Transform(lnFldCnt) + '"' + lcRowDefHt + '>')
		    If This.DefaultFont = "Calibri" And This.DefaultFontSize = 11
		      For lnCol=1 To lnFldCnt
		        This.WriteAsInLineString(lhFile, 1, lnCol, taFields[lnCol, 2])
		      Endfor
		    Else
		      For lnCol=1 To lnFldCnt
		        This.WriteAsInLineFormattedString(lhFile, 1, lnCol, taFields[lnCol, 2])
		      Endfor
		    Endif
		    Fwrite(lhFile, '</row>')
		
		*-*		Write the table field values to cells
		    lcSETCentry = Set("CENTURY")
		    Set Century On
		    lnRow = 1
		    If This.DefaultFont = "Calibri" And This.DefaultFontSize = 11
		      Scan
		        lnRow = lnRow + 1
		        Fwrite(lhFile, '<row r="' + Transform(lnRow) + '" spans="1:' + Transform(lnFldCnt) + '"' + lcRowDefHt + '>')
		        For lnCol=1 To lnFldCnt
		          lxCellValue = Evaluate(lcAlias + '.' + taFields[lnCol, 1])
		          This.WriteDirectCellValue(lhFile, lnRow, lnCol, lxCellValue)
		        Endfor
		        Fwrite(lhFile, '</row>')
		      Endscan
		    Else
		      Scan
		        lnRow = lnRow + 1
		        Fwrite(lhFile, '<row r="' + Transform(lnRow) + '" spans="1:' + Transform(lnFldCnt) + '"' + lcRowDefHt + '>')
		        For lnCol=1 To lnFldCnt
		          lxCellValue = Evaluate(lcAlias + '.' + taFields[lnCol, 1])
		          This.WriteDirectCellFormattedValue(lhFile, lnRow, lnCol, lxCellValue)
		        Endfor
		        Fwrite(lhFile, '</row>')
		      Endscan
		    Endif
		    Set Century &lcSETCentry
		
		*-*		End the sheet cell data values and worksheet
		    Fwrite(lhFile, '</sheetData>')
		    Fwrite(lhFile, '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>')
		    Fwrite(lhFile, '</worksheet>')
		
		  Catch To loException
		    Set Step On
		    llError = True
		    This.ErrorLevelId = 14
		    Raiseevent(This, "OnShowErrorMessage", 14, loException.Message)
		
		  Finally
		    Fclose(lhFile)
		    This.SaveAsUTF8(lcFileName)
		  Endtry
		  If llError
		    llSuccess = False
		  Else
		*-*		Create the XLSX file
		    llSuccess = This.CreateExcelFile(lcTempPath, Justpath(tcXlsxName), Juststem(tcXlsxName))    && Change recommendation by Doug Hennig [placement of code after ELSE]
		  Endif
		  This.RemoveWorkingDirectories(lcTempPath)
		Else
		  llSuccess = False
		Endif
		If !Empty(lcCurAlias)
		  Select (lcCurAlias)
		Endif
		
		*-*	Restore default settings
		If lcSetPoint != "."
		  Set Point To (lcSetPoint)
		  Set Separator To (lcSeparator)
		Endif
		Return llSuccess
		
	ENDPROC

	PROCEDURE saveworkbook		&& Saves the selected workbook as an XLSX file
		Lparameters tnWB
		Local lcTempPath, lnSheet, lcDeleted, lcSetPoint, lcSeparator, lcSetDeleted, llReturn, lcAlias
		Local lcSafety, lnTotStages
		If Seek(BinToC(tnWB), "xl_workbooks", "workbook")
		  llReturn     = True
		  lcAlias      = Alias()
		  lcSafety     = Set("SAFETY")
		  lcSetDeleted = Set("DELETED")
		  lcSetPoint   = Set("POINT")
		  lcSeparator  = Set("SEPARATOR")
		  Set Safety Off
		  Set Point To "."
		  Set Separator To ","
		  Set Deleted On
		
		*-*	Write the XLSX Workbook to XML structures
		  lcTempPath = This.CreateWorkingDirectories()
		  If Isnull(lcTempPath)
		    llReturn = False
		  Else
		    Select xl_sheets
		    Count For workbook = tnWB And !shdeleted To lnTotStages
		    lnTotStages = lnTotStages + 5
		    Raiseevent(This, "OnShowStatusMessage", 2, 0, lnTotStages)
		
		    If This.WriteStringsXML(tnWB, lcTempPath) ;
		        AND This.WriteSupportXMLs(tnWB, lcTempPath) ;
		        AND This.WriteStylesXML(tnWB, lcTempPath) ;
		        AND This.WriteWorkbookXML(tnWB, lcTempPath) ;
		        AND This.WriteRelationshipsXML(tnWB, lcTempPath)
		
		      lnSheet = 0
		      Select xl_sheets
		      Set Order To Tag Sheet
		      Scan For workbook = tnWB And !shdeleted
		        lnSheet = lnSheet + 1
		        Raiseevent(This, "OnShowStatusMessage", 2, lnSheet+5)
		        If !This.WriteSheetXMLs(tnWB, xl_sheets.Sheet, lcTempPath)
		          llReturn = False
		          Exit
		        Endif
		      Endscan
		      Select xl_sheets
		      Set Order To
		
		      If llReturn And Seek(BinToC(tnWB), "xl_workbooks", "workbook")
		        llReturn = This.CreateExcelFile(lcTempPath, xl_workbooks.filepath, xl_workbooks.wbname)
		      Endif
		    Else
		      llReturn = False
		    Endif
		    This.RemoveWorkingDirectories(lcTempPath)
		    Raiseevent(This, "OnShowStatusMessage", 2, -1)
		  Endif
		
		  Set Safety &lcSafety
		  Set Deleted &lcSetDeleted
		  Set Point To (lcSetPoint)
		  Set Separator To (lcSeparator)
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Else
		  llReturn = False
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE saveworkbookas		&& Saves the selected workbook with the new name
		Lparameters tnWB, tcWBName
		Local lcName, lcPath
		If Seek(BinToC(tnWB), "xl_workbooks", "workbook") And !Empty(tcWBName)
		  lcName = Juststem(tcWBName)
		  lcPath = Justpath(tcWBName)
		  If Empty(lcPath)
		    lcPath = Sys(5) + Sys(2003)
		  Endif
		  Replace xl_workbooks.wbname   With lcName, ;
		    xl_workbooks.filepath With lcPath In xl_workbooks
		  This.SaveWorkbook(tnWB)
		Endif
		
	ENDPROC

	PROCEDURE setcellalignment		&& Sets the cell horizontal and vertical alignments
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tcHorizAlign, tcVertAlign
		Local llReturn, lnCellXfsId, lcAlias
		With This
		  If Pcount() < 4 Or .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  lcAlias = Alias()
		  If .GetSheetRecord(tnWB, tnSheet)
		    Do Case
		    Case Vartype(tcHorizAlign) = 'C' And Vartype(tcVertAlign) = 'C'
		      If Inlist(tcHorizAlign, CELL_HORIZ_ALIGN_LEFT, CELL_HORIZ_ALIGN_RIGHT, CELL_HORIZ_ALIGN_CENTER) And ;
		          INLIST(tcVertAlign, CELL_VERT_ALIGN_TOP, CELL_VERT_ALIGN_BOTTOM, CELL_VERT_ALIGN_CENTER)
		
		        If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		          If xl_cells.cellxfs > 0 And .GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		            lnCellXfsId = xl_cellxfs.Id
		            Select workbook From xl_cells Where workbook = tnWB And cellxfs = lnCellXfsId Into Cursor xl_temp
		            If _Tally > 1
		              lnCellXfsId = .GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontId, xl_cellxfs.fillId, xl_cellxfs.borderId, tcHorizAlign, tcVertAlign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.Rotation)
		            Else
		              Replace xl_cellxfs.halign With tcHorizAlign, ;
		                xl_cellxfs.valign With tcVertAlign In xl_cellxfs
		            Endif
		            Use In Select('xl_temp')
		          Else
		            lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, 0, 0, tcHorizAlign, tcVertAlign, 0, 0, 0)
		          Endif
		          Replace xl_cells.cellxfs With lnCellXfsId In xl_cells
		        Else
		          lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, 0, 0, tcHorizAlign, tcVertAlign, 0, 0, 0)
		          Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted) ;
		            VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False)
		          This.SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		        Endif
		        llReturn = True
		      Else
		        llReturn = False
		      Endif
		
		    Case Vartype(tcHorizAlign) = 'C' And Vartype(tcVertAlign) != 'C'
		      If Inlist(tcHorizAlign, CELL_HORIZ_ALIGN_LEFT, CELL_HORIZ_ALIGN_RIGHT, CELL_HORIZ_ALIGN_CENTER)
		        If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		          If xl_cells.cellxfs > 0 And This.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		            lnCellXfsId = xl_cellxfs.Id
		            Select workbook From xl_cells Where workbook = tnWB And cellxfs = lnCellXfsId Into Cursor xl_temp
		            If _Tally > 1
		              lnCellXfsId = .GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontId, xl_cellxfs.fillId, xl_cellxfs.borderId, tcHorizAlign, "", xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.Rotation)
		            Else
		              Replace xl_cellxfs.halign With tcHorizAlign, ;
		                xl_cellxfs.valign With "" In xl_cellxfs
		            Endif
		            Use In Select('xl_temp')
		          Else
		            lnCellXfsId = This.GetCellXfsId(tnWB, 0, 0, 0, 0, tcHorizAlign, "", 0, 0, 0)
		          Endif
		          Replace xl_cells.cellxfs With lnCellXfsId In xl_cells
		        Else
		          lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, 0, 0, tcHorizAlign, "", 0, 0, 0)
		          Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted) ;
		            VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False)
		          =.SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		        Endif
		        llReturn = True
		      Else
		        llReturn = False
		      Endif
		
		    Case Vartype(tcHorizAlign) != 'C' And Vartype(tcVertAlign) = 'C'
		      If Inlist(tcVertAlign, CELL_VERT_ALIGN_TOP, CELL_VERT_ALIGN_BOTTOM, CELL_VERT_ALIGN_CENTER)
		        If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		          If xl_cells.cellxfs > 0 And .GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		            lnCellXfsId = xl_cellxfs.Id
		            Select workbook From xl_cells Where workbook = tnWB And cellxfs = lnCellXfsId Into Cursor xl_temp
		            If _Tally > 1
		              lnCellXfsId = .GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontId, xl_cellxfs.fillId, xl_cellxfs.borderId, "", tcVertAlign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.Rotation)
		            Else
		              Replace xl_cellxfs.halign With "", ;
		                xl_cellxfs.valign With tcVertAlign In xl_cellxfs
		            Endif
		            Use In Select('xl_temp')
		          Else
		            lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, 0, 0, "", tcVertAlign, 0, 0, 0)
		          Endif
		          Replace xl_cells.cellxfs With lnCellXfsId In xl_cells
		        Else
		          lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, 0, 0, "", tcVertAlign, 0, 0, 0)
		          Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted) ;
		            VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False)
		          SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		        Endif
		        llReturn = True
		      Else
		        llReturn = False
		      Endif
		
		    Otherwise
		      If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		        Replace xl_cells.halign With "", xl_cells.valign With "" In xl_cells
		      Endif
		      llReturn = True
		    Endcase
		  Else
		    llReturn = False
		  Endif
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellalignmentrange		&& Sets the cell alignment for a range of cells
		Lparameters tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tcHorizAlign, tcVertAlign
		Local lnRow, lnCol, llReturn
		With This
		  If Pcount() < 7 Or .IsCellReferenceInvalid(tnBegRow, tnBegCol) Or .IsCellReferenceInvalid(tnEndRow, tnEndCol)
		    Return False
		  Endif
		  If tnBegRow > tnEndRow Or tnBegCol > tnEndCol
		    Return False
		  Endif
		  llReturn = True
		  For lnRow=tnBegRow To tnEndRow
		    For lnCol=tnBegCol To tnEndCol
		      If !.SetCellAlignment(tnWB, tnSheet, lnRow, lnCol, tcHorizAlign, tcVertAlign)
		        llReturn = False
		        Exit
		      Endif
		    Endfor
		  Endfor
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellborder
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tnBorders, tcStyle, tnColor
		Local lcLStyle, lnLColor, lcRStyle, lcTStyle, lnTColor, lcBStyle, lnBColor, lcDStyle, lnDColor, lnDiagDn, lnDiagUp
		Local lnRColor, llReturn, lcAlias
		With This
		  If Pcount() < 5 Or .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  lcAlias = Alias()
		  If .GetSheetRecord(tnWB, tnSheet)
		    If Vartype(tnBorders) != 'N' Or Empty(tnBorders) Or !Between(tnBorders, 0, 63)
		      tnBorders = 0
		    Endif
		    If !.IsValidBorderStyle(tcStyle)
		      tcStyle = BORDER_STYLE_NONE
		    Endif
		    If Vartype(tnColor) != 'N' Or !Between(tnColor, 0, Rgb(255,255,255)) Or Empty(tnColor)
		      tnColor = Rgb(0, 0, 0)
		    Endif
		    Store 0 To lnDiagDn, lnDiagUp
		    Store Rgb(0,0,0) To lnLColor, lnRColor, lnTColor, lnBColor, lnDColor
		    Store BORDER_STYLE_NONE To lcLStyle, lcRStyle, lcTStyle, lcBStyle, lcDStyle
		    If Bittest(tnBorders, 0)
		      lcLStyle = tcStyle
		      lnLColor = tnColor
		    Endif
		    If Bittest(tnBorders, 1)
		      lcRStyle = tcStyle
		      lnRColor = tnColor
		    Endif
		    If Bittest(tnBorders, 2)
		      lcTStyle = tcStyle
		      lnTColor = tnColor
		    Endif
		    If Bittest(tnBorders, 3)
		      lcBStyle = tcStyle
		      lnBColor = tnColor
		    Endif
		    If Bittest(tnBorders, 4)
		      lcDStyle = tcStyle
		      lnDColor = tnColor
		      lnDiagDn = 1
		    Endif
		    If Bittest(tnBorders, 5)
		      lcDStyle = tcStyle
		      lnDColor = tnColor
		      lnDiagUp = 1
		    Endif
		    .SetCellBorderEx(tnWB, tnSheet, tnCellRow, tnCellCol, lcLStyle, lnLColor, lcRStyle, lnRColor, ;
		      lcTStyle, lnTColor, lcBStyle, lnBColor, lcDStyle, lnDColor, lnDiagDn, lnDiagUp)
		    .SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		    llReturn = True
		  Else
		    llReturn = False
		  Endif
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellborderex
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tcLStyle, tnLColor, tcRStyle, tnRColor, tcTStyle, tnTColor, tcBStyle, tnBColor, tcDStyle, tnDColor, tnDiagDn, tnDiagUp
		Local lnCellXfsId, lnBorderId
		With This
		  If Pcount() < 5 Or .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  If .GetSheetRecord(tnWB, tnSheet)
		    If !.IsValidBorderStyle(tcLStyle)
		      tcLStyle = BORDER_STYLE_NONE
		    Endif
		    If Vartype(tnLColor) != 'N' Or Empty(tnLColor) Or !Between(tnLColor, 0, Rgb(255,255,255))
		      tnLColor = Rgb(0, 0, 0)
		    Endif
		
		    If !.IsValidBorderStyle(tcRStyle)
		      tcRStyle = BORDER_STYLE_NONE
		    Endif
		    If Vartype(tnRColor) != 'N' Or Empty(tnRColor) Or !Between(tnRColor, 0, Rgb(255,255,255))
		      tnRColor = Rgb(0, 0, 0)
		    Endif
		
		    If !.IsValidBorderStyle(tcTStyle)
		      tcTStyle = BORDER_STYLE_NONE
		    Endif
		    If Vartype(tnTColor) != 'N' Or Empty(tnTColor) Or !Between(tnTColor, 0, Rgb(255,255,255))
		      tnTColor = Rgb(0, 0, 0)
		    Endif
		
		    If !.IsValidBorderStyle(tcBStyle)
		      tcBStyle = BORDER_STYLE_NONE
		    Endif
		    If Vartype(tnBColor) != 'N' Or Empty(tnBColor) Or !Between(tnBColor, 0, Rgb(255,255,255))
		      tnBColor = Rgb(0, 0, 0)
		    Endif
		
		    If !.IsValidBorderStyle(tcDStyle)
		      tcDStyle = BORDER_STYLE_NONE
		    Endif
		    If Vartype(tnDColor) != 'N' Or Empty(tnDColor) Or !Between(tnDColor, 0, Rgb(255,255,255))
		      tnDColor = Rgb(0, 0, 0)
		    Endif
		    If Vartype(tnDiagDn) != 'N' Or !Between(tnDiagDn, 0, 3)
		      tnDiagDn = 0
		    Endif
		    If Vartype(tnDiagUp) != 'N' Or !Between(tnDiagUp, 0, 3)
		      tnDiagUp = 0
		    Endif
		
		*-*	Get the border record Id
		    If .GetBordersRecord(tnWB, tcLStyle, tnLColor, tcRStyle, tnRColor, tcTStyle, tnTColor, tcBStyle, tnBColor, tcDStyle, tnDColor, tnDiagDn, tnDiagUp)
		      lnBorderId = xl_borders.Id
		    Else
		      lnBorderId = .GetNextId(tnWB, 'xl_borders')
		      Insert Into xl_borders (workbook, Id, lstyle, lcolor, rstyle, rcolor, tstyle, tcolor, bstyle, bcolor, dstyle, dcolor, diagdn, diagup) ;
		        VALUES (tnWB, lnBorderId, tcLStyle, tnLColor, tcRStyle, tnRColor, tcTStyle, tnTColor, tcBStyle, tnBColor, tcDStyle, tnDColor, tnDiagDn, tnDiagUp)
		    Endif
		*-*	Set the XfsId to the cell record
		    If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		      If xl_cells.cellxfs > 0 And .GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		        lnCellXfsId = xl_cellxfs.Id
		        Select workbook From xl_cells Where workbook = tnWB And cellxfs = lnCellXfsId Into Cursor xl_temp
		        If _Tally > 1
		          lnCellXfsId = This.GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontId, xl_cellxfs.fillId, lnBorderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.Rotation)
		        Else
		          Replace xl_cellxfs.borderId With lnBorderId In xl_cellxfs
		        Endif
		        Use In Select('xl_temp')
		      Else
		        lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, 0, lnBorderId, "", "", 0, 0, 0)
		      Endif
		      Replace xl_cells.cellxfs With lnCellXfsId In xl_cells
		    Else
		      lnCellXfsId = This.GetCellXfsId(tnWB, 0, 0, 0, lnBorderId, "", "", 0, 0, 0)
		      Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted, numdec, validndx) ;
		        VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
		      This.SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		    Endif
		    llReturn = True
		  Else
		    llReturn = False
		  Endif
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellborderrange		&& Sets the cell border for a range of cells
		Lparameters tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tnBorder, tcStyle, tnColor
		Local llReturn, lnRow, lnCol
		With This
		  If Pcount() < 7 Or .IsCellReferenceInvalid(tnBegRow, tnBegCol) Or .IsCellReferenceInvalid(tnEndRow, tnEndCol)
		    Return False
		  Endif
		  If tnBegRow > tnEndRow Or tnBegCol > tnEndCol
		    Return False
		  Endif
		  llReturn = True
		  For lnRow=tnBegRow To tnEndRow
		    For lnCol=tnBegCol To tnEndCol
		      If !.SetCellBorder(tnWB, tnSheet, lnRow, lnCol, tnBorder, tcStyle, tnColor)
		        llReturn = False
		        Exit
		      Endif
		    Endfor
		  Endfor
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellfill		&& Sets the fill color for the cell
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tnFColor, tnBColor, tcPatternType
		Local llReturn, lnFillId, lnCellXfsId, lnFIndex, lnBIndex, lcAlias
		Do Case
		Case Pcount() < 5
		  Return False
		
		Case Pcount() = 5
		  tnBColor = Rgb(255,255,255)
		  tcPatternType = FILL_STYLE_SOLID
		
		Case Pcount() = 6
		  tcPatternType = FILL_STYLE_SOLID
		Endcase
		With This
		  If .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  lcAlias = Alias()
		  If Pcount() = 5 Or Pcount() = 6 Or Vartype(tcPatternType) != "C" Or Empty(tcPatternType)
		    tcPatternType = FILL_STYLE_SOLID
		  Endif
		  If .GetSheetRecord(tnWB, tnSheet)
		    If Vartype(tnBColor) != 'N'
		      tnBColor = Rgb(255,255,255)
		    Endif
		    If Vartype(tnFColor) = 'N' And Between(tnFColor, 0, Rgb(255, 255, 255))
		      tnFColor = Floor(tnFColor)
		      lnFIndex = 0
		    Else
		      tnFColor = 0
		      lnFIndex = 64
		    Endif
		    If Vartype(tnBColor) = 'N' And Between(tnBColor, 0, Rgb(255, 255, 255))
		      tnBColor = Floor(tnBColor)
		      lnBIndex = 0
		    Else
		      tnBColor = Rgb(0, 0, 0)
		      lnBIndex = 64
		    Endif
		*-*	Get the fill record id
		    If Seek(BinToC(tnWB)+BinToC(tnFColor)+BinToC(tnBColor)+tcPatternType, "xl_fills", "fillcolor")
		      lnFillId = xl_fills.Id
		      Replace xl_fills.Theme     With 0, ;
		        xl_fills.tint      With 0, ;
		        xl_fills.fgindexed With lnFIndex, ;
		        xl_fills.bgindexed With lnBIndex In xl_fills
		    Else
		      lnFillId = This.GetNextId(tnWB, 'xl_fills')
		      Insert Into xl_fills (workbook, Id, fgcolor, bgcolor, patttype, Theme, tint, fgindexed, bgindexed) ;
		        VALUES (tnWB, lnFillId, tnFColor, tnBColor, tcPatternType, 0, 0, lnFIndex, lnBIndex)
		    Endif
		*-*	Set the XfsId to the cell record
		    If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		      If xl_cells.cellxfs > 0 And This.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		        lnCellXfsId = xl_cellxfs.Id
		        Select workbook From xl_cells Where workbook = tnWB And cellxfs = lnCellXfsId Into Cursor xl_temp
		        If _Tally > 1
		          lnCellXfsId = .GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontId, lnFillId, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.Rotation)
		        Else
		          Replace xl_cellxfs.fillId With lnFillId In xl_cellxfs
		        Endif
		        Use In Select('xl_temp')
		      Else
		        lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, lnFillId, 0, "", "", 0, 0, 0)
		      Endif
		      Replace xl_cells.cellxfs With lnCellXfsId In xl_cells
		    Else
		      lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, lnFillId, 0, "", "", 0, 0, 0)
		      Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted, numdec, validndx) ;
		        VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
		      .SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		    Endif
		    llReturn = True
		  Else
		    llReturn = False
		  Endif
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellfillrange		&& Sets the fill for a range of cells
		Lparameters tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tnFColor, tnBColor, tcPatternType
		Local lnRow, lnCol, llReturn
		Do Case
		Case Pcount() < 7
		  Return False
		
		Case Pcount() = 7
		  tnBColor = Rgb(255,255,255)
		  tcPatternType = FILL_STYLE_SOLID
		
		Case Pcount() = 8
		  tcPatternType = FILL_STYLE_SOLID
		Endcase
		If tnBegRow > tnEndRow Or tnBegCol > tnEndCol Or This.IsCellReferenceInvalid(tnBegRow, tnBegCol) Or This.IsCellReferenceInvalid(tnEndRow, tnEndCol)
		  Return False
		Endif
		If Vartype(tnBColor) != 'N'
		  tnBColor = Rgb(255,255,255)
		Endif
		llReturn = True
		For lnRow=tnBegRow To tnEndRow
		  For lnCol=tnBegCol To tnEndCol
		    If !This.SetCellFill(tnWB, tnSheet, lnRow, lnCol, tnFColor, tnBColor, tcPatternType)
		      llReturn = False
		      Exit
		    Endif
		  Endfor
		Endfor
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellfont		&& Sets the selected cell font format
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tcFName, tnFSize, tlBold, tlItalic, tnFColor, tcULine, tlStrikThr, tcVPos
		Local llReturn, lcAlias
		With This
		  If Pcount() < 5 Or .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  lcAlias = Alias()
		  If .GetSheetRecord(tnWB, tnSheet)
		    If Vartype(tcFName) != 'C' Or Empty(tcFName)
		      tcFName = 'Calibri'
		    Endif
		    tcFName = Proper(Alltrim(tcFName))
		    If Vartype(tnFSize) != 'N' Or Empty(tnFSize) Or tnFSize < 0.5
		      tnFSize = 11
		    Else
		      tnFSize = Int(tnFSize)
		    Endif
		    If Vartype(tlBold) != 'L'
		      tlBold = False
		    Endif
		    If Vartype(tlItalic) != 'L'
		      tlItalic = False
		    Endif
		    If Vartype(tnFColor) = 'N' And Between(tnFColor, 0, Rgb(255, 255, 255))
		      tnFColor = Floor(tnFColor)
		    Else
		      tnFColor = Rgb(0, 0, 0)
		    Endif
		    If Vartype(tlStrikThr) != 'L'
		      tlStrikThr = False
		    Endif
		    If Vartype(tcULine) != 'C' Or !Inlist(tcULine, UNDERLINE_SINGLE, UNDERLINE_DOUBLE, UNDERLINE_SINGLEACCOUNTING, UNDERLINE_DOUBLEACCOUNTING, UNDERLINE_NONE)
		      tcULine = UNDERLINE_NONE
		    Endif
		    If Vartype(tcVPos) != 'C' Or !Inlist(tcVPos, FONT_VERTICAL_BASELINE, FONT_VERTICAL_SUBSCRIPT, FONT_VERTICAL_SUPERSCRIPT)
		      tcVPos = FONT_VERTICAL_BASELINE
		    Endif
		*-*	Get the font record id
		    If Seek(BinToC(tnWB)+Padr(tcFName, 100) + Str(tnFSize, 5, 1) + Transform(tlBold) + Transform(tlItalic) + Padl(tnFColor, 15) + Padr(tcULine, 16) + ;
		        TRANSFORM(tlStrikThr) + Padr(tcVPos, 11), "xl_fonts", "cellformat")
		
		      lnFontId = xl_fonts.Id
		      Replace xl_fonts.Theme   With 0, ;
		        xl_fonts.tint    With 0, ;
		        xl_fonts.indexed With 0 In xl_fonts
		    Else
		      lnFontId = .GetNextId(tnWB, 'xl_fonts')
		      Insert Into xl_fonts (workbook, Id, fname, Fsize, fbold, fitalic, fcolor, uline, strkthr, fvpos) ;
		        VALUES (tnWB, lnFontId, tcFName, tnFSize, tlBold, tlItalic, tnFColor, tcULine, tlStrikThr, tcVPos)
		    Endif
		*-*	Set the XfsId to the cell record
		    If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		      If xl_cells.cellxfs > 0 And .GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		        lnCellXfsId = xl_cellxfs.Id
		        Select workbook From xl_cells Where workbook = tnWB And cellxfs = lnCellXfsId Into Cursor xl_temp
		        If _Tally > 1
		          lnCellXfsId = .GetCellXfsId(tnWB, xl_cellxfs.numFmtId, lnFontId, xl_cellxfs.fillid, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.Rotation)
		        Else
		          Replace xl_cellxfs.fontid With lnFontId In xl_cellxfs
		        Endif
		        Use In Select('xl_temp')
		      Else
		        lnCellXfsId = .GetCellXfsId(tnWB, 0, lnFontId, 0, 0, "", "", 0, 0, 0)
		      Endif
		      Replace xl_cells.cellxfs With lnCellXfsId In xl_cells
		    Else
		      lnCellXfsId = .GetCellXfsId(tnWB, 0, lnFontId, 0, 0, "", "", 0, 0, 0)
		      Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted, numdec, validndx) ;
		        VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
		      .SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		    Endif
		    llReturn = True
		  Else
		    llReturn = False
		  Endif
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellfontrange		&& Sets the cell font format for a range of cells
		Lparameters tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tcFName, tnFSize, tlBold, tlItalic, tnFColor, tcULine, tlStrikThr, tcVPos
		Local lnRow, lnCol, llReturn
		If Pcount() < 7 Or This.IsCellReferenceInvalid(tnBegRow, tnBegCol) Or This.IsCellReferenceInvalid(tnEndRow, tnEndCol)
		  Return False
		Endif
		If tnBegRow > tnEndRow Or tnBegCol > tnEndCol
		  Return False
		Endif
		llReturn = True
		For lnRow=tnBegRow To tnEndRow
		  For lnCol=tnBegCol To tnEndCol
		    If !This.SetCellFont(tnWB, tnSheet, lnRow, lnCol, tcFName, tnFSize, tlBold, tlItalic, tnFColor, tcULine, tlStrikThr, tcVPos)
		      llReturn = False
		      Exit
		    Endif
		  Endfor
		Endfor
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellformula		&& Sets the cell formula expression
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tcCellFormula
		Local llReturn, lcAlias
		With This
		  If Pcount() < 5 Or Vartype(tcCellFormula) != "C" Or .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  lcAlias = Alias()
		  If .GetSheetRecord(tnWB, tnSheet)
		    If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		      Replace xl_cells.cellvalue   With "", ;
		        xl_cells.cellformula With tcCellFormula, ;
		        xl_cells.stringid    With 0, ;
		        xl_cells.DataType    With DATA_TYPE_FORMULA, ;
		        xl_cells.celldeleted With False In xl_cells
		    Else
		      Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, cellformula, DataType, cellxfs, celldeleted, numdec, validndx) ;
		        VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, tcCellFormula, DATA_TYPE_FORMULA, 0, False, -1, 0)
		      .SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		    Endif
		    llReturn = True
		  Else
		    llReturn = False
		  Endif
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellindent		&& Sets the cell indentation value
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tnIndent
		Local lnCellXfsId, lcAlias
		With This
		  If Pcount() != 5 Or .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  If Vartype(tnIndent) != 'N'
		    Return False
		  Endif
		  lcAlias = Alias()
		  tnIndent = Floor(tnIndent)
		  If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		    If xl_cells.cellxfs > 0 And .GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		      lnCellXfsId = xl_cellxfs.Id
		      Select workbook From xl_cells Where workbook = tnWB And cellxfs = lnCellXfsId Into Cursor xl_temp
		      If _Tally > 1
		        lnCellXfsId = .GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontid, xl_cellxfs.fillid, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, tnIndent, xl_cellxfs.wraptext, xl_cellxfs.Rotation)
		      Else
		        Replace xl_cellxfs.indent With tnIndent In xl_cellxfs
		      Endif
		      Use In Select('xl_temp')
		    Else
		      lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, 0, 0, "", "", tnIndent, 0, 0)
		    Endif
		    Replace xl_cells.cellxfs With lnCellXfsId In xl_cells
		  Else
		    lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, 0, 0, "", "", tnIndent, 0, 0)
		    Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted, numdec, validndx) ;
		      VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
		    .SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		  Endif
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return True
		
	ENDPROC

	PROCEDURE setcellinlineformattext		&& Saves the in-line format definition to a cell value
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, toInLine
		Local lnNdx, lcRText, llFBold, llFItalic, lnFColor, lcFName, lnFSize, lcULine, llStrkThr, lcFVPos, lcAlias
		With this
		If .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		  Return False
		Endif
		If tnWB = toInLine.Workbook
		  lcAlias = Alias()
		  If Isnull(toInLine.StringId)
		    toInLine.StringId = .AddStringValue(toInLine.Workbook, toInLine.StringValue, True)
		  Endif
		  If .GetCellRecord(toInLine.Workbook, tnSheet, tnCellRow, tnCellCol)
		    Replace xl_cells.cellvalue   With "StringValue", ;
		      xl_cells.cellxfs     With 0, ;
		      xl_cells.cellformula With "", ;
		      xl_cells.StringId    With toInLine.StringId, ;
		      xl_cells.DataType    With DATA_TYPE_CHAR, ;
		      xl_cells.celldeleted With False In xl_cells
		  Else
		    Insert Into xl_cells (Workbook, Sheet, cellrow, cellcol, cellvalue, StringId, DataType, cellxfs, celldeleted, numdec, validndx) ;
		      VALUES (toInLine.Workbook, tnSheet, tnCellRow, tnCellCol, "StringValue", toInLine.StringId, DATA_TYPE_CHAR, 0, False, -1, 0)
		
		    .SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		  Endif
		  For lnNdx=1 To toInLine.Count
		    lcRText   = Substr(toInLine.StringValue, toInLine.Characters[lnNdx].BegPos, toInLine.Characters[lnNdx].Length)
		    llFBold   = toInLine.Characters[lnNdx].FontBold
		    llFItalic = toInLine.Characters[lnNdx].FontItalic
		    lnFColor  = toInLine.Characters[lnNdx].FontColor
		    lcFName   = toInLine.Characters[lnNdx].FontName
		    lnFSize   = toInLine.Characters[lnNdx].FontSize
		    lcULine   = toInLine.Characters[lnNdx].Underline
		    llStrkThr = toInLine.Characters[lnNdx].StrikeThru
		    lcFVPos   = Icase(toInLine.Characters[lnNdx].SubScript, FONT_VERTICAL_SUBSCRIPT, toInLine.Characters[lnNdx].SuperScript, FONT_VERTICAL_SUPERSCRIPT, FONT_VERTICAL_BASELINE)
		
		    Insert Into xl_strformat (Workbook, Id, Index, stringxml, stringval, fbold, fitalic, fcolor, fname, Fsize, uline, strkthr, fvpos, Theme, tint, indexed) ;
		      VALUES (toInLine.Workbook, toInLine.StringId, lnNdx, .GetXMLString(lcRText), lcRText, llFBold, llFItalic, lnFColor, lcFName, lnFSize, lcULine, ;
		      llStrkThr, lcFVPos, 0, 0, 0)
		  Endfor
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		  Return True
		Else
		  Return False
		Endif
		EndWith
	ENDPROC

	PROCEDURE setcellnumberdecimals		&& Sets the number of decimals to display
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tnNumDecimals
		Local lcAlias
		With This
		  If Pcount() < 5 Or .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  If Vartype(tnNumDecimals) != 'N' Or tnNumDecimals < 0
		    Return False
		  Endif
		  lcAlias = Alias()
		  If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		    Replace xl_cells.numdec With tnNumDecimals In xl_cells
		  Else
		    Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, nbrfmtid, numdec, celldeleted) ;
		      VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, 0, tnNumDecimals, False)
		    .SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		  Endif
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return True
		
	ENDPROC

	PROCEDURE setcellnumberformat		&& Sets the cell number format
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tnNumFormat
		Local llReturn, lnNumFmtId, lcAlias, loException
		With This
		  If Pcount() < 5 Or .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  If Vartype(tnNumFormat) != 'N'
		    Return False
		  Endif
		  lcAlias = Alias()
		  If .GetSheetRecord(tnWB, tnSheet)
		    Do Case
		    Case tnNumFormat < START_NUMERIC_FORMAT_ID
		      lnNumFmtId = tnNumFormat
		
		    Case tnNumFormat >= START_NUMERIC_FORMAT_ID
		      If Seek(BinToC(tnWB)+BinToC(tnNumFormat), "xl_numfmts", "id")
		        lnNumFmtId = xl_numfmts.Id
		      Else
		        If !.AddClassDefinedNumericFormats(tnWB, tnNumFormat)
		          Return False
		        Endif
		        lnNumFmtId = tnNumFormat
		      Endif
		
		    Otherwise
		      Return False
		    Endcase
		    If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		      If xl_cells.cellxfs > 0 And .GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		        lnCellXfsId = xl_cellxfs.Id
		        Select workbook From xl_cells Where workbook = tnWB And cellxfs = lnCellXfsId Into Cursor xl_temp
		        If _Tally > 1
		          lnCellXfsId = .GetCellXfsId(tnWB, lnNumFmtId, xl_cellxfs.fontid, xl_cellxfs.fillid, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.Rotation)
		        Else
		          Try
		            Replace xl_cellxfs.numFmtId With lnNumFmtId In xl_cellxfs
		          Catch To loException
		            Set Step On
		          Endtry
		        Endif
		        Use In Select('xl_temp')
		      Else
		        lnCellXfsId = .GetCellXfsId(tnWB, lnNumFmtId, 0, 0, 0, "", "", 0, 0, 0)
		      Endif
		      Replace xl_cells.cellxfs With lnCellXfsId In xl_cells
		    Else
		      lnCellXfsId = .GetCellXfsId(tnWB, lnNumFmtId, 0, 0, 0, "", "", 0, 0, 0)
		      Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted, numdec, validndx) ;
		        VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
		      .SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		    Endif
		    llReturn = True
		  Else
		    llReturn = False
		  Endif
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellnumberformatrange		&& Sets the number format for a range of cells
		Lparameters tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tnNumFormat
		Local lnRow, lnCol, llReturn
		With This
		  If Pcount() < 7 Or .IsCellReferenceInvalid(tnBegRow, tnBegCol) Or .IsCellReferenceInvalid(tnEndRow, tnEndCol)
		    Return False
		  Endif
		  If tnBegRow > tnEndRow Or tnBegCol > tnEndCol
		    Return False
		  Endif
		  llReturn = True
		  For lnRow=tnBegRow To tnEndRow
		    For lnCol=tnBegCol To tnEndCol
		      If !.SetCellNumberFormat(tnWB, tnSheet, lnRow, lnCol, tnNumFormat)
		        llReturn = False
		        Exit
		      Endif
		    Endfor
		  Endfor
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellstyle		&& Sets the cell style
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tnCellXfsId
		If Seek(BinToC(tnWB)+BinToC(tnCellXfsId), "xl_cellxfs", "id")
		  If This.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		    Replace xl_cells.cellxfs With tnCellXfsId In xl_cells
		  Else
		    Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted, numdec, validndx) ;
		      VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, tnCellXfsId, False, -1, 0)
		    This.SetRowMaxColumn(tnWB, tnSheet, lnRow, lnCol)
		  Endif
		  Return True
		Else
		  Return False
		Endif
		
	ENDPROC

	PROCEDURE setcellstylerange		&& Sets the cell style for a range of cells
		Lparameters tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tnCellXfsId
		Local lnRow, lnCol
		If Pcount() < 7 Or tnBegRow > tnEndRow Or tnBegCol > tnEndCol
		  Return False
		Endif
		If Seek(BinToC(tnWB)+BinToC(tnCellXfsId), "xl_cellxfs", "id")
		  For lnRow=tnBegRow To tnEndRow
		    For lnCol=tnBegCol To tnEndCol
		      If This.GetCellRecord(tnWB, tnSheet, lnRow, lnCol)
		        Replace xl_cells.cellxfs With tnCellXfsId In xl_cells
		      Else
		        Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted, numdec, validndx) ;
		          VALUES (tnWB, tnSheet, lnRow, lnCol, DATA_TYPE_NONE, tnCellXfsId, False, -1, 0)
		        This.SetRowMaxColumn(tnWB, tnSheet, lnRow, lnCol)
		      Endif
		    Endfor
		  Endfor
		  Return True
		Else
		  Return False
		Endif
		
	ENDPROC

	PROCEDURE setcelltextrotation		&& Sets the cell text rotation value
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tnRotation
		Local lnCellXfsId, lcAlias
		With This
		  If Pcount() != 5 Or .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  If Vartype(tnRotation) != 'N'
		    Return False
		  Endif
		  If !Between(tnRotation, -90, 90)
		    Return False
		  Endif
		  lcAlias = Alias()
		  tnRotation = Floor(tnRotation)
		  If tnRotation < 0
		    tnRotation = 90 - tnRotation
		  Endif
		  If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		    If xl_cells.cellxfs > 0 And .GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		      lnCellXfsId = xl_cellxfs.Id
		      Select workbook From xl_cells Where workbook = tnWB And cellxfs = lnCellXfsId Into Cursor xl_temp
		      If _Tally > 1
		        lnCellXfsId = .GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontid, xl_cellxfs.fillid, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, xl_cellxfs.wraptext, tnRotation)
		      Else
		        Replace xl_cellxfs.Rotation With tnRotation In xl_cellxfs
		      Endif
		      Use In Select('xl_temp')
		    Else
		      lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, 0, 0, "", "", 0, 0, tnRotation)
		    Endif
		    Replace xl_cells.cellxfs With lnCellXfsId In xl_cells
		  Else
		    lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, 0, 0, "", "", 0, 0, tnRotation)
		    Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted, numdec, validndx) ;
		      VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
		    .SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		  Endif
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return True
		
	ENDPROC

	PROCEDURE setcellvalidation		&& Adds a cell validation
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tnType, tnStyle, tnOperator, tlAllowBlank, tlShowInputMsg, tlShowErrMsg, tcErrMsg, tcErrTitle, tcPrompt, tcFormula1, tcFormula2
		Local lcAlias, lnIndex, llFormula
		lcAlias = Alias()
		With This
		  If Pcount() < 14 Or .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  If !Between(tnType, 0, CUSTOM_VALID_TYPE)
		    Return False
		  Endif
		  If Vartype(tcFormula1) != "C"
		    tcFormula1 = Transform(tcFormula1)
		  Endif
		  If Empty(tcFormula1) Or Len(tcFormula1) > 254
		    Return False
		  Endif
		  If Left(tcFormula1, 1) = "="
		    llFormula  = True
		    tcFormula1 = Alltrim(Substr(tcFormula1, 2))
		  Else
		    llFormula  = False
		  Endif
		  If Pcount() < 15
		    tcFormula2 = ""
		  Endif
		  If Vartype(tcFormula2) != "C"
		    tcFormula2 = Transform(tcFormula2)
		  Endif
		  If Len(tcFormula2) > 254
		    Return False
		  Endif
		  If Left(tcFormula2, 1) = "="
		    tcFormula2 = Alltrim(Substr(tcFormula2, 2))
		  Endif
		  If Vartype(tnStyle) = "N"
		    If !Between(tnStyle, 0, INFO_VALID_STYLE)
		      Return False
		    Endif
		  Else
		    tnStyle = 0
		  Endif
		  If Vartype(tnOperator) = "N"
		    If !Between(tnOperator, 0, GREATOREQUAL_VALID_OPER)
		      Return False
		    Endif
		  Else
		    tnOperator = 0
		  Endif
		  If Vartype(tcErrMsg) != "C"
		    tcErrMsg = ""
		  Endif
		  If Vartype(tcErrTitle) != "C"
		    tcErrTitle = ""
		  Endif
		  If Vartype(tcPrompt) != "C"
		    tcPrompt = ""
		  Endif
		  If Vartype(tlAllowBlank) != "L"
		    tlAllowBlank = True
		  Endif
		  If Vartype(tlShowInputMsg) != "L"
		    tlShowInputMsg = True
		  Endif
		  If Vartype(tlShowErrMsg) != "L"
		    tlShowErrMsg = True
		  Endif
		*-*	Check if the cell is part of a merged range of cells; if so set the cell to the upper left cell of the merged range
		  If Reccount('xl_mergecells') > 0
		    Select xl_mergecells
		    Locate For workbook = tnWB And Sheet = tnSheet And Between(tnCellRow, begrow, endrow) And Between(tnCellCol, begcol, endcol) And !Deleted()
		    If Found()
		      tnCellRow = xl_mergecells.begrow
		      tnCellCol = xl_mergecells.begcol
		    Endif
		  Endif
		  Select xl_validation
		  Locate For BinToC(workbook)+BinToC(Sheet) = BinToC(tnWB)+BinToC(tnSheet) ;
		    AND Upper(formula1) = Upper(Padr(tcFormula1, 240)) ;
		    AND Upper(formula2) = Upper(Padr(tcFormula2, 240)) And !Deleted()
		  If Found()
		    lnIndex = 0
		    Do While Found()
		      If xl_validation.vtype = tnType ;
		          AND xl_validation.vstyle = tnStyle ;
		          AND xl_validation.voperator = tnOperator ;
		          AND xl_validation.errmsg = tcErrMsg ;
		          AND xl_validation.errtitle = tcErrTitle ;
		          AND xl_validation.allowblank = tlAllowBlank ;
		          AND xl_validation.showinpmsg = tlShowInputMsg ;
		          AND xl_validation.showerrmsg = tlShowErrMsg ;
		          AND xl_validation.vprompt = tcPrompt
		
		        lnIndex = xl_validation.validndx
		        Exit
		      Endif
		      Continue
		    Enddo
		    If lnIndex = 0
		      Insert Into xl_validation (workbook, Sheet, vtype, vstyle, voperator, errmsg, errtitle, vprompt, allowblank, showinpmsg, showerrmsg, formula, formula1, formula2) ;
		        VALUES (tnWB, tnSheet, tnType, tnStyle, tnOperator, tcErrMsg, tcErrTitle, tcPrompt, tlAllowBlank, tlShowInputMsg, tlShowErrMsg, llFormula, tcFormula1, tcFormula2)
		      lnIndex = xl_validation.validndx
		    Endif
		  Else
		    Insert Into xl_validation (workbook, Sheet, vtype, vstyle, voperator, errmsg, errtitle, vprompt, allowblank, showinpmsg, showerrmsg, formula, formula1, formula2) ;
		      VALUES (tnWB, tnSheet, tnType, tnStyle, tnOperator, tcErrMsg, tcErrTitle, tcPrompt, tlAllowBlank, tlShowInputMsg, tlShowErrMsg, llFormula, tcFormula1, tcFormula2)
		    lnIndex = xl_validation.validndx
		  Endif
		  If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		    Replace xl_cells.validndx With lnIndex In xl_cells
		  Else
		    Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted, numdec, validndx) ;
		      VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, 0, False, -1, lnIndex)
		    .SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		  Endif
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return True
		
	ENDPROC

	PROCEDURE setcellvalue		&& Sets the cell value
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, txCellValue
		Local lcCellValue, lcDataType, lnStringNdx, lnSetDecimals, lnWholePart, lnFractPart, lcAlias, lnNumFmtId, lcHorzAlign
		Local lcSetDate, lcSetPoint, lcSeparator, lcCurrency
		With This
		  If Pcount() < 5 Or .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  lcAlias = Alias()
		*-*	Check if the cell is part of a merged range of cells; if so set the cell to the upper left cell of the merged range
		  If Reccount('xl_mergecells') > 0
		    Select xl_mergecells
		    Locate For workbook = tnWB And Sheet = tnSheet And tnCellRow >= begrow And tnCellRow <= endrow And tnCellCol >= begcol And tnCellCol <= endcol And !Deleted()
		    If Found()
		      tnCellRow = xl_mergecells.begrow
		      tnCellCol = xl_mergecells.begcol
		    Endif
		  Endif
		*-*	Assign the data type based on type of value and add to cell
		  lnStringNdx = 0
		  lcHorzAlign = ""
		  lnNumFmtId  = 0
		  lcSetPoint  = Set("POINT")
		  lcSeparator = Set("SEPARATOR")
		  If lcSetPoint != "."                        && Change recommended by Doug Hennig; 2017-06-12
		    Set Point To "."
		    Set Separator To ","
		  Endif
		  Do Case
		  Case Vartype(txCellValue) = DATA_TYPE_LOGICAL
		    lcDataType  = DATA_TYPE_LOGICAL
		    lcCellValue = "StringValue"
		    txCellValue = Iif(txCellValue, Getwordnum(.TrueFalseValue, 1, "|"), Getwordnum(.TrueFalseValue, 2, "|"))
		    lnStringNdx = .AddStringValue(tnWB, txCellValue, False)
		
		  Case Vartype(txCellValue) = DATA_TYPE_CHAR
		    txCellValue = Alltrim(txCellValue)
		    If Len(txCellValue) > LIMITS_MAX_CELL_CHARS
		      Return False
		    Endif
		    lcDataType  = DATA_TYPE_CHAR
		    lcCellValue = "StringValue"
		    lnStringNdx = .AddStringValue(tnWB, txCellValue, False)
		    Delete For workbook = tnWB And Id = lnStringNdx In xl_strformat
		
		  Case Vartype(txCellValue) = DATA_TYPE_DATE
		    If txCellValue >= Date(1900, 1, 1)
		      lcDataType  = DATA_TYPE_DATE
		      lcCellValue = Transform(Int(txCellValue - Date(1900, 1, 1) + 2))
		    Else
		      lcDataType  = DATA_TYPE_CHAR
		      lcCellValue = "StringValue"
		      lcSetDate   = Set("DATE")
		      Set Date To AMERICAN
		      lnStringNdx = .AddStringValue(tnWB, Transform(txCellValue), False)
		      Set Date To (lcSetDate)
		    Endif
		    lcHorzAlign = CELL_HORIZ_ALIGN_LEFT
		    lnNumFmtId  = CELL_FORMAT_DATE_MMDDYY
		
		  Case Vartype(txCellValue) = DATA_TYPE_DATETIME
		    If Ttod(txCellValue) >= Date(1900, 1, 1)
		      lnSetDecimals = Set("DECIMALS")
		      Set Decimals To 12
		      lcDataType  = DATA_TYPE_DATETIME
		      lnWholePart = Int(Ttod(txCellValue) - Date(1900, 1, 1) + 2)
		      lnFractPart = ((Hour(txCellValue) * 60 + Minute(txCellValue)) * 60 + Sec(txCellValue)) / (24 * 60 * 60)
		      lcCellValue = Transform(lnWholePart + lnFractPart)
		      Set Decimals To (lnSetDecimals)
		    Else
		      lcDataType  = DATA_TYPE_CHAR
		      lcCellValue = "StringValue"
		      lcSetDate   = Set("DATE")
		      Set Date To AMERICAN
		      lnStringNdx = .AddStringValue(tnWB, Transform(txCellValue), False)
		      Set Date To (lcSetDate)
		    Endif
		    lcHorzAlign = CELL_HORIZ_ALIGN_LEFT
		    lnNumFmtId  = CELL_FORMAT_DATETIME_MMMDDYYYY_TTAM
		
		  Case Vartype(txCellValue) = DATA_TYPE_FLOAT
		    lcCellValue = Transform(txCellValue)
		    If Atc(".", lcCellValue) > 0
		      lcDataType = DATA_TYPE_FLOAT
		    Else
		      lcDataType = DATA_TYPE_INT
		    Endif
		
		  Case Vartype(txCellValue) = DATA_TYPE_CURRENCY
		    If .SaveCurrencyAsNumeric
		      lcDataType  = DATA_TYPE_FLOAT                     && Change requested by Tony Federer
		      lcCellValue = Transform(Mton(txCellValue))
		    Else
		      lcCurrency  = Set("Currency", 1)
		      lcCellValue = Chrtran(Transform(txCellValue), lcCurrency+",", "")
		      lcDataType  = DATA_TYPE_CURRENCY
		      lcHorzAlign = CELL_HORIZ_ALIGN_RIGHT
		      Do Case
		      Case lcCurrency = "Ј"
		        lnNumFmtId = CELL_FORMAT_ACC_CURR_POUNDS
		
		      Case lcCurrency = "Ђ"
		        lnNumFmtId = CELL_FORMAT_ACC_CURR_EURO
		
		      Otherwise
		        lnNumFmtId = CELL_FORMAT_CURRENCY_PAREN
		      Endcase
		    Endif
		
		  Case Vartype(txCellValue) = DATA_TYPE_GENERAL
		    lcDataType  = DATA_TYPE_GENERAL
		    lcCellValue = ""                                      && Change recommendation by Doug Hennig
		
		  Otherwise
		    lcDataType  = DATA_TYPE_GENERAL
		    lcCellValue = Transform(txCellValue)
		  Endcase
		  If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		    If xl_cells.cellxfs > 0 And .GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		      lnCellXfsId = xl_cellxfs.Id
		      Select workbook From xl_cells Where workbook = tnWB And cellxfs = lnCellXfsId Into Cursor xl_temp
		      If _Tally > 1
		        lnCellXfsId = .GetCellXfsId(tnWB, lnNumFmtId, xl_cellxfs.fontid, xl_cellxfs.fillid, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.Rotation)
		      Else
		        Replace xl_cellxfs.numFmtId With lnNumFmtId In xl_cellxfs
		      Endif
		      Use In Select('xl_temp')
		    Else
		      lnCellXfsId = .GetCellXfsId(tnWB, lnNumFmtId, 0, 0, 0, "", "", 0, 0, 0)
		    Endif
		    Replace xl_cells.cellvalue   With lcCellValue, ;
		      xl_cells.cellxfs     With lnCellXfsId, ;
		      xl_cells.cellformula With "", ;
		      xl_cells.stringid    With lnStringNdx, ;
		      xl_cells.DataType    With lcDataType, ;
		      xl_cells.celldeleted With False In xl_cells
		  Else
		    If lnNumFmtId > 0
		      lnCellXfsId = .GetCellXfsId(tnWB, lnNumFmtId, 0, 0, 0, "", "", 0, 0, 0)
		    Else
		      lnCellXfsId = 0
		    Endif
		    Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, cellvalue, stringid, DataType, cellxfs, celldeleted, numdec, validndx) ;
		      VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, lcCellValue, lnStringNdx, lcDataType, lnCellXfsId, False, -1, 0)
		
		    .SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		  Endif
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		  If lcSetPoint != "."                        && Change recommended by Doug Hennig; 2017-06-12
		    Set Point To (lcSetPoint)
		    Set Separator To (lcSeparator)
		  Endif
		Endwith
		Return True
		
	ENDPROC

	PROCEDURE setcellwordwrap		&& Sets the cell word-wrapping value
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol, tlWordWrap
		Local llReturn, lnWrapText, lnCellXfsId, lcAlias
		With This
		  If Pcount() < 5 Or Vartype(tlWordWrap) != "L" Or .IsCellReferenceInvalid(tnCellRow, tnCellCol)
		    Return False
		  Endif
		  lcAlias = Alias()
		  If .GetSheetRecord(tnWB, tnSheet)
		    lnWrapText = Iif(tlWordWrap, 1, 0)
		*-*	Set the XfsId to the cell record
		    If .GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
		      If xl_cells.cellxfs > 0 And .GetCellXfsRecord(tnWB, xl_cells.cellxfs)
		        lnCellXfsId = xl_cellxfs.Id
		        Select workbook From xl_cells Where workbook = tnWB And cellxfs = lnCellXfsId Into Cursor xl_temp
		        If _Tally > 1
		          lnCellXfsId = .GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontId, xl_cellxfs.fillid, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, lnWrapText, xl_cellxfs.Rotation)
		        Else
		          Replace xl_cellxfs.wraptext With lnWrapText In xl_cellxfs
		        Endif
		        Use In Select('xl_temp')
		      Else
		        lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, 0, 0, "", "", 0, lnWrapText, 0)
		      Endif
		      Replace xl_cells.cellxfs With lnCellXfsId In xl_cells
		    Else
		      lnCellXfsId = .GetCellXfsId(tnWB, 0, 0, 0, 0, "", "", 0, lnWrapText, 0)
		      Insert Into xl_cells (workbook, Sheet, cellrow, cellcol, DataType, cellxfs, celldeleted, numdec, validndx) ;
		        VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
		      .SetRowMaxColumn(tnWB, tnSheet, tnCellRow, tnCellCol)
		    Endif
		    llReturn = True
		  Else
		    llReturn = False
		  Endif
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE setcellwordwraprange		&& Sets the word wrap for a range of cells
		Lparameters tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tlWordWrap
		Local lnRow, lnCol, llReturn
		With This
		  If Pcount() < 7 Or Vartype(tlWordWrap) != "L" Or .IsCellReferenceInvalid(tnBegRow, tnBegCol) Or .IsCellReferenceInvalid(tnEndRow, tnEndCol)
		    Return False
		  Endif
		  If tnBegRow > tnEndRow Or tnBegCol > tnEndCol
		    Return False
		  Endif
		  llReturn = True
		  For lnRow=tnBegRow To tnEndRow
		    For lnCol=tnBegCol To tnEndCol
		      If !.SetCellWordWrap(tnWB, tnSheet, lnRow, lnCol, tlWordWrap)
		        llReturn = False
		        Exit
		      Endif
		    Endfor
		  Endfor
		Endwith
		Return llReturn
		
	ENDPROC

	PROCEDURE setcolumnbestfit		&& Set the column to best fit
		Lparameters tnWB, tnSheet, tnColumn, tlBestFit
		Local llReturn, lcAlias
		If Pcount() < 4
		  Return False
		Endif
		lcAlias = Alias()
		If This.GetSheetRecord(tnWB, tnSheet)
		  If Seek(This.GetColWidthKeyExpr(tnWB, tnSheet, tnColumn), "xl_colwidths", "shcolumn")
		    Replace xl_colwidths.bestfit With tlBestFit In xl_colwidths
		  Else
		    Insert Into xl_colwidths (workbook, Sheet, Column, bestfit) Values (tnWB, tnSheet, tnColumn, tlBestFit)
		  Endif
		  llReturn = True
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE setcolumnwidth		&& Sets the column width
		Lparameters tnWB, tnSheet, tnColumn, tnWidth
		Local llReturn, lcAlias
		If Pcount() < 4 Or Vartype(tnWidth) != "N"
		  Return False
		Endif
		lcAlias = Alias()
		If This.GetSheetRecord(tnWB, tnSheet)
		  If Seek(This.GetColWidthKeyExpr(tnWB, tnSheet, tnColumn), "xl_colwidths", "shcolumn")
		    Replace xl_colwidths.Width With tnWidth In xl_colwidths
		  Else
		    Insert Into xl_colwidths (workbook, Sheet, Column, Width, bestfit) Values (tnWB, tnSheet, tnColumn, tnWidth, False)
		  Endif
		  llReturn = True
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE setcolumnwidthrange		&& Sets the column width for a range of columns
		Lparameters tnWB, tnSheet, tnBegCol, tnEndCol, tnWidth
		Local lnCol, llReturn
		If Pcount() < 5
		  Return False
		Endif
		If tnBegCol > tnEndCol
		  Return False
		Endif
		llReturn = True
		For lnCol=tnBegCol To tnEndCol
		  If !This.SetColumnWidth(tnWB, tnSheet, lnCol, tnWidth)
		    llReturn = False
		    Exit
		  Endif
		Endfor
		Return llReturn
		
	ENDPROC

	PROCEDURE setcustompapersize		&& Sets the paper size based on custom dimensions
		Lparameters tnWB, tnSheet, tnWidth, tnHeight, tcDimen
		Local llReturn, lcAlias
		lcAlias = Alias()
		If Pcount() = 5 And This.GetSheetRecord(tnWB, tnSheet)
		  Do Case
		  Case tnWidth=0 Or tnHeight=0
		    Replace xl_sheets.Paperwidth  With 0, ;
		      xl_sheets.paperheight With 0, ;
		      xl_sheets.paperdimen  With "" In xl_sheets
		    llReturn = True
		
		  Case tnWidth>0 And tnHeight>0 And Inlist(tcDimen, "mm", "in")
		    Replace xl_sheets.Paperwidth  With tnWidth, ;
		      xl_sheets.paperheight With tnHeight, ;
		      xl_sheets.paperdimen  With Lower(tcDimen) In xl_sheets
		    llReturn = True
		
		  Otherwise
		    llReturn = False
		  Endcase
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE setdefaultborder		&& Sets the default border style for the workbook
		LPARAMETERS tnWB, tcLStyle, tnLColor, tcRStyle, tnRColor, tcTStyle, tnTColor, tcBStyle, tnBColor, tcDStyle, tnDColor, tnDiagDn, tnDiagUp
		LOCAL lcAlias
		IF PCOUNT() < 2
			RETURN False
		ENDIF
		IF VARTYPE(tcLStyle) != "C"
			tcLStyle = BORDER_STYLE_NONE
		ENDIF
		lcAlias = ALIAS()
		DO CASE
			CASE PCOUNT() = 2
				tnLColor = 0
				tcRStyle = tcLStyle
				tnRColor = 0
				tcTStyle = tcLStyle
				tnTColor = 0
				tcBStyle = tcLStyle
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 3
				tcRStyle = tcLStyle
				tnRColor = 0
				tcTStyle = tcLStyle
				tnTColor = 0
				tcBStyle = tcLStyle
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 4
				tnRColor = 0
				tcTStyle = tcLStyle
				tnTColor = 0
				tcBStyle = tcLStyle
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 5
				tcTStyle = tcLStyle
				tnTColor = 0
				tcBStyle = tcLStyle
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 6
				tnTColor = 0
				tcBStyle = tcLStyle
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 7
				tcBStyle = tcLStyle
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 8
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 9
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 10
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 11
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 12
				tnDiagUp = 0
		
		ENDCASE
		IF VARTYPE(tnLColor) != "N"
			tnLColor = 0
		ENDIF
		IF VARTYPE(tcRStyle) != "C"
			tcRStyle = tcLStyle
		ENDIF
		IF VARTYPE(tnRColor) != "N"
			tnRColor = 0
		ENDIF
		IF VARTYPE(tcTStyle) != "C"
			tcTStyle = tcLStyle
		ENDIF
		IF VARTYPE(tnTColor) != "N"
			tnTColor = 0
		ENDIF
		IF VARTYPE(tcBStyle) != "C"
			tcBStyle = tcLStyle
		ENDIF
		IF VARTYPE(tnBColor) != "N"
			tnBColor = 0
		ENDIF
		IF VARTYPE(tcDStyle) != "C"
			tcDStyle = tcLStyle
		ENDIF
		IF VARTYPE(tnDColor) != "N"
			tnDColor = 0
		ENDIF
		IF VARTYPE(tnDiagDn) != "N"
			tnDiagDn = 0
		ENDIF
		IF VARTYPE(tnDiagUp) != "N"
			tnDiagUp = 0
		ENDIF
		IF SEEK(BINTOC(tnWB)+BINTOC(0), "xl_borders", "id")
			REPLACE xl_borders.lstyle WITH tcLStyle, ;
					xl_borders.lcolor WITH tnLColor, ;
					xl_borders.rstyle WITH tcRStyle, ;
					xl_borders.rcolor WITH tnRColor, ;
					xl_borders.tstyle WITH tcTStyle, ;
					xl_borders.tcolor WITH tnTColor, ;
					xl_borders.bstyle WITH tcBStyle, ;
					xl_borders.bcolor WITH tnBColor, ;
					xl_borders.dstyle WITH tcDStyle, ;
					xl_borders.dcolor WITH tnDColor, ;
					xl_borders.diagdn WITH tnDiagDn, ;
					xl_borders.diagup WITH tnDiagUp IN xl_borders
		ELSE
			INSERT INTO xl_borders (workbook, id, lstyle, lcolor, rstyle, rcolor, tstyle, tcolor, bstyle, bcolor, dstyle, dcolor, diagdn, diagup) ;
				VALUES (tnWB, 0, tcLStyle, tnLColor, tcRStyle, tnRColor, tcTStyle, tnTColor, tcBStyle, tnBColor, tcDStyle, tnDColor, tnDiagDn, tnDiagUp)
		ENDIF
		IF !EMPTY(lcAlias)
			Select (lcAlias)
		ENDIF
		RETURN True
	ENDPROC

	PROCEDURE setdefaultfill		&& Sets the default fill for the workbook
		Lparameters tnWB, tcPatternType, tnFColor, tnBColor
		Local lnFIndex, lnBIndex, lcAlias
		If Pcount() < 2
		  Return False
		Endif
		lcAlias = Alias()
		If Vartype(tcPatternType) != "C"
		  tcPatternType = FILL_STYLE_NONE
		Endif
		Do Case
		Case Pcount() = 2
		  tnFColor = 0
		  lnFIndex = 0
		  tnBColor = 0
		  lnBIndex = 0
		
		Case Pcount() = 3
		  tnBColor = 0
		  lnBIndex = 64
		Endcase
		If Vartype(tnFColor) != "N"
		  tnFColor = 0
		Endif
		If Vartype(tnBColor) != "N"
		  tnBColor = Rgb(255,255,255)
		Endif
		If Seek(BinToC(tnWB)+BinToC(0), "xl_fills", "id")
		  Replace xl_fills.fgcolor   With tnFColor, ;
		    xl_fills.bgcolor   With tnBColor, ;
		    xl_fills.patttype  With tcPatternType, ;
		    xl_fills.Theme     With 0, ;
		    xl_fills.tint      With 0, ;
		    xl_fills.fgindexed With 0, ;
		    xl_fills.bgindexed With 0 In xl_fills
		Else
		  Insert Into xl_fills (workbook, Id, fgcolor, bgcolor, patttype, Theme, tint, fgindexed, bgindexed) ;
		    VALUES (tnWB, 0, tnFColor, tnBColor, tcPatternType, 0, 0, lnFIndex, lnBIndex)
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return True
		
	ENDPROC

	PROCEDURE setdefaultfont		&& Sets the default font for the workbook
		Lparameters tnWB, tcFontName, tnSize, tlBold, tlItalic, tnColor, tcUline, tlStrkthr, tcFVPos, tnTheme, tnTint, tnIndexed
		Local lcAlias
		If Pcount() < 2
		  Return False
		Endif
		lcAlias = Alias()
		Do Case
		Case Pcount() = 2
		  tnSize    = 11
		  tlBold    = False
		  tlItalic  = False
		  tnColor   = 0
		  tcUline   = ""
		  tlStrkthr = False
		  tcFVPos   = ""
		  tnTheme   = 0
		  tnTint    = 0
		  tnIndexed = 0
		
		Case Pcount() = 3
		  tlBold    = False
		  tlItalic  = False
		  tnColor   = 0
		  tcUline   = ""
		  tlStrkthr = False
		  tcFVPos   = ""
		  tnTheme   = 0
		  tnTint    = 0
		  tnIndexed = 0
		
		Case Pcount() = 4
		  tlItalic  = False
		  tnColor   = 0
		  tcUline   = ""
		  tlStrkthr = False
		  tcFVPos   = ""
		  tnTheme   = 0
		  tnTint    = 0
		  tnIndexed = 0
		
		Case Pcount() = 5
		  tnColor   = 0
		  tcUline   = ""
		  tlStrkthr = False
		  tcFVPos   = ""
		  tnTheme   = 0
		  tnTint    = 0
		  tnIndexed = 0
		
		Case Pcount() = 6
		  tcUline   = ""
		  tlStrkthr = False
		  tcFVPos   = ""
		  tnTheme   = 0
		  tnTint    = 0
		  tnIndexed = 0
		
		Case Pcount() = 7
		  tlStrkthr = False
		  tcFVPos   = ""
		  tnTheme   = 0
		  tnTint    = 0
		  tnIndexed = 0
		
		Case Pcount() = 8
		  tcFVPos   = ""
		  tnTheme   = 0
		  tnTint    = 0
		  tnIndexed = 0
		
		Case Pcount() = 9
		  tnTheme   = 0
		  tnTint    = 0
		  tnIndexed = 0
		
		Case Pcount() = 10
		  tnTint    = 0
		  tnIndexed = 0
		
		Case Pcount() = 11
		  tnIndexed = 0
		Endcase
		If Vartype(tcFontName) != "C"
		  tcFontName = "Calibri"
		Endif
		If Vartype(tnSize) != "N"
		  tnSize = 11
		Endif
		If Vartype(tlBold) != "L"
		  tlBold = False
		Endif
		If Vartype(tlItalic) != "L"
		  tlItalic = False
		Endif
		If Vartype(tnColor) != "N"
		  tnColor = 0
		Endif
		If Vartype(tcUline) != "C"
		  tcUline = ""
		Endif
		If Vartype(tlStrkthr) != "L"
		  tlStrkthr = False
		Endif
		If Vartype(tcFVPos) != "C"
		  tcFVPos = ""
		Endif
		If Vartype(tnTheme) != "N"
		  tnTheme = 0
		Endif
		If Vartype(tnTint) != "N"
		  tnTint = 0
		Endif
		If Vartype(tnIndexed) != "N"
		  tnTint = 0
		Endif
		If Seek(BinToC(tnWB)+BinToC(0), "xl_fonts", "id")
		  Replace xl_fonts.fname   With tcFontName, ;
		    xl_fonts.Fsize   With tnSize, ;
		    xl_fonts.fbold   With tlBold, ;
		    xl_fonts.fitalic With tlItalic, ;
		    xl_fonts.fcolor  With tnColo , ;
		    xl_fonts.uline   With tcUline, ;
		    xl_fonts.strkthr With tlStrkthr, ;
		    xl_fonts.fvpos   With tcFVPos, ;
		    xl_fonts.Theme   With tnTheme, ;
		    xl_fonts.tint    With tnTint, ;
		    xl_fonts.indexed With tnIndexed In xl_fonts
		Else
		  Insert Into xl_fonts (workbook, Id, fname, Fsize, fbold, fitalic, fcolor, uline, strkthr, fvpos, Theme, tint, indexed) ;
		    VALUES (tnWB, 0, tcFontName, tnSize, tlBold, tlItalic, tnColor, tcUline, tlStrkthr, tcFVPos, tnTheme, tnTint, tnIndexed)
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return true
		
	ENDPROC

	PROCEDURE setheaderfootersetup		&& Sets the header and footer setup for the sheet
		Lparameters tnWB, tnSheet, tlAlignMargin, tlDiffFirstPg, tlDiffOddEven, tlScaleWDoc
		Local llReturn, lcAlias
		lcAlias = Alias()
		If Pcount() = 6 And This.GetSheetRecord(tnWB, tnSheet)
		  If Seek(BinToC(tnWB)+BinToC(tnSheet), "xl_hdrfooterdefn", "wbsheet")
		    Replace xl_hdrfooterdefn.alignmargin With tlAlignMargin, ;
		      xl_hdrfooterdefn.difffirstpg With tlDiffFirstPg, ;
		      xl_hdrfooterdefn.diffoddeven With tlDiffOddEven, ;
		      xl_hdrfooterdefn.scalewdoc   With tlScaleWDoc In xl_hdrfooterdefn
		  Else
		    Insert Into xl_hdrfooterdefn (workbook, Sheet, alignmargin, difffirstpg, diffoddeven, scalewdoc) ;
		      VALUES (tnWB, tnSheet, tlAlignMargin, tlDiffFirstPg, tlDiffOddEven, tlScaleWDoc)
		  Endif
		  llReturn = True
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE setheaderfootertext		&& Sets the header/footer text for the sheet
		Lparameters tnWB, tnSheet, tnPage, tnSection, tcText, tcFontName, tnFontSize, tnFontEffect, tnFontColor
		Local llReturn, lcAlias
		Do Case
		Case Pcount() < 5
		  Return False
		
		Case Pcount() = 5
		  tcFontName   = ""
		  tnFontSize   = 0
		  tnFontEffect = 0
		  tnFontColor  = 0
		
		Case Pcount() = 6
		  tnFontSize   = 0
		  tnFontEffect = 0
		  tnFontColor  = 0
		
		Case Pcount() = 7
		  tnFontEffect = 0
		  tnFontColor  = 0
		
		Case Pcount() = 8
		  tnFontColor = 0
		Endcase
		If Vartype(tcFontName) != "C"
		  tcFontName = ""
		Endif
		If Vartype(tnFontSize) != "N"
		  tnFontSize = 0
		Endif
		If Vartype(tnFontEffect) != "N"
		  tnFontEffect = 0
		Endif
		If Vartype(tnFontColor) != "N"
		  tnFontColor = 0
		Endif
		lcAlias = Alias()
		If This.GetSheetRecord(tnWB, tnSheet)
		  If Seek(BinToC(tnWB)+BinToC(tnSheet), "xl_hdrfooterdefn", "wbsheet")
		    If Seek(This.GetHeaderFooterKeyExpr(tnWB, tnSheet, tnPage, tnSection), "xl_hdrfootertext", "hdrfootr")
		      Replace xl_hdrfootertext.Text      With tcText, ;
		        xl_hdrfootertext.FontName  With tcFontName, ;
		        xl_hdrfootertext.FontSize  With tnFontSize, ;
		        xl_hdrfootertext.fontstyle With tnFontEffect, ;
		        xl_hdrfootertext.fontcolor With tnFontColor In xl_hdrfootertext
		    Else
		      Insert Into xl_hdrfootertext (workbook, Sheet, Page, section, Text, FontName, FontSize, fontstyle, fontcolor) ;
		        VALUES (tnWB, tnSheet, tnPage, tnSection, tcText, tcFontName, tnFontSize, tnFontEffect, tnFontColor)
		    Endif
		    llReturn = True
		  Else
		    llReturn = False
		  Endif
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE setlastid		&& Sets the last used Id Value for strings, borders, fills, fonts, and cellxfs
		Lparameters tnWB, tnLastId, tcCursor
		Local lnNdx
		With This
		  Do Case
		  Case tcCursor = "xl_borders"
		    lnNdx = Ascan(.LastBorderId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastBorderId[lnNdx, 2] = tnLastId
		    Else
		      lnNdx = Max(1, Alen(.LastBorderId, 1) + 1)
		      Dimension .LastBorderId[lnNdx, 2]
		      .LastBorderId[lnNdx, 1] = tnWB
		      .LastBorderId[lnNdx, 2] = tnLastId
		    Endif
		
		  Case tcCursor = "xl_cellxfs"
		    lnNdx = Ascan(.LastCellXfsId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastCellXfsId[lnNdx, 2] = tnLastId
		    Else
		      lnNdx = Max(1, Alen(.LastCellXfsId, 1) + 1)
		      Dimension .LastCellXfsId[lnNdx, 2]
		      .LastCellXfsId[lnNdx, 1] = tnWB
		      .LastCellXfsId[lnNdx, 2] = tnLastId
		    Endif
		
		  Case tcCursor = "xl_fills"
		    lnNdx = Ascan(.LastFillId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastFillId[lnNdx, 2] = tnLastId
		    Else
		      lnNdx = Max(1,  Alen(.LastFillId, 1) + 1)
		      Dimension .LastFillId[lnNdx, 2]
		      .LastFillId[lnNdx, 1] = tnWB
		      .LastFillId[lnNdx, 2] = tnLastId
		    Endif
		
		  Case tcCursor = "xl_fonts"
		    lnNdx = Ascan(.LastFontId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastFontId[lnNdx, 2] = tnLastId
		    Else
		      lnNdx = Max(1,  Alen(.LastFontId, 1) + 1)
		      Dimension .LastFontId[lnNdx, 2]
		      .LastFontId[lnNdx, 1] = tnWB
		      .LastFontId[lnNdx, 2] = tnLastId
		    Endif
		
		  Case tcCursor = "xl_ndxcolors"
		    lnNdx = Ascan(.LastIndexColorId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastIndexColorId[lnNdx, 2] = tnLastId
		    Else
		      lnNdx = Max(1, Alen(.LastIndexColorId, 1) + 1)
		      Dimension .LastIndexColorId[lnNdx, 2]
		      .LastIndexColorId[lnNdx, 1] = tnWB
		      .LastIndexColorId[lnNdx, 2] = tnLastId
		    Endif
		
		  Case tcCursor = "xl_mrucolors"
		    lnNdx = Ascan(.LastMruColorId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastMruColorId[lnNdx, 2] = tnLastId
		    Else
		      lnNdx = Max(1,  Alen(.LastMruColorId, 1) + 1)
		      Dimension .LastMruColorId[lnNdx, 2]
		      .LastMruColorId[lnNdx, 1] = tnWB
		      .LastMruColorId[lnNdx, 2] = tnLastId
		    Endif
		
		  Case tcCursor = "xl_numfmts"
		    lnNdx = Ascan(.LastNumFmtId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastNumFmtId[lnNdx, 2] = tnLastId
		    Else
		      lnNdx = Max(1,  Alen(.LastNumFmtId, 1) + 1)
		      Dimension .LastNumFmtId[lnNdx, 2]
		      .LastNumFmtId[lnNdx, 1] = tnWB
		      .LastNumFmtId[lnNdx, 2] = tnLastId
		    Endif
		
		  Case tcCursor = "xl_relationships"
		    lnNdx = Ascan(.LastRelationId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastRelationId[lnNdx, 2] = tnLastId
		    Else
		      lnNdx = Max(1,  Alen(.LastRelationId, 1) + 1)
		      Dimension .LastRelationId[lnNdx, 2]
		      .LastRelationId[lnNdx, 1] = tnWB
		      .LastRelationId[lnNdx, 2] = tnLastId
		    Endif
		
		  Case tcCursor = "xl_sheets"
		    lnNdx = Ascan(.LastSheetId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastSheetId[lnNdx, 2] = tnLastId
		    Else
		      lnNdx = Max(1,  Alen(.LastSheetId, 1) + 1)
		      Dimension .LastSheetId[lnNdx, 2]
		      .LastSheetId[lnNdx, 1] = tnWB
		      .LastSheetId[lnNdx, 2] = tnLastId
		    Endif
		
		  Case tcCursor = "xl_strings"
		    lnNdx = Ascan(.LastStringId, tnWB, 1, -1, 1, 15)
		    If lnNdx > 0
		      .LastStringId[lnNdx, 2] = tnLastId
		    Else
		      lnNdx = Max(1,  Alen(.LastStringId, 1) + 1)
		      Dimension .LastStringId[lnNdx, 2]
		      .LastStringId[lnNdx, 1] = tnWB
		      .LastStringId[lnNdx, 2] = tnLastId
		    Endif
		  Endcase
		Endwith
		
	ENDPROC

	PROCEDURE setpapersize		&& Sets the paper size for the selected sheet
		Lparameters tnWB, tnSheet, tnPaperSize
		Local llReturn, lcAlias
		lcAlias = Alias()
		If Pcount() = 3 And This.GetSheetRecord(tnWB, tnSheet)
		  If Between(tnPaperSize, 0, 118)
		    Replace xl_sheets.Papersize With tnPaperSize In xl_sheets
		    llReturn = True
		  Else
		    llReturn = False
		  Endif
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE setprintfittoheight		&& Number of vertical pages to fit on for printing
		Lparameters tnWB, tnSheet, tnFitToHeight
		Local llReturn
		lcAlias = Alias()
		If Pcount() = 3 And This.GetSheetRecord(tnWB, tnSheet)
		  If Int(tnFitToHeight) >= 0
		    Replace xl_sheets.fittoheight With Int(tnFitToHeight) In xl_sheets
		    llReturn = True
		  Else
		    llReturn = False
		  Endif
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE setprintfittowidth		&& Number of horizontal pages to fit on for printing
		Lparameters tnWB, tnSheet, tnFitToWidth
		Local llReturn, lcAlias
		lcAlias = Alias()
		If Pcount() = 3 And This.GetSheetRecord(tnWB, tnSheet)
		  If Int(tnFitToWidth) >= 0
		    Replace xl_sheets.fittowidth With Int(tnFitToWidth) In xl_sheets
		    llReturn = True
		  Else
		    llReturn = False
		  Endif
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE setprintorientation		&& Sets the printer orientation for sheet output
		Lparameters tnWB, tnSheet, tnOrientation
		Local llReturn, lcAlias
		lcAlias = Alias()
		If Pcount() = 3 And This.GetSheetRecord(tnWB, tnSheet)
		  Replace xl_sheets.prnorient With tnOrientation In xl_sheets
		  llReturn = True
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE setrowheight		&& Sets the row height
		Lparameters tnWB, tnSheet, tnRow, tnHeight
		Local llReturn, lcAlias
		If Pcount() < 4 Or Vartype(tnHeight) != "N"
		  Return False
		Endif
		lcAlias = Alias()
		If This.GetSheetRecord(tnWB, tnSheet)
		  If Seek(This.GetRowHeightKeyExpr(tnWB, tnSheet, tnRow), "xl_rowheights", "shrow")
		    Replace xl_rowheights.Height With tnHeight In xl_rowheights
		  Else
		    Insert Into xl_rowheights (workbook, Sheet, Row, Height) Values (tnWB, tnSheet, tnRow, tnHeight)
		  Endif
		  llReturn = True
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE setrowheightrange		&& Sets the row height for a range of rows
		Lparameters tnWB, tnSheet, tnBegRow, tnEndRow, tnHeight
		Local lnRow, llReturn
		If Pcount() < 5
		  Return False
		Endif
		If tnBegRow > tnEndRow
		  Return False
		Endif
		llReturn = True
		For lnRow=tnBegRow To tnEndRow
		  If !This.SetRowHeight(tnWB, tnSheet, lnRow, tnHeight)
		    llReturn = False
		    Exit
		  Endif
		Endfor
		Return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE setrowmaxcolumn		&& Sets the value for the maximum cell column in a row
		Lparameters tnWB, tnSheet, tnCellRow, tnCellCol
		If Seek(BinToC(tnWB)+BinToC(tnSheet)+BinToC(tnCellRow), "xl_rows", "id")
		  If xl_rows.maxcol < tnCellCol
		    Replace xl_rows.maxcol With tnCellCol In xl_rows
		  Endif
		Else
		  Insert Into xl_rows (workbook, Sheet, Row, maxcol) Values (tnWB, tnSheet, tnCellRow, tnCellCol)
		Endif
		
	ENDPROC

	PROCEDURE setsheetmargins		&& Sets the sheet margin values
		Lparameters tnWB, tnSheet, tnLeft, tnRight, tnTop, tnbot, tnHeader, tnFooter
		Local llReturn, lcAlias
		lcAlias = Alias()
		If Pcount() = 8 And This.GetSheetRecord(tnWB, tnSheet)
		  Replace xl_sheets.mleft   With tnLeft, ;
		    xl_sheets.mright  With tnRight, ;
		    xl_sheets.mtop    With tnTop, ;
		    xl_sheets.mbot    With tnbot, ;
		    xl_sheets.mheader With tnHeader, ;
		    xl_sheets.mfooter With tnFooter In xl_sheets
		  llReturn = True
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE setsheetscale		&& Sets the print scale; must be between 10 and 400; i.e. 10=10%, 100=100%, etc.
		Lparameters tnWB, tnSheet, tnScale
		Local llReturn, lcAlias
		lcAlias = Alias()
		If Pcount() = 3 And This.GetSheetRecord(tnWB, tnSheet)
		  If Between(Int(tnScale), 10, 400)
		    Replace xl_sheets.Scale With Int(tnScale) In xl_sheets
		    llReturn = True
		  Else
		    llReturn = False
		  Endif
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE setsheetvisibility		&& Sets the sheet visibility
		Lparameters tnWB, tnSheet, tnVisiblity
		Local llReturn, lcAlias
		llReturn = False
		lcAlias = Alias()
		If Pcount() = 3 And This.GetSheetRecord(tnWB, tnSheet)
		  If Between(tnVisiblity, VISIBLE_SHEET_STATE, VERYHIDDEN_SHEET_STATE)
		    Replace xl_sheets.state With tnVisiblity In xl_sheets
		    llReturn = True
		  Endif
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE ttoc3		&& Equlivalent of TTOC() function for pre VFP9 support
		Lparameters ttime
		Local lct
		If Pcount() < 1 Or Vartype(m.ttime) != "T"
		  Return
		Endif
		lct = Ttoc(m.ttime,1)
		Return Left(m.lct,4) + "-" + Substr(m.lct,5,2) + "-" + Substr(m.lct,7,2) + "T" + Substr(m.lct,9,2) + ":" + Substr(m.lct,11,2) + ":" + Right(m.lct,2)
		
	ENDPROC

	PROCEDURE unfreezepanes		&& Removes the pane freeze from the sheet
		Lparameters tnWB, tnSheet
		Local llReturn, lcAlias
		lcAlias = Alias()
		If This.GetSheetRecord(tnWB, tnSheet)
		  Replace xl_sheets.xsplit With 0, ;
		    xl_sheets.ysplit With 0 In xl_sheets
		  llReturn = True
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROCEDURE unmergedcells		&& Unmerges merged cells
		Lparameters tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol
		Local llReturn, lcAlias
		lcAlias = Alias()
		Select xl_mergecells
		Locate For workbook=tnWB And Sheet=tnSheet And begrow=tnBegRow And begcol=tnBegCol And endrow=tnEndRow And endcol=tnEndCol And !Deleted()
		If Found()
		  Delete In xl_mergecells
		  llReturn = True
		Else
		  llReturn = False
		Endif
		If !Empty(lcAlias)
		  Select (lcAlias)
		Endif
		Return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE writeasinlineformattedstring		&& Writes the string as formatted in-line
		Lparameters thFile, tnRow, tnCol, txCellValue
		* TODO: заменить на textmerge
		With This
		  Fwrite(thFile, '<c r="' + .ColumnIndexToAscii(tnCol) + Transform(tnRow) + '" t="inlineStr">')
		  Fwrite(thFile, '<is>')
		  Fwrite(thFile, '<r>')
		  Fwrite(thFile, '<rPr>')
		  Fwrite(thFile, '<sz val="' + Transform(.DefaultFontSize) + '"/>')
		  Fwrite(thFile, '<rFont val="' + .DefaultFont + '"/>')
		  Fwrite(thFile, '</rPr>')
		  Fwrite(thFile, '<t>' + .GetXMLString(txCellValue) + '</t>')
		  Fwrite(thFile, '</r>')
		  Fwrite(thFile, '</is>')
		  Fwrite(thFile, '</c>')
		Endwith
		
	ENDPROC

	PROTECTED PROCEDURE writeasinlinestring		&& Writes the value as an inlineStr value
		Lparameters thFile, tnRow, tnCol, txCellValue
		* TODO: заменить на textmerge
		With This
		  Fwrite(thFile, '<c r="' + .ColumnIndexToAscii(tnCol) + Transform(tnRow) + '" t="inlineStr">')
		  Fwrite(thFile, '<is><t>' + .GetXMLString(txCellValue) + '</t></is>')
		  Fwrite(thFile, '</c>')
		Endwith
		
	ENDPROC

	PROTECTED PROCEDURE writedirectcellformattedvalue		&& WriteDirectCellFormattedValue
		Lparameters thFile, tnRow, tnCol, txCellValue
		* TODO: заменить на textmerge
		With This
		  Do Case
		  Case Isnull(txCellValue)
		    Return
		
		  Case Inlist(Vartype(txCellValue), "C", "D", "T") And Empty(txCellValue)
		    Return
		
		  Case Vartype(txCellValue) = DATA_TYPE_DATE
		    .WriteAsInLineFormattedString(thFile, tnRow, tnCol, Transform(txCellValue))
		
		  Case Vartype(txCellValue) = DATA_TYPE_DATETIME
		    .WriteAsInLineFormattedString(thFile, tnRow, tnCol, Ttoc(txCellValue))
		
		  Case Vartype(txCellValue) = DATA_TYPE_LOGICAL
		    txCellValue = Iif(txCellValue, Getwordnum(.TrueFalseValue, 1, "|"), Getwordnum(.TrueFalseValue, 2, "|"))
		    .WriteAsInLineFormattedString(thFile, tnRow, tnCol, txCellValue)
		
		  Case Vartype(txCellValue) = DATA_TYPE_CURRENCY
		    Fwrite(thFile, '<c r="' + .ColumnIndexToAscii(tnCol) + Transform(tnRow) + '" t="n">')
		    Fwrite(thFile, '<v>' + Transform(Mton(txCellValue)) + '</v></c>')
		
		  Case Vartype(txCellValue) = DATA_TYPE_CHAR
		    .WriteAsInLineFormattedString(thFile, tnRow, tnCol, Alltrim(txCellValue))
		
		  Case Inlist(Vartype(txCellValue), DATA_TYPE_INT, DATA_TYPE_FLOAT)
		    Fwrite(thFile, '<c r="' + .ColumnIndexToAscii(tnCol) + Transform(tnRow) + '" t="n">')
		    Fwrite(thFile, '<v>' + Transform(txCellValue) + '</v></c>')
		
		  Otherwise
		    Fwrite(thFile, '<c r="' + .ColumnIndexToAscii(tnCol) + Transform(tnRow) + '" t="inlineStr">')
		    Fwrite(thFile, '<is><t>Unsupported Field Type</t></is></c>')
		  Endcase
		Endwith
		
	ENDPROC

	PROTECTED PROCEDURE writedirectcellvalue		&& Writes the cell value directly to the sheets xml
		Lparameters thFile, tnRow, tnCol, txCellValue
		* TODO: заменить на textmerge
		With This
		  Do Case
		  Case Isnull(txCellValue)
		    Return
		
		  Case Inlist(Vartype(txCellValue), "C", "D", "T") And Empty(txCellValue)
		    Return
		
		  Case Vartype(txCellValue) = DATA_TYPE_DATE
		    .WriteAsInLineString(thFile, tnRow, tnCol, Transform(txCellValue))
		
		  Case Vartype(txCellValue) = DATA_TYPE_DATETIME
		    .WriteAsInLineString(thFile, tnRow, tnCol, Ttoc(txCellValue))
		
		  Case Vartype(txCellValue) = DATA_TYPE_LOGICAL
		    txCellValue = Iif(txCellValue, Getwordnum(.TrueFalseValue, 1, "|"), Getwordnum(.TrueFalseValue, 2, "|"))
		    .WriteAsInLineString(thFile, tnRow, tnCol, txCellValue)
		
		  Case Vartype(txCellValue) = DATA_TYPE_CURRENCY
		    Fwrite(thFile, '<c r="' + .ColumnIndexToAscii(tnCol) + Transform(tnRow) + '" t="n">')
		    Fwrite(thFile, '<v>' + Transform(Mton(txCellValue)) + '</v></c>')
		
		  Case Vartype(txCellValue) = DATA_TYPE_CHAR
		    .WriteAsInLineString(thFile, tnRow, tnCol, Alltrim(txCellValue))
		
		  Case Inlist(Vartype(txCellValue), DATA_TYPE_INT, DATA_TYPE_FLOAT)
		    Fwrite(thFile, '<c r="' + .ColumnIndexToAscii(tnCol) + Transform(tnRow) + '" t="n">')
		    Fwrite(thFile, '<v>' + Transform(txCellValue) + '</v></c>')
		
		  Otherwise
		    Fwrite(thFile, '<c r="' + .ColumnIndexToAscii(tnCol) + Transform(tnRow) + '" t="inlineStr">')
		    Fwrite(thFile, '<is><t>Unsupported Field Type</t></is></c>')
		  Endcase
		Endwith
		
	ENDPROC

	PROTECTED PROCEDURE writedirectxmls		&& Writes the workbook XMLs for direct table/grid to workbook output
		Lparameters tcPath, taSheetNames
		Local lhFile, lcFileName, loException, lcSheetName, lnSheet, lnNumSheets
		External Array taSheetNames
		*-*	Create the supporting XML files
		* TODO: заменить на textmerge
		With This
		  loException = Null
		  Try
		    lnNumSheets = Alen(taSheetNames, 1)
		  Catch To loException
		  Endtry
		  If !Isnull(loException)
		    Return False
		  Endif
		  Try
		    lhFile = Fcreate(tcPath + "[Content_Types].xml")
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">')
		    Fwrite(lhFile, '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>')
		    Fwrite(lhFile, '<Default Extension="xml" ContentType="application/xml"/>')
		    Fwrite(lhFile, '<Override ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" PartName="/xl/workbook.xml"/>')
		    Fwrite(lhFile, '<Override ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" PartName="/xl/styles.xml"/>')
		    For lnSheet=1 To lnNumSheets
		      Fwrite(lhFile, '<Override ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" PartName="/xl/worksheets/sheet' + Transform(lnSheet) + '.xml"/>')
		    Endfor
		    Fwrite(lhFile, '<Override ContentType="application/vnd.openxmlformats-package.core-properties+xml" PartName="/docProps/core.xml"/>')
		    Fwrite(lhFile, '<Override ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml" PartName="/docProps/app.xml"/>')
		    Fwrite(lhFile, '</Types>')
		    Fclose(lhFile)
		
		*-*	Save the .rels XML
		    lhFile = Fcreate(tcPath + "_rels\.rels")
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">')
		    Fwrite(lhFile, '<Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>')
		    Fwrite(lhFile, '<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>')
		    Fwrite(lhFile, '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>')
		    Fwrite(lhFile, '</Relationships>')
		    Fclose(lhFile)
		
		*-*	Write the workbook relationships file
		    lhFile = Fcreate(tcPath + "xl\_rels\workbook.xml.rels")
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">')
		    Fwrite(lhFile, '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>')
		    For lnSheet=1 To lnNumSheets
		      Fwrite(lhFile, '<Relationship Id="rId' + Transform(lnSheet+1) + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet' + Transform(lnSheet) + '.xml"/>')
		    Endfor
		    Fwrite(lhFile, '</Relationships>')
		    Fclose(lhFile)
		
		*-*	Save the app XML
		    lcFileName = tcPath + "docProps\app.xml"
		    lhFile = Fcreate(lcFileName)
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">')
		    Fwrite(lhFile, '<Application>ExcelXMLX Release ' + Transform(.ExcelXlsxRelease) + '</Application>')
		    If !Empty(.CompanyName)
		      Fwrite(lhFile, '<Company>' + .CompanyName + '</Company>')
		    Endif
		    Fwrite(lhFile, '</Properties>')
		    Fclose(lhFile)
		    .SaveAsUTF8(lcFileName)
		
		*-*	Save the core XML
		    lcFileName = tcPath + "docProps\core.xml"
		    lhFile = Fcreate(lcFileName)
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<cp:coreProperties ')
		    Fwrite(lhFile, 'xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" ')
		    Fwrite(lhFile, 'xmlns:dc="http://purl.org/dc/elements/1.1/" ')
		    Fwrite(lhFile, 'xmlns:dcterms="http://purl.org/dc/terms/" ')
		    Fwrite(lhFile, 'xmlns:dcmitype="http://purl.org/dc/dcmitype/" ')
		    Fwrite(lhFile, 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">')
		    If !Empty(.Title)
		      Fwrite(lhFile, '<dc:title>' + .GetXMLString(.Title) + '</dc:title>')
		    Endif
		    If !Empty(.Subject)
		      Fwrite(lhFile, '<dc:subject>' + .GetXMLString(.Subject) + '</dc:subject>')
		    Endif
		    If !Empty(.CreatorName)
		      Fwrite(lhFile, '<dc:creator>' + .GetXMLString(.CreatorName) + '</dc:creator>')
		    Endif
		    If !Empty(.UserName)
		      Fwrite(lhFile, '<cp:lastModifiedBy>' + .GetXMLString(.UserName) + '</cp:lastModifiedBy>')
		    Endif
		    If Version(5) < 900
		      Fwrite(lhFile, '<dcterms:created xsi:type="dcterms:W3CDTF">' + .TTOC3(Datetime()) + 'Z</dcterms:created>')
		      Fwrite(lhFile, '<dcterms:modified xsi:type="dcterms:W3CDTF">' + .TTOC3(Datetime()) + 'Z</dcterms:modified>')
		    Else
		      Fwrite(lhFile, '<dcterms:created xsi:type="dcterms:W3CDTF">' + Ttoc(Datetime(), 3) + 'Z</dcterms:created>')
		      Fwrite(lhFile, '<dcterms:modified xsi:type="dcterms:W3CDTF">' + Ttoc(Datetime(), 3) + 'Z</dcterms:modified>')
		    Endif
		    Fwrite(lhFile, '</cp:coreProperties>')
		    Fclose(lhFile)
		    .SaveAsUTF8(lcFileName)
		
		*-*	Save the styles XML
		    lcFileName = tcPath + "xl\styles.xml"
		    lhFile = Fcreate(lcFileName)
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" ')
		    Fwrite(lhFile, 'xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" ')
		    Fwrite(lhFile, 'mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">')
		    Fwrite(lhFile, '<fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>')
		    Fwrite(lhFile, '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>')
		    Fwrite(lhFile, '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>')
		    Fwrite(lhFile, '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>')
		    Fwrite(lhFile, '<cellXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/></cellXfs>')
		    Fwrite(lhFile, '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>')
		    Fwrite(lhFile, '</styleSheet>')
		    Fclose(lhFile)
		    .SaveAsUTF8(lcFileName)
		
		*-*	Write the workbook XML
		    lcFileName = tcPath + "xl\workbook.xml"
		    lhFile = Fcreate(lcFileName)
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+ LF)
		    Fwrite(lhFile, '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">')
		    Fwrite(lhFile, '<sheets>')
		    For lnSheet=1 To lnNumSheets
		      If Empty(taSheetNames[lnSheet])
		        lcSheetName = "Sheet" + Transform(lnSheet)
		      Else
		        lcSheetName = taSheetNames[lnSheet]
		      Endif
		      Fwrite(lhFile, '<sheet name="' + lcSheetName + '" sheetId="' + Transform(lnSheet) + '" r:id="rId' + Transform(lnSheet+1) + '"/>')
		    Endfor
		    Fwrite(lhFile, '</sheets>')
		    Fwrite(lhFile, '<calcPr calcId="0"/>')
		    Fwrite(lhFile, '</workbook>')
		    Fclose(lhFile)
		    .SaveAsUTF8(lcFileName)
		
		  Catch To loException
		    Set Step On
		    Fclose(lhFile)
		    .ErrorLevelId = 18
		    Raiseevent(This, "OnShowErrorMessage", 18, "Unable to create workbook supporting XMLs")
		  Endtry
		Endwith
		Return Isnull(loException)
		
	ENDPROC

	PROTECTED PROCEDURE writerelationshipsxml		&& Writes the relationships xml file
		Lparameters tnWB, tcPath
		Local lhFile, lcBaseType, llSuccess
		* TODO: заменить на textmerge
		With This
		  Raiseevent(This, "OnShowStatusMessage", 2, 5)
		  lcBaseType = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/"
		  Try
		*-*	Write the workbook relationships file
		    lhFile = Fcreate(tcPath + "xl\_rels\workbook.xml.rels")
		    If lhFile < 0
		      Throw
		    Endif
		
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">')
		
		    Select xl_relationships
		    Scan For workbook = tnWB
		      Fwrite(lhFile, '<Relationship Id="rId' + Transform(xl_relationships.relid) + '" Target="' + Alltrim(xl_relationships.Target) + '" Type="' + lcBaseType + Alltrim(xl_relationships.reltype) + '"/>')
		    Endscan
		
		    Fwrite(lhFile, '</Relationships>')
		    llSuccess = True
		
		  Catch To loException
		    Set Step On
		    llSuccess = False
		    .ErrorLevelId = 16
		    Raiseevent(This, "OnShowErrorMessage", 16, "Unable to create workbook.xml.rels")
		
		  Finally
		    Fclose(lhFile)
		  Endtry
		Endwith
		Return llSuccess
		
	ENDPROC

	PROTECTED PROCEDURE writesheetxmls		&& Writes the Sheet XML files
		Lparameters tnWB, tnSheetNbr, tcPath
		Local llSuccess, lcAlias, lhFile, lcRow, lnMinCol, lnMaxCol, lnWidth, lnLastRow, lcDyDescent
		Local lcRowDefHt, lcFileName
		*-*	Write the sheet XML
		* TODO: заменить на textmerge
		With This
		  lcAlias = Alias()
		*-*	Write the sheet
		  Try
		    lcFileName = tcPath + "xl\worksheets\sheet" + Transform(tnSheetNbr) + ".xml"
		    lhFile = Fcreate(lcFileName)
		    If lhFile < 0
		      Throw
		    Endif
		*	lcDyDescent = ' x14ac:dyDescent="0.25"'                && Uncomment to add back...
		    lcDyDescent = ''
		    lcRowDefHt  = ' ht="30"'
		
		*-*	Write sheet XML header information
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"')
		    Fwrite(lhFile, ' xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"')
		    Fwrite(lhFile, ' xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac"')
		    Fwrite(lhFile, ' xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">')
		
		*-*	Write the tab color definition if set
		    Do Case
		    Case xl_sheets.tabcolorndx > 0
		      Fwrite(lhFile, '<sheetPr codeName="Sheet' + Transform(tnSheetNbr) + '"><tabColor indexed="' + Transform(xl_sheets.tabcolorndx) + '"/></sheetPr>')
		
		    Case !Empty(xl_sheets.tabcolorrgb)
		      Fwrite(lhFile, '<sheetPr codeName="Sheet' + Transform(tnSheetNbr) + '"><tabColor rgb="' + xl_sheets.tabcolorrgb + '"/></sheetPr>')
		    Endcase
		
		*-*	Verify cells have been written
		    Select xl_cells
		    Locate For workbook = tnWB And Sheet = xl_sheets.Sheet And !celldeleted
		    If Found()
		*-*		Write the sheet view information which includes the freeze pane information
		      Select cel.Sheet, Max(cel.cellrow) As maxrow, Max(cel.cellcol) As maxcol ;
		        FROM xl_cells As cel ;
		        WHERE cel.workbook = tnWB ;
		        AND cel.Sheet = xl_sheets.Sheet ;
		        AND cel.celldeleted = False ;
		        GROUP By 1 ;
		        INTO Cursor t_max Readwrite
		
		      Fwrite(lhFile, '<dimension ref="A1:' + .ColumnIndexToAscii(t_max.maxcol) + Transform(t_max.maxrow) + '"/>')
		      Do Case
		      Case xl_sheets.ysplit > 0 And xl_sheets.xsplit = 0      && Freeze top row(s) only
		        Fwrite(lhFile, '<sheetViews><sheetView workbookViewId="0">')
		        lcRow = Transform(xl_sheets.ysplit+1)
		        Fwrite(lhFile, '<pane state="frozenSplit" activePane="bottomLeft" topLeftCell="A' + lcRow + '" ySplit="' + Transform(xl_sheets.ysplit) + '"/>')
		        Fwrite(lhFile, '<selection activeCell="A' + lcRow + '" sqref="A' + lcRow + '" pane="bottomLeft"/>')
		
		      Case xl_sheets.ysplit = 0 And xl_sheets.xsplit > 0      && Freeze side column(s) only
		        Fwrite(lhFile, '<sheetViews><sheetView workbookViewId="0">')
		        lcColumn = .ColumnIndexToAscii(xl_sheets.xsplit+1)
		        Fwrite(lhFile, '<pane state="frozenSplit" activePane="bottomLeft" topLeftCell="' + lcColumn + '1" xSplit="' + Transform(xl_sheets.xsplit) + '"/>')
		        Fwrite(lhFile, '<selection activeCell="' + lcColumn + '1" sqref="' + lcColumn + '1" pane="topRight"/>')
		
		      Case xl_sheets.ysplit > 0 And xl_sheets.xsplit > 0      && Freeze both top row(s) and side column(s)
		        Fwrite(lhFile, '<sheetViews><sheetView workbookViewId="0">')
		        lcRow = Transform(xl_sheets.ysplit+1)
		        lcColumn = .ColumnIndexToAscii(xl_sheets.xsplit+1)
		        Fwrite(lhFile, '<pane state="frozenSplit" activePane="bottomRight" topLeftCell="' + lcColumn + lcRow + ;
		          '" ySplit="' + Transform(xl_sheets.ysplit) + '" xSplit="' + Transform(xl_sheets.xsplit) + '"/>')
		        Fwrite(lhFile, '<selection activeCell="' + .ColumnIndexToAscii(xl_sheets.xsplit) + '1" sqref="' + .ColumnIndexToAscii(xl_sheets.xsplit) + '1" pane="topRight"/>')
		        Fwrite(lhFile, '<selection activeCell="' + .ColumnIndexToAscii(xl_sheets.xsplit) + lcRow + '" sqref="' + .ColumnIndexToAscii(xl_sheets.xsplit) + lcRow + '" pane="bottomLeft"/>')
		        Fwrite(lhFile, '<selection activeCell="' + lcColumn + lcRow + '" sqref="' + lcColumn + lcRow + '" pane="bottomRight"/>')
		
		      Otherwise
		        Fwrite(lhFile, '<sheetViews><sheetView workbookViewId="0"><selection activeCell="A1" sqref="A1"/>')
		*				FWRITE(lhFile, '<sheetViews><sheetView tabSelected="1" workbookViewId="0">')
		      Endcase
		      Fwrite(lhFile, '</sheetView></sheetViews>')
		      Fwrite(lhFile, '<sheetFormatPr defaultRowHeight="15"' + lcDyDescent + '/>')
		
		*-*		Write sheet Column widths
		      Select clm.Column, clm.Width, clm.bestfit From xl_colwidths As clm ;
		        WHERE clm.workbook = tnWB ;
		        AND clm.Sheet = xl_sheets.Sheet ;
		        ORDER By clm.Column ;
		        INTO Cursor t_colwidths Readwrite
		
		      If _Tally > 0
		        Fwrite(lhFile, '<cols>')
		        Select t_colwidths
		        Goto Top
		        lnMinCol = t_colwidths.Column
		        lnMaxCol = t_colwidths.Column
		        lnWidth  = t_colwidths.Width
		        Skip In t_colwidths
		        Do While !Eof('t_colwidths')
		          Do Case
		*					CASE t_colwidths.bestfit    && Not yet working!!!
		*						FWRITE(lhFile, '<col min="' + TRANSFORM(t_colwidths.column) + '" max="' + TRANSFORM(t_colwidths.column) + '" bestFit="1" customWidth="1"/>')
		
		          Case t_colwidths.Width = lnWidth And t_colwidths.Column-1 = lnMinCol
		            lnMaxCol = t_colwidths.Column
		
		          Otherwise
		            Fwrite(lhFile, '<col min="' + Transform(lnMinCol) + '" max="' + Transform(lnMaxCol) + ;
		              '" width="' + Transform(lnWidth+0.7109375) + '" customWidth="1"/>')
		            lnMinCol = t_colwidths.Column
		            lnMaxCol = t_colwidths.Column
		            lnWidth  = t_colwidths.Width
		          Endcase
		          Skip In t_colwidths
		        Enddo
		        Fwrite(lhFile, '<col min="' + Transform(lnMinCol) + '" max="' + Transform(lnMaxCol) + '" width="' + Transform(lnWidth+0.7109375) + '" customWidth="1"/>')
		        Fwrite(lhFile, '</cols>')
		      Endif
		      Use In Select('t_colwidths')
		
		*-*		Write sheet cell data values
		      Fwrite(lhFile, '<sheetData>')
		*		lnLastRow = 0
		      lnHeadRow = 0
		      Select xl_cells
		      Set Order To Tag cellindex
		      Scan For workbook = tnWB And Sheet = xl_sheets.Sheet And !celldeleted
		*-*			Write row header
		        If lnHeadRow != xl_cells.cellrow
		          If lnHeadRow != 0
		            Fwrite(lhFile, '</row>')
		          Endif
		          lnHeadRow = xl_cells.cellrow
		          lnMaxCol  = .GetRowMaxColumn(tnWB, xl_sheets.Sheet, lnHeadRow)
		          If Seek(.GetRowHeightKeyExpr(tnWB, xl_sheets.Sheet, xl_cells.cellrow), "xl_rowheights", "shrow")
		            Fwrite(lhFile, '<row r="' + Transform(xl_cells.cellrow) + '" spans="1:' + Transform(lnMaxCol) + ;
		              '" ht="' + Transform(xl_rowheights.Height) + '" customHeight="1">')
		          Else
		            Fwrite(lhFile, '<row r="' + Transform(xl_cells.cellrow) + '" spans="1:' + Transform(lnMaxCol) + '"' + lcRowDefHt + '>')
		          Endif
		        Endif
		*-*			Write columns
		        If xl_cells.cellxfs > 0
		          lcStyle = ' s="' + Transform(xl_cells.cellxfs) + '"'
		        Else
		          lcStyle = ''
		        Endif
		        Do Case
		        Case xl_cells.DataType = DATA_TYPE_TIME
		          Fwrite(lhFile, '<c r="' + .ColumnIndexToAscii(xl_cells.cellcol) + Transform(xl_cells.cellrow) + '"' + lcStyle + '>')
		          Fwrite(lhFile, '<v>' + Alltrim(xl_cells.cellvalue) + '</v></c>')
		
		        Case xl_cells.DataType = DATA_TYPE_DATE
		          Fwrite(lhFile, '<c r="' + .ColumnIndexToAscii(xl_cells.cellcol) + Transform(xl_cells.cellrow) + '"' + lcStyle + '>')
		          Fwrite(lhFile, '<v>' + Alltrim(xl_cells.cellvalue) + '</v></c>')
		
		        Case xl_cells.DataType = DATA_TYPE_DATETIME
		          Fwrite(lhFile, '<c r="' + .ColumnIndexToAscii(xl_cells.cellcol) + Transform(xl_cells.cellrow) + '"' + lcStyle + '>')
		          Fwrite(lhFile, '<v>' + Alltrim(xl_cells.cellvalue) + '</v></c>')
		
		        Case xl_cells.DataType = DATA_TYPE_LOGICAL
		          Fwrite(lhFile, '<c r="' + .ColumnIndexToAscii(xl_cells.cellcol) + Transform(xl_cells.cellrow) + '"' + lcStyle + ' t="s"' + '>')
		          Fwrite(lhFile, '<v>' + Transform(xl_cells.stringid) + '</v></c>')
		
		        Case xl_cells.DataType = DATA_TYPE_CHAR
		          Fwrite(lhFile, '<c r="' + .ColumnIndexToAscii(xl_cells.cellcol) + Transform(xl_cells.cellrow) + '"' + lcStyle + ' t="s"' + '>')
		          Fwrite(lhFile, '<v>' + Transform(xl_cells.stringid) + '</v></c>')
		
		        Case xl_cells.DataType = DATA_TYPE_INT
		          Fwrite(lhFile, '<c r="' + .ColumnIndexToAscii(xl_cells.cellcol) + Transform(xl_cells.cellrow) + '"' + lcStyle + '>')
		          Fwrite(lhFile, '<v>' + Alltrim(xl_cells.cellvalue) + '</v></c>')
		
		        Case xl_cells.DataType = DATA_TYPE_FLOAT
		          Fwrite(lhFile, '<c r="' + .ColumnIndexToAscii(xl_cells.cellcol) + Transform(xl_cells.cellrow) + '"' + lcStyle + '>')
		          Fwrite(lhFile, '<v>' + Alltrim(xl_cells.cellvalue) + '</v></c>')
		
		        Case xl_cells.DataType = DATA_TYPE_CURRENCY
		          Fwrite(lhFile, '<c r="' + .ColumnIndexToAscii(xl_cells.cellcol) + Transform(xl_cells.cellrow) + '"' + lcStyle + '>')
		          Fwrite(lhFile, '<v>' + Alltrim(xl_cells.cellvalue) + '</v></c>')
		
		        Case xl_cells.DataType = DATA_TYPE_PERCENT
		          Fwrite(lhFile, '<c r="' + .ColumnIndexToAscii(xl_cells.cellcol) + Transform(xl_cells.cellrow) + '"' + lcStyle + '>')
		          Fwrite(lhFile, '<v>' + Alltrim(xl_cells.cellvalue) + '</v></c>')
		
		        Case xl_cells.DataType = DATA_TYPE_FORMULA
		          Fwrite(lhFile, '<c r="' + .ColumnIndexToAscii(xl_cells.cellcol) + Transform(xl_cells.cellrow) + '"' + lcStyle + ' t="str"' + '>')
		          Fwrite(lhFile, '<f>' + Alltrim(xl_cells.cellformula) + '</f><v>' + Alltrim(xl_cells.cellvalue) + '</v></c>')
		
		        Case xl_cells.DataType = DATA_TYPE_NONE
		          If !Empty(lcStyle)
		            Fwrite(lhFile, '<c r="' + .ColumnIndexToAscii(xl_cells.cellcol) + Transform(xl_cells.cellrow) + '"' + lcStyle + '></c>')
		          Endif
		        Endcase
		      Endscan
		      Fwrite(lhFile, '</row>')
		      Fwrite(lhFile, '</sheetData>')
		      Set Order To
		      Use In t_max
		
		    Else
		*-*		No cell data has been created/written
		      Fwrite(lhFile, '<dimension ref="A1"/>')
		      Fwrite(lhFile, '<sheetViews>')
		      Fwrite(lhFile, '<sheetView workbookViewId="0"/>')
		      Fwrite(lhFile, '</sheetViews>')
		      Fwrite(lhFile, '<sheetFormatPr defaultRowHeight="14.4"/>')
		      Fwrite(lhFile, '<sheetData/>')
		    Endif
		*-*	Write sheet merge data
		    Select mrg.begrow, mrg.begcol, mrg.endrow, mrg.endcol From xl_mergecells As mrg ;
		      WHERE mrg.workbook = tnWB ;
		      AND mrg.Sheet = xl_sheets.Sheet ;
		      ORDER By mrg.begrow ;
		      INTO Cursor t_merge
		
		    If _Tally > 0
		      Fwrite(lhFile, '<mergeCells>')
		      Select t_merge
		      Scan
		        Fwrite(lhFile, '<mergeCell ref="' + .ColumnIndexToAscii(t_merge.begcol) + Transform(t_merge.begrow) + ':' + ;
		          .ColumnIndexToAscii(t_merge.endcol) + Transform(t_merge.endrow) + '"/>')
		      Endscan
		      Fwrite(lhFile, '</mergeCells>')
		    Endif
		    Use In t_merge
		
		*-*	Write the cell validation data
		    Select xl_validation
		    Count For xl_validation.workbook = tnWB And xl_validation.Sheet = xl_sheets.Sheet And !Deleted() To lnValidCnt
		    If lnValidCnt > 0
		      Fwrite(lhFile, '<dataValidations count="' + Transform(lnValidCnt) + '">')
		      Scan
		        Select xl.cellrow, xl.cellcol From xl_cells As xl ;
		          WHERE BinToC(xl.workbook)+BinToC(xl.Sheet)+BinToC(xl.validndx) = BinToC(tnWB)+BinToC(xl_sheets.Sheet)+BinToC(xl_validation.validndx) ;
		          ORDER By xl.cellrow, xl.cellcol ;
		          INTO Cursor t_celllist
		        Select t_celllist
		        lcSqRef = ""
		        Scan
		          lcSqRef = lcSqRef + .ColumnIndexToAscii(t_celllist.cellcol) + Transform(t_celllist.cellrow) + " "
		        Endscan
		        lcSqRef = Alltrim(lcSqRef)
		        Do Case
		        Case xl_validation.vtype = NONE_VALID_TYPE
		          lcValidationText = 'type="none"'
		
		        Case xl_validation.vtype = WHOLE_VALID_TYPE
		          lcValidationText = 'type="whole"'
		
		        Case xl_validation.vtype = DECIMAL_VALID_TYPE
		          lcValidationText = 'type="decimal"'
		
		        Case xl_validation.vtype = LIST_VALID_TYPE
		          lcValidationText = 'type="list"'
		
		        Case xl_validation.vtype = DATE_VALID_TYPE
		          lcValidationText = 'type="date"'
		
		        Case xl_validation.vtype = TIME_VALID_TYPE
		          lcValidationText = 'type="time"'
		
		        Case xl_validation.vtype = TXTLEN_VALID_TYPE
		          lcValidationText = 'type="textLength"'
		
		        Case xl_validation.vtype = CUSTOM_VALID_TYPE
		          lcValidationText = 'type="custom"'
		
		        Otherwise
		          lcValidationText = 'type="none"'
		        Endcase
		        If xl_validation.vstyle > 0
		          Do Case
		          Case xl_validation.vstyle = STOP_VALID_STYLE
		            lcValidationText = lcValidationText + ' errorStyle="stop"'
		
		          Case xl_validation.vstyle = WARN_VALID_STYLE
		            lcValidationText = lcValidationText + ' errorStyle="warning"'
		
		          Case xl_validation.vstyle = INFO_VALID_STYLE
		            lcValidationText = lcValidationText + ' errorStyle="information"'
		          Endcase
		        Endif
		        If xl_validation.voperator > 0
		          Do Case
		          Case xl_validation.voperator = BETWEEN_VALID_OPER
		            lcValidationText = lcValidationText + ' operator="between"'
		
		          Case xl_validation.voperator = NOTBETW_VALID_OPER
		            lcValidationText = lcValidationText + ' operator="notBetween"'
		
		          Case xl_validation.voperator = EQUAL_VALID_OPER
		            lcValidationText = lcValidationText + ' operator="equal"'
		
		          Case xl_validation.voperator = NOTEQUAL_VALID_OPER
		            lcValidationText = lcValidationText + ' operator="notEqual"'
		
		          Case xl_validation.voperator = LESSTHAN_VALID_OPER
		            lcValidationText = lcValidationText + ' operator="lessThan"'
		
		          Case xl_validation.voperator = LESSOREQUAL_VALID_OPER
		            lcValidationText = lcValidationText + ' operator="lessThanOrEqual"'
		
		          Case xl_validation.voperator = GREATTHAN_VALID_OPER
		            lcValidationText = lcValidationText + ' operator="greaterThan"'
		
		          Case xl_validation.voperator = GREATOREQUAL_VALID_OPER
		            lcValidationText = lcValidationText + ' operator="greaterThanOrEqual"'
		          Endcase
		        Endif
		        lcValidationText = lcValidationText + ' allowBlank="' + Iif(xl_validation.allowblank, '1', '0') + '"'
		        lcValidationText = lcValidationText + ' showInputMessage="' + Iif(xl_validation.showinpmsg, '1', '0') + '"'
		        lcValidationText = lcValidationText + ' showErrorMessage="' + Iif(xl_validation.showerrmsg, '1', '0') + '"'
		        If !Empty(xl_validation.errtitle)
		          lcValidationText = lcValidationText + ' errorTitle="' + Alltrim(xl_validation.errtitle) + '"'
		        Endif
		        If !Empty(xl_validation.errmsg)
		          lcValidationText = lcValidationText + ' error="' + Alltrim(xl_validation.errmsg) + '"'
		        Endif
		        If !Empty(xl_validation.vprompt)
		          lcValidationText = lcValidationText + ' prompt="' + Alltrim(xl_validation.vprompt) + '"'
		        Endif
		        Fwrite(lhFile, '<dataValidation ' + lcValidationText + ' sqref="' + lcSqRef + '">')
		        If xl_validation.formula
		          Fwrite(lhFile, '<formula1>' + Alltrim(xl_validation.formula1) + '</formula1>')
		          If !Empty(xl_validation.formula2)
		            Fwrite(lhFile, '<formula2>' + Alltrim(xl_validation.formula2) + '</formula2>')
		          Endif
		        Else
		          Fwrite(lhFile, '<formula1>"' + Alltrim(xl_validation.formula1) + '"</formula1>')
		          If !Empty(xl_validation.formula2)
		            Fwrite(lhFile, '<formula2>"' + Alltrim(xl_validation.formula2) + '"</formula2>')
		          Endif
		        Endif
		        Fwrite(lhFile, '</dataValidation>')
		      Endscan
		      Use In Select('t_celllist')
		      Fwrite(lhFile, '</dataValidations>')
		    Endif
		
		*-*	Write sheet margin data
		    Fwrite(lhFile, '<pageMargins left="' + Rtrim(Transform(xl_sheets.mleft), 1, '0') + '" right="' + Rtrim(Transform(xl_sheets.mright), 1, '0') + ;
		      '" top="' + Rtrim(Transform(xl_sheets.mtop), 1, '0') + '" bottom="' + Rtrim(Transform(xl_sheets.mbot), 1, '0') + ;
		      '" header="' + Rtrim(Transform(xl_sheets.mheader), 1, '0') + '" footer="' + Rtrim(Transform(xl_sheets.mfooter), 1, '0') + '"/>')
		
		*-*	Write the sheet page print setup
		    Fwrite(lhFile, '<pageSetup orientation="' + Iif(xl_sheets.prnorient=PORTRAIT_PRINT_ORIENTATION, 'portrait', 'landscape') + '"')
		    If xl_sheets.Paperwidth > 0 And xl_sheets.paperheight > 0
		      Fwrite(lhFile, ' paperHeight="' + Transform(xl_sheets.paperheight) + xl_sheets.paperdimen + '"')
		      Fwrite(lhFile, ' paperWidth="' + Transform(xl_sheets.Paperwidth) + xl_sheets.paperdimen + '"')
		    Else
		      If xl_sheets.Papersize > 0
		        Fwrite(lhFile, ' paperSize="' + Transform(xl_sheets.Papersize) + '"')
		      Endif
		    Endif
		    Do Case
		    Case xl_sheets.fittowidth > 0 And xl_sheets.fittoheight > 0
		      Fwrite(lhFile, ' fitToWidth="'  + Transform(xl_sheets.fittowidth) + '"')
		      Fwrite(lhFile, ' fitToHeight="' + Transform(xl_sheets.fittoheight) + '"')
		
		    Case xl_sheets.fittowidth = 0 And xl_sheets.fittoheight > 0
		      Fwrite(lhFile, ' fitToHeight="' + Transform(xl_sheets.fittoheight) + '"')
		
		    Case xl_sheets.fittowidth > 0 And xl_sheets.fittoheight = 0
		      Fwrite(lhFile, ' fitToWidth="'  + Transform(xl_sheets.fittowidth) + '"')
		
		    Otherwise
		      If xl_sheets.Scale != 100
		        Fwrite(lhFile, ' scale="' + Transform(xl_sheets.Scale) + '"')
		      Endif
		    Endcase
		    Fwrite(lhFile, '/>')
		
		*-*	Write the header and footer for the sheet if defined
		    If Seek(BinToC(tnWB)+BinToC(xl_sheets.Sheet), "xl_hdrfooterdefn", "wbsheet")
		      Fwrite(lhFile, '<headerFooter')
		      If xl_hdrfooterdefn.alignmargin
		        Fwrite(lhFile, ' alignWithMargins="1"')
		      Endif
		      If xl_hdrfooterdefn.difffirstpg
		        Fwrite(lhFile, ' differentFirst="1"')
		      Endif
		      If xl_hdrfooterdefn.diffoddeven
		        Fwrite(lhFile, ' differentOddEven="1"')
		      Endif
		      If xl_hdrfooterdefn.scalewdoc
		        Fwrite(lhFile, ' scaleWithDoc="1"')
		      Endif
		      Fwrite(lhFile, '>')
		
		*-*		Get the page header text
		      lcOddText = ""
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_ODD_PAGE, HEADERFOOTER_SECT_HDR_LEFT), "xl_hdrfootertext", "hdrfootr")
		        lcOddText = Iif(Empty(lcOddText), '<oddHeader>', lcOddText) + '&amp;L&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_ODD_PAGE, HEADERFOOTER_SECT_HDR_CENTER), "xl_hdrfootertext", "hdrfootr")
		        lcOddText = Iif(Empty(lcOddText), '<oddHeader>', lcOddText) + '&amp;C&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_ODD_PAGE, HEADERFOOTER_SECT_HDR_RIGHT), "xl_hdrfootertext", "hdrfootr")
		        lcOddText = Iif(Empty(lcOddText), '<oddHeader>', lcOddText) + '&amp;R&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If !Empty(lcOddText)
		        lcOddText = lcOddText + '</oddHeader>'
		      Endif
		
		      lcEvenText = ""
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_EVEN_PAGE, HEADERFOOTER_SECT_HDR_LEFT), "xl_hdrfootertext", "hdrfootr")
		        lcEvenText = Iif(Empty(lcEvenText), '<evenHeader>', lcEvenText) + '&amp;L&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_EVEN_PAGE, HEADERFOOTER_SECT_HDR_CENTER), "xl_hdrfootertext", "hdrfootr")
		        lcEvenText = Iif(Empty(lcEvenText), '<evenHeader>', lcEvenText) + '&amp;C&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_EVEN_PAGE, HEADERFOOTER_SECT_HDR_RIGHT), "xl_hdrfootertext", "hdrfootr")
		        lcEvenText = Iif(Empty(lcEvenText), '<evenHeader>', lcEvenText) + '&amp;R&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If !Empty(lcEvenText)
		        lcEvenText = lcEvenText + '</evenHeader>'
		      Endif
		
		      lcSameText = ""
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_HDR_LEFT), "xl_hdrfootertext", "hdrfootr")
		        lcSameText = Iif(Empty(lcSameText), '<oddHeader>', lcSameText) + '&amp;L&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_HDR_CENTER), "xl_hdrfootertext", "hdrfootr")
		        lcSameText = Iif(Empty(lcSameText), '<oddHeader>', lcSameText) + '&amp;C&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_HDR_RIGHT), "xl_hdrfootertext", "hdrfootr")
		        lcSameText = Iif(Empty(lcSameText), '<oddHeader>', lcSameText) + '&amp;R&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If !Empty(lcSameText)
		        lcSameText = lcSameText + '</oddHeader>'
		      Endif
		      If Empty(lcSameText)
		        lcHeaderText = lcOddText + lcEvenText
		      Else
		        lcHeaderText = lcSameText
		      Endif
		
		*-*		Get the page footer text
		      lcOddText = ""
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_ODD_PAGE, HEADERFOOTER_SECT_FTR_LEFT), "xl_hdrfootertext", "hdrfootr")
		        lcOddText = Iif(Empty(lcOddText), '<oddFooter>', lcOddText) + '&amp;L&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_ODD_PAGE, HEADERFOOTER_SECT_FTR_CENTER), "xl_hdrfootertext", "hdrfootr")
		        lcOddText = Iif(Empty(lcOddText), '<oddFooter>', lcOddText) + '&amp;C&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_ODD_PAGE, HEADERFOOTER_SECT_FTR_RIGHT), "xl_hdrfootertext", "hdrfootr")
		        lcOddText = Iif(Empty(lcOddText), '<oddFooter>', lcOddText) + '&amp;R&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If !Empty(lcOddText)
		        lcOddText = lcOddText + '</oddFooter>'
		      Endif
		
		      lcEvenText = ""
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_EVEN_PAGE, HEADERFOOTER_SECT_FTR_LEFT), "xl_hdrfootertext", "hdrfootr")
		        lcEvenText = Iif(Empty(lcEvenText), '<evenFooter>', lcEvenText) + '&amp;L&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_EVEN_PAGE, HEADERFOOTER_SECT_FTR_CENTER), "xl_hdrfootertext", "hdrfootr")
		        lcEvenText = Iif(Empty(lcEvenText), '<evenFooter>', lcEvenText) + '&amp;C&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_EVEN_PAGE, HEADERFOOTER_SECT_FTR_RIGHT), "xl_hdrfootertext", "hdrfootr")
		        lcEvenText = Iif(Empty(lcEvenText), '<evenFooter>', lcEvenText) + '&amp;R&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If !Empty(lcEvenText)
		        lcEvenText = lcEvenText + '</evenFooter>'
		      Endif
		
		      lcSameText = ""
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_FTR_LEFT), "xl_hdrfootertext", "hdrfootr")
		        lcSameText = Iif(Empty(lcSameText), '<oddFooter>', lcSameText) + '&amp;L&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_FTR_CENTER), "xl_hdrfootertext", "hdrfootr")
		        lcSameText = Iif(Empty(lcSameText), '<oddFooter>', lcSameText) + '&amp;C&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_FTR_RIGHT), "xl_hdrfootertext", "hdrfootr")
		        lcSameText = Iif(Empty(lcSameText), '<oddFooter>', lcSameText) + '&amp;R&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If !Empty(lcSameText)
		        lcSameText = lcSameText + '</oddFooter>'
		      Endif
		      If Empty(lcSameText)
		        lcFooterText = lcOddText + lcEvenText
		      Else
		        lcFooterText = lcSameText
		      Endif
		
		*-*		Get the first page text
		      lcFirstHdrText = ""
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_HDR_LEFT), "xl_hdrfootertext", "hdrfootr")
		        lcFirstHdrText = Iif(Empty(lcFirstHdrText), '<firstHeader>', lcFirstHdrText) + '&amp;L&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_HDR_CENTER), "xl_hdrfootertext", "hdrfootr")
		        lcFirstHdrText = Iif(Empty(lcFirstHdrText), '<firstHeader>', lcFirstHdrText) + '&amp;C&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_HDR_RIGHT), "xl_hdrfootertext", "hdrfootr")
		        lcFirstHdrText = Iif(Empty(lcFirstHdrText), '<firstHeader>', lcFirstHdrText) + '&amp;R&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If !Empty(lcFirstHdrText)
		        lcFirstHdrText = lcFirstHdrText + '</firstHeader>'
		      Endif
		
		      lcFirstFtrText = ""
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_FTR_LEFT), "xl_hdrfootertext", "hdrfootr")
		        lcFirstFtrText = Iif(Empty(lcFirstFtrText), '<firstFooter>', lcFirstFtrText) + '&amp;L&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_FTR_CENTER), "xl_hdrfootertext", "hdrfootr")
		        lcFirstFtrText = Iif(Empty(lcFirstFtrText), '<firstFooter>', lcFirstFtrText) + '&amp;C&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If Seek(.GetHeaderFooterKeyExpr(tnWB, xl_sheets.Sheet, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_FTR_RIGHT), "xl_hdrfootertext", "hdrfootr")
		        lcFirstFtrText = Iif(Empty(lcFirstFtrText), '<firstFooter>', lcFirstFtrText) + '&amp;R&amp;' + .GetXMLHeaderFooterText()
		      Endif
		      If !Empty(lcFirstFtrText)
		        lcFirstFtrText = lcFirstFtrText + '</firstFooter>'
		      Endif
		*-*		Write the header/footer text to XML
		      Fwrite(lhFile, lcHeaderText + lcFooterText + lcFirstHdrText + lcFirstFtrText + '</headerFooter>')
		    Endif
		*-*	Completed writing sheet
		    Fwrite(lhFile, '</worksheet>')
		    llSuccess = True
		
		  Catch To loException
		    Set Step On
		    llSuccess = False
		    .ErrorLevelId = 14
		    Raiseevent(This, "OnShowErrorMessage", 14, loException.Message)
		
		  Finally
		    Fclose(lhFile)
		    .SaveAsUTF8(lcFileName)
		  Endtry
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return llSuccess
		
	ENDPROC

	PROTECTED PROCEDURE writestringsxml		&& Writes the sharedStrings XML
		Lparameters tnWB, tcPath
		Local lcFileName, lhFile, lnTotCount, lnUniqueCnt, loException, llSuccess, lnRelId
		* TODO: заменить на textmerge
		With This
		  Raiseevent(This, "OnShowStatusMessage", 2, 2)
		  Try
		    Select xl_strformat
		    Set Order To Tag sortorder
		    Count For workbook = tnWB And !Deleted() To lnTotCount
		
		    Select xl_strings
		    Set Order To Tag sortorder
		    Count For workbook = tnWB And !Deleted() To lnUniqueCnt
		    lnTotCount = lnTotCount + lnUniqueCnt
		
		    If lnUniqueCnt > 0
		*-*		If the shared strings xml has not been defined in the relationships, add it
		      If !Seek(BinToC(tnWB)+"sharedStrings", "xl_relationships", "reltype")
		        lnRelId = .GetNextId(tnWB, "xl_relationships")
		        Insert Into xl_relationships (workbook, relid, reltype, Target) Values (tnWB, lnRelId, "sharedStrings", "sharedStrings.xml")
		      Endif
		
		*-*		Output the file
		      lcFileName = tcPath + "xl\sharedStrings.xml"
		      lhFile = Fcreate(lcFileName)
		      If lhFile < 0
		        Throw
		      Endif
		
		      Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + LF)
		      Fwrite(lhFile, '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="' + Transform(lnTotCount) + '" uniqueCount="' + Transform(lnUniqueCnt) + '">')   && Change 19Jun2018: missplaced >
		
		      Select xl_strings
		      Scan For workbook = tnWB And !Deleted()
		        If xl_strings.Formatted
		          Fwrite(lhFile, '<si>')
		          Select xl_strformat
		          Scan For workbook = tnWB And Id = xl_strings.Id And !Deleted()
		            Fwrite(lhFile, '<r>')
		            If xl_strformat.fbold Or xl_strformat.fitalic Or xl_strformat.fcolor>0 Or !Empty(xl_strformat.fname) Or xl_strformat.Fsize>0 ;
		                OR xl_strformat.strkthr Or !Empty(xl_strformat.fvpos) Or xl_strformat.Theme>0 Or xl_strformat.indexed>0 Or xl_strformat.uline != UNDERLINE_NONE
		
		              Fwrite(lhFile, '<rPr>')
		              If xl_strformat.fbold
		                Fwrite(lhFile, '<b/>')
		              Endif
		              If xl_strformat.fitalic
		                Fwrite(lhFile, '<i/>')
		              Endif
		              If xl_strformat.uline != UNDERLINE_NONE
		                Fwrite(lhFile, '<u/>')
		              Endif
		              If xl_strformat.strkthr
		                Fwrite(lhFile, '<strike/>')
		              Endif
		              If xl_strformat.Fsize > 0
		                Fwrite(lhFile, '<sz val="' + Transform(xl_strformat.Fsize) + '"/>')
		              Endif
		              Do Case
		              Case xl_strformat.fcolor > 0
		                Fwrite(lhFile, '<color rgb="' + .ConvertColorToHex(xl_strformat.fcolor) +'"/>')
		
		              Case xl_strformat.indexed > 0
		                Fwrite(lhFile, '<color indexed="' + Transform(xl_strformat.indexed) + '"/>')
		
		              Case xl_strformat.Theme > 0
		                Fwrite(lhFile, '<color theme="' + Transform(xl_strformat.Theme) +'" tint="' + Transform(xl_strformat.tint, "99.999999999999999") + '"/>')
		              Endcase
		              If !Empty(xl_strformat.fvpos)
		                Fwrite(lhFile, '<vertAlign val="' + Alltrim(xl_strformat.fvpos) + '"/>')
		              Endif
		              If !Empty(xl_strformat.fname)
		                Fwrite(lhFile, '<rFont val="' + Alltrim(xl_strformat.fname) + '"/>')
		              Endif
		              Fwrite(lhFile, '</rPr>')
		            Endif
		*					IF xl_strformat.presvspace
		            Fwrite(lhFile, '<t xml:space="preserve">' + Chrtran(xl_strformat.stringxml, Chr(160), Chr(32)) + '</t>')
		*					ELSE
		*						FWRITE(lhFile, '<t>' + xl_strformat.stringxml + '</t>')
		*					ENDIF
		            Fwrite(lhFile, '</r>')
		          Endscan
		          Fwrite(lhFile, '</si>')
		          Select xl_strings
		        Else
		          If xl_strings.presvspace
		            Fwrite(lhFile, '<si><t xml:space="preserve">' + Chrtran(xl_strformat.stringxml, Chr(160), Chr(32)) + '</t></si>')
		          Else
		            Fwrite(lhFile, '<si><t>' + xl_strings.stringxml + '</t></si>')
		          Endif
		        Endif
		      Endscan
		      Set Order To
		      Fwrite(lhFile, '</sst>')
		      Fclose(lhFile)
		      Strtofile(Strconv(Filetostr(lcFileName), 9), lcFileName, 4)      && Save as UTF-8
		    Else
		*-*		No strings are assigned to cells; remove from relationships if present
		      Delete From xl_relationships Where workbook = tnWB And reltype = "sharedStrings"
		    Endif
		    llSuccess = True
		
		  Catch To loException
		    Set Step On
		    llSuccess = False
		    .ErrorLevelId = 15
		    Raiseevent(This, "OnShowErrorMessage", 15, loException.Message)
		  Endtry
		Endwith
		Return llSuccess
		
	ENDPROC

	PROTECTED PROCEDURE writestylesxml		&& Writes the styles.xml support file
		Lparameters tnWB, tcPath
		Local lcAlias, lcFileName, lhFile, lnNumFmtsId, lnRecCount, lcNumFmtId, lnRotation, llIndexedColors
		Local llMruColors
		* TODO: заменить на textmerge
		With This
		  Raiseevent(This, "OnShowStatusMessage", 2, 3)
		  Try
		    lcAlias = Alias()
		    lcFileName = tcPath + "xl\styles.xml"
		    lhFile = Fcreate(lcFileName)
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" ')
		    Fwrite(lhFile, 'xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" ')
		    Fwrite(lhFile, 'mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">')
		
		*-*	Get last used custom number format Id
		    lnNumFmtsId = 0
		    Select xl_numfmts
		    Set Order To Tag sortorder
		    Scan For workbook = tnWB And xl_numfmts.Id < 900
		      If xl_numfmts.Id > lnNumFmtsId
		        lnNumFmtsId = xl_numfmts.Id
		      Endif
		    Endscan
		
		*-*	Write the Number format section
		    Count For workbook = tnWB To lnRecCount
		    Fwrite(lhFile, '<numFmts count="' + Transform(lnRecCount) + '">')
		    Scan For workbook = tnWB
		      If xl_numfmts.Id > 900
		        lnNumFmtsId = lnNumFmtsId + 1
		        Fwrite(lhFile, '<numFmt numFmtId="' + Transform(lnNumFmtsId) + '" formatCode="' + Alltrim(xl_numfmts.formatxml) + '"/>')
		        Replace xl_numfmts.tempid With lnNumFmtsId In xl_numfmts
		      Else
		        Fwrite(lhFile, '<numFmt numFmtId="' + Transform(xl_numfmts.Id) + '" formatCode="' + Alltrim(xl_numfmts.formatxml) + '"/>')
		        Replace xl_numfmts.tempid With xl_numfmts.Id In xl_numfmts
		      Endif
		    Endscan
		    Fwrite(lhFile, '</numFmts>')
		    Set Order To
		
		*-*	Write the fonts section
		    Select xl_fonts
		    Set Order To Tag sortorder
		    Count For workbook = tnWB To lnRecCount
		    Fwrite(lhFile, '<fonts count="' + Transform(lnRecCount) + '" x14ac:knownFonts="1">')
		    Scan For workbook = tnWB
		      Fwrite(lhFile, '<font>')
		      Fwrite(lhFile, '<name val="' + Alltrim(xl_fonts.fname) + '"/>')
		      Fwrite(lhFile, '<sz val="' + Transform(xl_fonts.Fsize) + '"/>')
		      If xl_fonts.fbold
		        Fwrite(lhFile, '<b/>')
		      Endif
		      If xl_fonts.fitalic
		        Fwrite(lhFile, '<i/>')
		      Endif
		      If !Empty(xl_fonts.uline)
		        Fwrite(lhFile, '<u val="' + Alltrim(xl_fonts.uline) + '"/>')
		      Endif
		      If xl_fonts.strkthr
		        Fwrite(lhFile, '<strike/>')
		      Endif
		      If !Empty(xl_fonts.fvpos)
		        Fwrite(lhFile, '<vertAlign val="' + Alltrim(xl_fonts.fvpos) + '"/>')
		      Endif
		      Do Case
		      Case xl_fonts.fcolor > 0
		        Fwrite(lhFile, '<color rgb="' + .ConvertColorToHex(xl_fonts.fcolor) + '"/>')
		
		      Case xl_fonts.indexed > 0
		        Fwrite(lhFile, '<color indexed="' + Transform(xl_fonts.indexed) + '"/>')
		
		      Case xl_fonts.Theme > 0
		        Fwrite(lhFile, '<color theme="' + Transform(xl_fonts.Theme) + '" tint="' + Transform(xl_fonts.tint, "99.999999999999999") + '"/>')
		      Endcase
		      Fwrite(lhFile, '</font>')
		    Endscan
		    Fwrite(lhFile, '</fonts>')
		    Set Order To
		
		*-*	Write the fills section
		    Select xl_fills
		    Set Order To Tag sortorder
		    Count For workbook = tnWB To lnRecCount
		    Fwrite(lhFile, '<fills count="' + Transform(lnRecCount) + '">')
		    Scan For workbook = tnWB
		      Fwrite(lhFile, '<fill><patternFill patternType="' + Alltrim(xl_fills.patttype) + '"')
		      Do Case
		      Case xl_fills.fgindexed > 0 And xl_fills.bgindexed > 0
		        Fwrite(lhFile, '>')
		        Fwrite(lhFile, '<fgColor indexed="' + Transform(xl_fills.fgindexed) + '"/>')
		        Fwrite(lhFile, '<bgColor indexed="' + Transform(xl_fills.bgindexed) + '"/>')
		        Fwrite(lhFile, '</patternFill>')
		
		      Case xl_fills.fgcolor > 0 And xl_fills.bgindexed > 0
		        Fwrite(lhFile, '>')
		        Fwrite(lhFile, '<fgColor rgb="' + .ConvertColorToHex(xl_fills.fgcolor) + '"/>')
		        Fwrite(lhFile, '<bgColor indexed="' + Transform(xl_fills.bgindexed) + '"/>')
		        Fwrite(lhFile, '</patternFill>')
		
		      Case xl_fills.bgcolor > 0 And xl_fills.fgindexed > 0
		        Fwrite(lhFile, '>')
		        Fwrite(lhFile, '<fgColor indexed="' + Transform(xl_fills.fgindexed) + '"/>')
		        Fwrite(lhFile, '<bgColor rgb="' + .ConvertColorToHex(xl_fills.bgcolor) + '"/>')
		        Fwrite(lhFile, '</patternFill>')
		
		      Case xl_fills.fgcolor > 0 And xl_fills.bgcolor > 0
		        Fwrite(lhFile, '>')
		        Fwrite(lhFile, '<fgColor rgb="' + .ConvertColorToHex(xl_fills.fgcolor) + '"/>')
		        Fwrite(lhFile, '<bgColor rgb="' + .ConvertColorToHex(xl_fills.bgcolor) + '"/>')
		        Fwrite(lhFile, '</patternFill>')
		
		      Case xl_fills.Theme > 0
		        Fwrite(lhFile, '>')
		        Fwrite(lhFile, '<fgColor theme="' + Transform(xl_fills.Theme) + '" tint="' + Transform(xl_fills.tint, "99.999999999999999") + '"/>')
		        Fwrite(lhFile, '<bgColor indexed="64"/>')
		        Fwrite(lhFile, '</patternFill>')
		
		      Otherwise
		        Fwrite(lhFile, '/>')
		      Endcase
		      Fwrite(lhFile, '</fill>')
		    Endscan
		    Fwrite(lhFile, '</fills>')
		
		*-*	Write the borders section
		    Select xl_borders
		    Set Order To Tag sortorder
		    Count For workbook = tnWB To lnRecCount
		    Fwrite(lhFile, '<borders count="' + Transform(lnRecCount) + '">')
		    Scan For workbook = tnWB
		      Fwrite(lhFile, '<border' + Iif(xl_borders.diagdn=1, ' diagonalDown="1"', '') + Iif(xl_borders.diagup=1, ' diagonalUp="1"', '') +'>')
		      If Empty(xl_borders.lstyle)
		        Fwrite(lhFile, '<left/>')
		      Else
		        If xl_borders.lstyle = BORDER_STYLE_NONE
		          Fwrite(lhFile, '<left')
		        Else
		          Fwrite(lhFile, '<left style="' + Alltrim(xl_borders.lstyle) + '"')
		        Endif
		        Do Case
		        Case xl_borders.lcolor > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color rgb="' + .ConvertColorToHex(xl_borders.lcolor) + '"/>')
		          Fwrite(lhFile, '</left>')
		
		        Case xl_borders.lindexed > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color indexed="' + Transform(xl_borders.lindexed) + '"/>')
		          Fwrite(lhFile, '</left>')
		
		        Case xl_borders.ltheme > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color theme="' + Transform(xl_borders.ltheme) +'" tint="' + Transform(xl_borders.ltint, "99.999999999999999") + '"/>')
		          Fwrite(lhFile, '</left>')
		
		        Otherwise
		          Fwrite(lhFile, '/>')
		        Endcase
		      Endif
		      If Empty(xl_borders.rstyle)
		        Fwrite(lhFile, '<right/>')
		      Else
		        If xl_borders.rstyle = BORDER_STYLE_NONE
		          Fwrite(lhFile, '<right')
		        Else
		          Fwrite(lhFile, '<right style="' + Alltrim(xl_borders.rstyle) + '"')
		        Endif
		        Do Case
		        Case xl_borders.rcolor > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color rgb="' + .ConvertColorToHex(xl_borders.rcolor) + '"/>')
		          Fwrite(lhFile, '</right>')
		
		        Case xl_borders.rindexed > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color indexed="' + Transform(xl_borders.rindexed) + '"/>')
		          Fwrite(lhFile, '</right>')
		
		
		        Case xl_borders.rtheme > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color theme="' + Transform(xl_borders.rtheme) +'" tint="' + Transform(xl_borders.rtint, "99.999999999999999") + '"/>')
		          Fwrite(lhFile, '</right>')
		
		        Otherwise
		          Fwrite(lhFile, '/>')
		        Endcase
		      Endif
		      If Empty(xl_borders.tstyle)
		        Fwrite(lhFile, '<top/>')
		      Else
		        If xl_borders.tstyle = BORDER_STYLE_NONE
		          Fwrite(lhFile, '<top')
		        Else
		          Fwrite(lhFile, '<top style="' + Alltrim(xl_borders.tstyle) + '"')
		        Endif
		        Do Case
		        Case xl_borders.tcolor > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color rgb="' + .ConvertColorToHex(xl_borders.tcolor) + '"/>')
		          Fwrite(lhFile, '</top>')
		
		        Case xl_borders.tindexed > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color indexed="' + Transform(xl_borders.tindexed) + '"/>')
		          Fwrite(lhFile, '</top>')
		
		        Case xl_borders.ttheme > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color theme="' + Transform(xl_borders.ttheme) +'" tint="' + Transform(xl_borders.ttint, "99.999999999999999") + '"/>')
		          Fwrite(lhFile, '</top>')
		
		        Otherwise
		          Fwrite(lhFile, '/>')
		        Endcase
		      Endif
		      If Empty(xl_borders.bstyle)
		        Fwrite(lhFile, '<bottom/>')
		      Else
		        If xl_borders.bstyle = BORDER_STYLE_NONE
		          Fwrite(lhFile, '<bottom')
		        Else
		          Fwrite(lhFile, '<bottom style="' + Alltrim(xl_borders.bstyle) + '"')
		        Endif
		        Do Case
		        Case xl_borders.bcolor > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color rgb="' + .ConvertColorToHex(xl_borders.bcolor) + '"/>')
		          Fwrite(lhFile, '</bottom>')
		
		        Case xl_borders.bindexed > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color indexed="' + Transform(xl_borders.bindexed) + '"/>')
		          Fwrite(lhFile, '</bottom>')
		
		        Case xl_borders.btheme > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color theme="' + Transform(xl_borders.btheme) +'" tint="' + Transform(xl_borders.btint, "99.999999999999999") + '"/>')
		          Fwrite(lhFile, '</bottom>')
		
		        Otherwise
		          Fwrite(lhFile, '/>')
		        Endcase
		      Endif
		      If Empty(xl_borders.dstyle)
		        Fwrite(lhFile, '<diagonal/>')
		      Else
		        If xl_borders.dstyle = BORDER_STYLE_NONE
		          Fwrite(lhFile, '<diagonal')
		        Else
		          Fwrite(lhFile, '<diagonal style="' + Alltrim(xl_borders.dstyle) + '"')
		        Endif
		        Do Case
		        Case xl_borders.dcolor > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color rgb="' + .ConvertColorToHex(xl_borders.dcolor) + '"/>')
		          Fwrite(lhFile, '</diagonal>')
		
		        Case xl_borders.dindexed > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color indexed="' + Transform(xl_borders.dindexed) + '"/>')
		          Fwrite(lhFile, '</diagonal>')
		
		        Case xl_borders.dtheme > 0
		          Fwrite(lhFile, '>')
		          Fwrite(lhFile, '<color theme="' + Transform(xl_borders.dtheme) +'" tint="' + Transform(xl_borders.dtint, "99.999999999999999") + '"/>')
		          Fwrite(lhFile, '</diagonal>')
		
		        Otherwise
		          Fwrite(lhFile, '/>')
		        Endcase
		      Endif
		      Fwrite(lhFile, '</border>')
		    Endscan
		    Fwrite(lhFile, '</borders>')
		*-*	Write the cellStyleXfs section
		
		*-*	Write the cellXfs section
		    Select xl_cellxfs
		    Set Order To Tag sortorder
		    Count For workbook = tnWB To lnRecCount
		    Fwrite(lhFile, '<cellXfs count="' + Transform(lnRecCount) + '">')
		    Scan For workbook = tnWB
		      If xl_cellxfs.numFmtId > 0 And Seek(BinToC(tnWB)+BinToC(xl_cellxfs.numFmtId), "xl_numfmts", "id")
		        lcNumFmtId = Transform(xl_numfmts.tempid)
		      Else
		        lcNumFmtId = Transform(xl_cellxfs.numFmtId)
		      Endif
		      Fwrite(lhFile, '<xf numFmtId="' + lcNumFmtId + '" fontId="' + Transform(xl_cellxfs.fontid) + ;
		        '" fillId="' + Transform(xl_cellxfs.fillid) + '" borderId="' + Transform(xl_cellxfs.borderid) + '"' + ;
		        IIF(lcNumFmtId = '0', '', ' applyNumberFormat="1"') + Iif(xl_cellxfs.fontid > 0, ' applyFont="1"', '') + ;
		        IIF(xl_cellxfs.fillid > 0, ' applyFill="1"', '') + Iif(xl_cellxfs.borderid > 0, ' applyBorder="1"', '') + ' applyAlignment="1"')
		
		      If !Empty(xl_cellxfs.halign) Or !Empty(xl_cellxfs.valign) Or xl_cellxfs.wraptext > 0 Or xl_cellxfs.indent > 0 Or xl_cellxfs.Rotation > 0
		        Fwrite(lhFile, '><alignment')
		        If !Empty(xl_cellxfs.halign)
		          Fwrite(lhFile, ' horizontal="' + Alltrim(xl_cellxfs.halign) + '"')
		        Endif
		        If !Empty(xl_cellxfs.valign)
		          Fwrite(lhFile, ' vertical="' + Alltrim(xl_cellxfs.valign) + '"')
		        Endif
		        If xl_cellxfs.wraptext > 0
		          Fwrite(lhFile, ' wrapText="1"')
		        Endif
		        If xl_cellxfs.indent > 0
		          Fwrite(lhFile, ' indent="' + Transform(xl_cellxfs.indent) + '"')
		        Endif
		        If xl_cellxfs.Rotation != 0
		          Fwrite(lhFile, ' textRotation="' + Transform(xl_cellxfs.Rotation) + '"')
		        Endif
		        Fwrite(lhFile, '/></xf>')
		      Else
		        Fwrite(lhFile, '/>')
		      Endif
		    Endscan
		    Fwrite(lhFile, '</cellXfs>')
		
		*-*	Write the colors section
		    llIndexedColors = Seek(BinToC(tnWB)+BinToC(1), "xl_ndxcolors", "indexid")
		    llMruColors     = Seek(BinToC(tnWB)+BinToC(1), "xl_mrucolors", "indexid")
		    If llIndexedColors Or llMruColors
		      Fwrite(lhFile, '<colors>')
		      If llIndexedColors
		        Fwrite(lhFile, '<indexedColors>')
		        Select xl_ndxcolors
		        Set Order To Tag indexid
		        Scan For workbook = tnWB
		          Fwrite(lhFile, '<rgbColor rgb="' + xl_ndxcolors.rgbcolor + '"/>')
		        Endscan
		        Fwrite(lhFile, '</indexedColors>')
		      Endif
		
		      If llMruColors
		        Fwrite(lhFile, '<mruColors>')
		        Select xl_mrucolors
		        Set Order To Tag indexid
		        Scan For workbook = tnWB
		          Fwrite(lhFile, '<color rgb="' + xl_ndxcolors.rgbcolor + '"/>')
		        Endscan
		        Fwrite(lhFile, '</mruColors>')
		      Endif
		      Fwrite(lhFile, '</colors>')
		    Endif
		
		*-*	Close the style sheet
		    Fwrite(lhFile, '</styleSheet>')
		    llSuccess = True
		
		  Catch To loException
		    Set Step On
		    llSuccess = False
		    .ErrorLevelId = 17
		    Raiseevent(This, "OnShowErrorMessage", 17, "Unable to create styles.xml")
		
		  Finally
		    Fclose(lhFile)
		    .SaveAsUTF8(lcFileName)
		  Endtry
		  If !Empty(lcAlias)
		    Select (lcAlias)
		  Endif
		Endwith
		Return llSuccess
		
	ENDPROC

	PROTECTED PROCEDURE writesupportxmls		&& Writes the [Content_Types].xml, .rels, core.xml, workbook.xml.rels and app.xml files
		Lparameters tnWB, tcPath
		Local llSuccess, loException, lhFile, lnSheet, lnUniqueCnt, lcCurr, lcColor, lnTotCount, lcFileName, lcBaseContentType
		* TODO: заменить на textmerge
		With This
		  Raiseevent(This, "OnShowStatusMessage", 2, 1)
		  Try
		    lhFile  = Fcreate(tcPath + "[Content_Types].xml")
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">')
		    Fwrite(lhFile, '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>')
		    Fwrite(lhFile, '<Default Extension="xml" ContentType="application/xml"/>')
		    Fwrite(lhFile, '<Override ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" PartName="/xl/workbook.xml"/>')
		
		    lcBaseContentType = '<Override ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.'
		    Select xl_relationships
		    Scan For workbook = tnWB And !Deleted()
		      Do Case
		      Case xl_relationships.reltype = "calcChain"
		*				FWRITE(lhFile, lcBaseContentType + 'calcChain+xml" PartName="/xl/calcChain.xml"/>')
		
		      Case xl_relationships.reltype = "drawings"
		*				FWRITE(lhFile, lcBaseContentType + 'drawing+xml" PartName="/xl/drawings/drawing1.xml"/>')
		
		      Case xl_relationships.reltype = "externalLink"
		*				FWRITE(lhFile, lcBaseContentType + 'externalLink+xml" PartName="/xl/externalLinks/externalLink1.xml"/>')
		
		      Case xl_relationships.reltype = "sharedStrings"
		        Fwrite(lhFile, lcBaseContentType + 'sharedStrings+xml" PartName="/xl/sharedStrings.xml"/>')
		
		      Case xl_relationships.reltype = "styles"
		        Fwrite(lhFile, lcBaseContentType + 'styles+xml" PartName="/xl/styles.xml"/>')
		
		      Case xl_relationships.reltype = "theme"
		*				FWRITE(lhFile, lcBaseContentType + 'theme+xml" PartName="/xl/theme/theme1.xml"/>')
		
		      Case xl_relationships.reltype = "worksheet"
		        Fwrite(lhFile, lcBaseContentType + 'worksheet+xml" PartName="/xl/worksheets/sheet' + Transform(xl_relationships.Sheet) + '.xml"/>')
		      Endcase
		    Endscan
		
		    Fwrite(lhFile, '<Override ContentType="application/vnd.openxmlformats-package.core-properties+xml" PartName="/docProps/core.xml"/>')
		    Fwrite(lhFile, '<Override ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml" PartName="/docProps/app.xml"/>')
		    Fwrite(lhFile, '</Types>')
		    Fclose(lhFile)
		
		*-*	Save the .rels XML
		    lhFile = Fcreate(tcPath + "_rels\.rels")
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">')
		    Fwrite(lhFile, '<Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>')
		    Fwrite(lhFile, '<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>')
		    Fwrite(lhFile, '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>')
		    Fwrite(lhFile, '</Relationships>')
		    Fclose(lhFile)
		
		*-*	Save the app XML
		    lcFileName = tcPath + "docProps\app.xml"
		    lhFile = Fcreate(lcFileName)
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">')
		    Fwrite(lhFile, '<Application>ExcelXMLX Release ' + Transform(.ExcelXlsxRelease) + '</Application>')
		    If !Empty(.CompanyName)
		      Fwrite(lhFile, '<Company>' + .CompanyName + '</Company>')
		    Endif
		    Fwrite(lhFile, '</Properties>')
		    Fclose(lhFile)
		    Strtofile(Strconv(Filetostr(lcFileName), 9), lcFileName, 4)      && Save as UTF-8
		
		*-*	Save the core XML
		    lcFileName = tcPath + "docProps\core.xml"
		    lhFile = Fcreate(lcFileName)
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
		    Fwrite(lhFile, '<cp:coreProperties ')
		    Fwrite(lhFile, 'xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" ')
		    Fwrite(lhFile, 'xmlns:dc="http://purl.org/dc/elements/1.1/" ')
		    Fwrite(lhFile, 'xmlns:dcterms="http://purl.org/dc/terms/" ')
		    Fwrite(lhFile, 'xmlns:dcmitype="http://purl.org/dc/dcmitype/" ')
		    Fwrite(lhFile, 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">')
		    If !Empty(.Title)
		      Fwrite(lhFile, '<dc:title>' + .GetXMLString(.Title) + '</dc:title>')
		    Endif
		    If !Empty(.Subject)
		      Fwrite(lhFile, '<dc:subject>' + .GetXMLString(.Subject) + '</dc:subject>')
		    Endif
		    If !Empty(.CreatorName)
		      Fwrite(lhFile, '<dc:creator>' + .GetXMLString(.CreatorName) + '</dc:creator>')
		    Endif
		    If !Empty(.UserName)
		      Fwrite(lhFile, '<cp:lastModifiedBy>' + .GetXMLString(.UserName) + '</cp:lastModifiedBy>')
		    Endif
		    If Version(5) < 900
		      Fwrite(lhFile, '<dcterms:created xsi:type="dcterms:W3CDTF">' + .TTOC3(Datetime()) + 'Z</dcterms:created>')
		      Fwrite(lhFile, '<dcterms:modified xsi:type="dcterms:W3CDTF">' + .TTOC3(Datetime()) + 'Z</dcterms:modified>')
		    Else
		      Fwrite(lhFile, '<dcterms:created xsi:type="dcterms:W3CDTF">' + Ttoc(Datetime(), 3) + 'Z</dcterms:created>')
		      Fwrite(lhFile, '<dcterms:modified xsi:type="dcterms:W3CDTF">' + Ttoc(Datetime(), 3) + 'Z</dcterms:modified>')
		    Endif
		    Fwrite(lhFile, '</cp:coreProperties>')
		    Fclose(lhFile)
		    Strtofile(Strconv(Filetostr(lcFileName), 9), lcFileName, 4)      && Save as UTF-8
		
		    llSuccess = True
		
		  Catch To loException
		    Set Step On
		    llSuccess = False
		    .ErrorLevelId = 18
		    Raiseevent(This, "OnShowErrorMessage", 18, "Unable to create workbook supporting XMLs")
		  Endtry
		Endwith
		Return llSuccess
		
	ENDPROC

	PROTECTED PROCEDURE writeworkbookxml		&& Writes the workbook XML
		Lparameters tnWB, tcPath
		Local lcFileName, lhFile, loException, llSuccess, lcSheetName
		* TODO: заменить на textmerge
		With This
		  Raiseevent(This, "OnShowStatusMessage", 2, 4)
		  Try
		    lcFileName = tcPath + "xl\workbook.xml"
		    lhFile = Fcreate(lcFileName)
		    If lhFile < 0
		      Throw
		    Endif
		    Fwrite(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+ LF)
		    Fwrite(lhFile, '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">')
		
		*-*	Write thw sheet information
		    Fwrite(lhFile, '<sheets>')
		    Select xl_relationships
		    Set Order To Tag relid
		    Scan For workbook = tnWB And reltype = "worksheet"
		      If Seek(BinToC(tnWB)+BinToC(xl_relationships.Sheet), "xl_sheets", "sheetndx")
		        Do Case
		        Case xl_sheets.state = VISIBLE_SHEET_STATE
		          Fwrite(lhFile, '<sheet r:id="rId' + Transform(xl_relationships.relid) + '" sheetId="' + Transform(xl_relationships.Sheet) + '" name="' + Alltrim(xl_sheets.shname) + '"/>')
		
		        Case xl_sheets.state = HIDDEN_SHEET_STATE
		          Fwrite(lhFile, '<sheet r:id="rId' + Transform(xl_relationships.relid) + '" sheetId="' + Transform(xl_relationships.Sheet) + '" state="hidden" name="' + Alltrim(xl_sheets.shname) + '"/>')
		
		        Case xl_sheets.state = VERYHIDDEN_SHEET_STATE
		          Fwrite(lhFile, '<sheet r:id="rId' + Transform(xl_relationships.relid) + '" sheetId="' + Transform(xl_relationships.Sheet) + '" state="veryHidden" name="' + Alltrim(xl_sheets.shname) + '"/>')
		        Endcase
		      Else
		        Throw
		      Endif
		    Endscan
		    Set Order To
		    Fwrite(lhFile, '</sheets>')
		
		*-*	Write the named range information
		    Select xl_namerange
		    Locate For workbook = tnWB And !Deleted()
		    If Found()
		      Fwrite(lhFile, '<definedNames>')
		      Scan For workbook = tnWB And !Deleted()
		        If (xl_namerange.begcol = 0 And xl_namerange.begrow = 0) Or (xl_namerange.begcol = 0 And xl_namerange.begrow = 0)
		          Loop
		        Endif
		        Fwrite(lhFile, '<definedName name="' + Alltrim(xl_namerange.rname) + '"')
		        If !Empty(xl_namerange.Comment)
		          Fwrite(lhFile, ' comment="' + Alltrim(xl_namerange.Comment) + '"')
		        Endif
		        If xl_namerange.scope = SCOPE_SH_NAMED_RANGE
		          Fwrite(lhFile, ' localSheetId="' + Transform(xl_namerange.Sheet) + '"')
		        Endif
		        Fwrite(lhFile, '>')
		
		        lcSheetName = .GetSheetName(tnWB, xl_namerange.Sheet)
		        Fwrite(lhFile, Iif(Occurs(" ", lcSheetName)>0, "'", "") + lcSheetName + Iif(Occurs(" ", lcSheetName)>0, "'", ""))
		        Do Case
		        Case xl_namerange.begcol = 0 And xl_namerange.begrow > 0
		          Fwrite(lhFile, '!$' + Transform(xl_namerange.begrow))
		
		        Case xl_namerange.begcol > 0 And xl_namerange.begrow = 0
		          Fwrite(lhFile, '!$' + .ColumnIndexToAscii(xl_namerange.begcol))
		
		        Otherwise
		          Fwrite(lhFile, '!$' + .ColumnIndexToAscii(xl_namerange.begcol) + '$' + Transform(xl_namerange.begrow))
		        Endcase
		        Do Case
		        Case xl_namerange.endcol = 0 And xl_namerange.endrow > 0
		          Fwrite(lhFile, ':$' + Transform(xl_namerange.endrow))
		
		        Case xl_namerange.endcol > 0 And xl_namerange.begrow = 0
		          Fwrite(lhFile, ':$' + .ColumnIndexToAscii(xl_namerange.endcol))
		
		        Otherwise
		          Fwrite(lhFile, ':$' + .ColumnIndexToAscii(xl_namerange.endcol) + '$' + Transform(xl_namerange.endrow))
		        Endcase
		        Fwrite(lhFile, '</definedName>')
		      Endscan
		      Fwrite(lhFile, '</definedNames>')
		    Endif
		
		*-*	Close the workbook
		    Fwrite(lhFile, '<calcPr calcId="0"/>')
		    Fwrite(lhFile, '</workbook>')
		
		    llSuccess = True
		
		  Catch To loException
		    Fclose(lhFile)
		    Set Step On
		    llSuccess = False
		
		  Finally
		    Fclose(lhFile)
		    .SaveAsUTF8(lcFileName)
		  Endtry
		Endwith
		Return llSuccess
		
	ENDPROC

ENDDEFINE
